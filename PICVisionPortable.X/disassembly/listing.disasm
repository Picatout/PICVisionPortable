Disassembly Listing for CHIPCON_Portable
Generated From:
C:/Users/Jacques/Documents/GitHub/PicVisionPortable/PICVisionPortable.X/dist/default/production/PICVisionPortable.X.production.elf
2015-02-26 20:08:01

---  C:/Users/Jacques/Documents/GitHub/PicVisionPortable/PICVisionPortable.X/tone.c  --------------------
1:                 /*
2:                 * Copyright 2014, Jacques Deschênes
3:                 * This file is part of CHIPcon.
4:                 *
5:                 *     CHIPcon is free software: you can redistribute it and/or modify
6:                 *     it under the terms of the GNU General Public License as published by
7:                 *     the Free Software Foundation, either version 3 of the License, or
8:                 *     (at your option) any later version.
9:                 *
10:                *     CHIPcon is distributed in the hope that it will be useful,
11:                *     but WITHOUT ANY WARRANTY; without even the implied warranty of
12:                *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
13:                *     GNU General Public License for more details.
14:                *
15:                *     You should have received a copy of the GNU General Public License
16:                *     along with CHIPcon.  If not, see <http://www.gnu.org/licenses/>.
17:                */
18:                
19:                /*
20:                 * tones.c
21:                 *
22:                 * Created: 2014-09-26 10:17:59
23:                 *  Author: Jacques Deschênes
24:                 */ 
25:                
26:                
27:                #include "tone.h"
28:                
29:                
30:                
31:                volatile unsigned tone_timer;
32:                
33:                
34:                
35:                // fréquence en hertz
36:                // durée en  millisecondes
37:                void tone(uint16_t freq, unsigned length){
004A58  781F88     MOV W8, [W15++]
004A5A  780401     MOV W1, W8
38:                    TONE_TRIS &= ~TONE_OUT;
004A5C  A982C8     BCLR TRISB, #4
39:                    TONE_OCCON &=~7; // OC off
004A5E  2FFF84     MOV #0xFFF8, W4
004A60  2018A5     MOV #0x18A, W5
004A62  620A95     AND W4, [W5], [W5]
40:                    TONE_PER = ((FCY/freq)>>1)-1;
004A64  B80161     MUL.UU W0, #1, W2
004A66  224000     MOV #0x2400, W0
004A68  200F41     MOV #0xF4, W1
004A6A  07DC21     RCALL ___udivsi3
004A6C  D10281     LSR W1, W5
004A6E  D38200     RRC W0, W4
004A70  E90204     DEC W4, W4
004A72  880864     MOV W4, PR2
41:                    TONE_DC = ((FCY/freq)>>2);
004A74  DE0AC2     LSR W1, #2, W5
004A76  DD0B4E     SL W1, #14, W6
004A78  DE0242     LSR W0, #2, W4
004A7A  730204     IOR W6, W4, W4
004A7C  880C34     MOV W4, OC2RS
42:                    TONE_IDC = ((FCY/freq)>>2);
004A7E  880C44     MOV W4, OC2R
43:                    TONE_OCCON |= 3; // toggle output on compare
004A80  200030     MOV #0x3, W0
004A82  B7218A     IOR OC2CON
44:                    tone_on();
004A84  280000     MOV #0x8000, W0
004A86  B72110     IOR T2CON
45:                    tone_timer = length;
004A88  88EA78     MOV W8, tone_timer
46:                }
004A8A  78044F     MOV [--W15], W8
004A8C  060000     RETURN
47:                
48:                const uint16_t SCALE[16]={523,554,587,622,659,698,740,784,831,880,932,988,1047,1109,1175,1245};
49:                	
50:                inline void key_tone(uint8_t key, unsigned length,bool wait_end){
004A8E  781F88     MOV W8, [W15++]
004A90  784402     MOV.B W2, W8
51:                	tone(SCALE[key&15],length);	
004A92  60006F     AND W0, #0xF, W0
004A94  400000     ADD W0, W0, W0
004A96  2A8F84     MOV #0xA8F8, W4
004A98  780064     MOV [W4+W0], W0
004A9A  07FFDE     RCALL tone
52:                	if (wait_end) wait_tone_end();
004A9C  544FE0     SUB.B W8, #0x0, [W15]
004A9E  320003     BRA Z, 0x4AA6
004AA0  80EA74     MOV tone_timer, W4
004AA2  520FE0     SUB W4, #0x0, [W15]
004AA4  3AFFFD     BRA NZ, 0x4AA0
53:                }
004AA6  78044F     MOV [--W15], W8
004AA8  060000     RETURN
54:                
55:                
56:                void noise(unsigned length){
004AAA  781F88     MOV W8, [W15++]
004AAC  780400     MOV W0, W8
57:                    tone(rand()&0xffff,length);
004AAE  07DC35     RCALL _rand
004AB0  780088     MOV W8, W1
004AB2  07FFD2     RCALL tone
58:                    TONE_IF=0;
004AB4  A9E084     BCLR IFS0, #7
59:                    TONE_IE=1;
004AB6  A8E094     BSET IEC0, #7
60:                    /*
61:                    while (tone_timer){
62:                        TONE_PER=rand();
63:                        TONE_DC=TONE_PER>>1;
64:                    }
65:                     */
66:                }//f()
004AB8  78044F     MOV [--W15], W8
004ABA  060000     RETURN
67:                
68:                void __attribute__((interrupt,no_auto_psv)) _T2Interrupt(void){
004ABC  F80036     PUSH RCOUNT
004ABE  BE9F80     MOV.D W0, [W15++]
004AC0  BE9F82     MOV.D W2, [W15++]
004AC2  BE9F84     MOV.D W4, [W15++]
004AC4  BE9F86     MOV.D W6, [W15++]
69:                    TONE_PER=rand()|1024;
004AC6  07DC29     RCALL _rand
004AC8  A0A000     BSET W0, #10
004ACA  880860     MOV W0, PR2
70:                    TONE_DC=TONE_PER>>1;
004ACC  D5010C     LSR PR2, WREG
004ACE  880C30     MOV W0, OC2RS
71:                    TONE_IF=0;
004AD0  A9E084     BCLR IFS0, #7
72:                }//f()
004AD2  BE034F     MOV.D [--W15], W6
004AD4  BE024F     MOV.D [--W15], W4
004AD6  BE014F     MOV.D [--W15], W2
004AD8  BE004F     MOV.D [--W15], W0
004ADA  F90036     POP RCOUNT
004ADC  064000     RETFIE
73:                
---  C:/Users/Jacques/Documents/GitHub/PicVisionPortable/PICVisionPortable.X/text.c  --------------------
1:                 /*
2:                 * Copyright 2014, Jacques Deschênes
3:                 * This file is part of CHIPcon.
4:                 *
5:                 *     CHIPcon is free software: you can redistribute it and/or modify
6:                 *     it under the terms of the GNU General Public License as published by
7:                 *     the Free Software Foundation, either version 3 of the License, or
8:                 *     (at your option) any later version.
9:                 *
10:                *     CHIPcon is distributed in the hope that it will be useful,
11:                *     but WITHOUT ANY WARRANTY; without even the implied warranty of
12:                *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
13:                *     GNU General Public License for more details.
14:                *
15:                *     You should have received a copy of the GNU General Public License
16:                *     along with CHIPcon.  If not, see <http://www.gnu.org/licenses/>.
17:                */
18:                
19:                /*
20:                 * console.c
21:                 *
22:                 * Created: 2014-09-30 22:31:27
23:                 *  Author: Jacques Deschênes
24:                 */ 
25:                
26:                #include "hardware/HardwareProfile.h"
27:                #include "Hardware/LCDout.h"
28:                #include "keypad.h"
29:                #include "display.h"
30:                #include "text.h"
31:                
32:                // police 4x5 hexadécimale
33:                const uint8_t font_hex_4x6[16*SHEX_HEIGHT]={
34:                	0xe0,0xa0,0xa0,0xa0,0xe0,0x00, //0
35:                	0xc0,0x40,0x40,0x40,0xe0,0x00, //1
36:                	0xe0,0x20,0xe0,0x80,0xe0,0x00, //2
37:                	0xe0,0x20,0xe0,0x20,0xe0,0x00, //3
38:                	0xa0,0xa0,0xe0,0x20,0x20,0x00, //4
39:                	0xe0,0x80,0xe0,0x20,0xe0,0x00, //5
40:                	0x80,0x80,0xe0,0xa0,0xe0,0x00, //6
41:                	0xe0,0x20,0x20,0x20,0x20,0x00, //7
42:                	0xe0,0xa0,0xe0,0xa0,0xe0,0x00, //8
43:                	0xe0,0xa0,0xe0,0x20,0x20,0x00, //9
44:                	0xe0,0xa0,0xe0,0xa0,0xa0,0x00, //A
45:                	0xc0,0xa0,0xc0,0xa0,0xc0,0x00, //B
46:                	0xe0,0x80,0x80,0x80,0xe0,0x00, //C
47:                	0xc0,0xa0,0xa0,0xa0,0xc0,0x00, //D
48:                	0xe0,0x80,0xe0,0x80,0xe0,0x00, //E
49:                	0xe0,0x80,0xe0,0x80,0x80,0x00,  //F
50:                	};
51:                	
52:                // police 8x10 hexadécimale	
53:                const uint8_t font_hex_8x10[16*LHEX_HEIGHT]={
54:                	0x7c,0x82,0x86,0x8a,0x92,0xa2,0xc2,0x82,0x7c,0x00, // 0
55:                	0x08,0x18,0x28,0x08,0x08,0x08,0x08,0x08,0x3e,0x00, // 1
56:                	0x38,0x44,0x82,0x04,0x08,0x10,0x20,0x40,0xfe,0x00, // 2
57:                	0x38,0x44,0x82,0x02,0x3c,0x02,0x82,0x44,0x38,0x00, // 3
58:                	0x84,0x84,0x84,0x84,0x7e,0x04,0x04,0x04,0x04,0x00, // 4
59:                	0x7e,0x80,0x80,0x80,0x7c,0x02,0x02,0x02,0xfe,0x00, // 5
60:                	0x78,0x84,0x80,0x80,0xfc,0x82,0x82,0x82,0x7c,0x00, // 6
61:                	0x7e,0x82,0x04,0x08,0x08,0x08,0x08,0x08,0x08,0x00, // 7
62:                	0x38,0x44,0x82,0x82,0x7c,0x82,0x82,0x44,0x38,0x00, // 8
63:                	0x38,0x44,0x82,0x82,0x46,0x3a,0x02,0x04,0x38,0x00, // 9
64:                	0x38,0x44,0x82,0x82,0xfe,0x82,0x82,0x82,0x82,0x00, // A
65:                	0xfc,0x82,0x82,0x82,0xfc,0x82,0x82,0x82,0xfc,0x00, // B
66:                	0x3e,0x40,0x80,0x80,0x80,0x80,0x80,0x40,0x3e,0x00, // C
67:                	0xf8,0x84,0x82,0x82,0x82,0x82,0x82,0x84,0xf8,0x00, // D
68:                	0xfe,0x80,0x80,0x80,0xfe,0x80,0x80,0x80,0xfe,0x00, // E
69:                	0xfe,0x80,0x80,0x80,0xfe,0x80,0x80,0x80,0x80,0x00, // F
70:                	};
71:                	
72:                	
73:                // police 6x8 caractères ASCII	
74:                const uint8_t font_6x8[FONT_SIZE*CHAR_HEIGHT]={
75:                0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, // espace
76:                0x20,0x20,0x20,0x20,0x20,0x00,0x20,0x00, // !
77:                0x50,0x50,0x50,0x00,0x00,0x00,0x00,0x00, // "
78:                0x50,0x50,0xF8,0x50,0xF8,0x50,0x50,0x00, // #
79:                0x20,0x78,0xA0,0x70,0x28,0xF0,0x20,0x00, // $
80:                0xC0,0xC8,0x10,0x20,0x40,0x98,0x18,0x00, // %
81:                0x60,0x90,0xA0,0x40,0xA8,0x90,0x68,0x00, // &
82:                0x60,0x20,0x40,0x00,0x00,0x00,0x00,0x00, // '
83:                0x10,0x20,0x40,0x40,0x40,0x20,0x10,0x00, // (
84:                0x40,0x20,0x10,0x10,0x10,0x20,0x40,0x00, // )
85:                0x00,0x20,0xA8,0x70,0xA8,0x20,0x00,0x00, // *
86:                0x00,0x20,0x20,0xF8,0x20,0x20,0x00,0x00, // +
87:                0x00,0x00,0x00,0x00,0x60,0x20,0x40,0x00, // ,
88:                0x00,0x00,0x00,0xF0,0x00,0x00,0x00,0x00, // -
89:                0x00,0x00,0x00,0x00,0x00,0x60,0x60,0x00, // .
90:                0x00,0x08,0x10,0x20,0x40,0x80,0x00,0x00, // /
91:                0x70,0x88,0x98,0xA8,0xC8,0x88,0x70,0x00, // 0
92:                0x20,0x60,0x20,0x20,0x20,0x20,0xF8,0x00, // 1
93:                0x70,0x88,0x10,0x20,0x40,0x80,0xF8,0x00, // 2
94:                0xF0,0x08,0x08,0xF0,0x08,0x08,0xF0,0x00, // 3
95:                0x10,0x30,0x50,0x90,0xF8,0x10,0x10,0x00, // 4
96:                0xF8,0x80,0x80,0xF0,0x08,0x08,0xF0,0x00, // 5
97:                0x30,0x40,0x80,0xF0,0x88,0x88,0x70,0x00, // 6
98:                0xF8,0x08,0x10,0x20,0x40,0x40,0x40,0x00, // 7
99:                0x70,0x88,0x88,0x70,0x88,0x88,0x70,0x00, // 8
100:               0x70,0x88,0x88,0x70,0x08,0x08,0x70,0x00, // 9
101:               0x00,0x60,0x60,0x00,0x60,0x60,0x00,0x00, // :
102:               0x00,0x60,0x60,0x00,0x60,0x20,0x40,0x00, // ;
103:               0x10,0x20,0x40,0x80,0x40,0x20,0x10,0x00, // <
104:               0x00,0x00,0xF8,0x00,0xF8,0x00,0x00,0x00, // =
105:               0x40,0x20,0x10,0x08,0x10,0x20,0x40,0x00, // >
106:               0x70,0x88,0x08,0x10,0x20,0x00,0x20,0x00, // ?
107:               0x70,0x88,0x08,0x68,0xA8,0xA8,0x70,0x00, // @
108:               0x70,0x88,0x88,0xF8,0x88,0x88,0x88,0x00, // A
109:               0xF0,0x88,0x88,0xF0,0x88,0x88,0xF0,0x00, // B
110:               0x78,0x80,0x80,0x80,0x80,0x80,0x78,0x00, // C
111:               0xF0,0x88,0x88,0x88,0x88,0x88,0xF0,0x00, // D
112:               0xF8,0x80,0x80,0xF8,0x80,0x80,0xF8,0x00, // E
113:               0xF8,0x80,0x80,0xF8,0x80,0x80,0x80,0x00, // F
114:               0x78,0x80,0x80,0xB0,0x88,0x88,0x70,0x00, // G
115:               0x88,0x88,0x88,0xF8,0x88,0x88,0x88,0x00, // H
116:               0x70,0x20,0x20,0x20,0x20,0x20,0x70,0x00, // I
117:               0x78,0x08,0x08,0x08,0x08,0x90,0x60,0x00, // J
118:               0x88,0x90,0xA0,0xC0,0xA0,0x90,0x88,0x00, // K
119:               0x80,0x80,0x80,0x80,0x80,0x80,0xF8,0x00, // L
120:               0x88,0xD8,0xA8,0x88,0x88,0x88,0x88,0x00, // M
121:               0x88,0x88,0xC8,0xA8,0x98,0x88,0x88,0x00, // N
122:               0x70,0x88,0x88,0x88,0x88,0x88,0x70,0x00, // O
123:               0xF0,0x88,0x88,0xF0,0x80,0x80,0x80,0x00, // P
124:               0x70,0x88,0x88,0x88,0xA8,0x98,0x78,0x00, // Q
125:               0xF0,0x88,0x88,0xF0,0xA0,0x90,0x88,0x00, // R
126:               0x78,0x80,0x80,0x70,0x08,0x08,0xF0,0x00, // S
127:               0xF8,0x20,0x20,0x20,0x20,0x20,0x20,0x00, // T
128:               0x88,0x88,0x88,0x88,0x88,0x88,0x70,0x00, // U
129:               0x88,0x88,0x88,0x88,0x88,0x50,0x20,0x00, // V
130:               0x88,0x88,0x88,0xA8,0xA8,0xD8,0x88,0x00, // W
131:               0x88,0x88,0x50,0x20,0x50,0x88,0x88,0x00, // X
132:               0x88,0x88,0x88,0x50,0x20,0x20,0x20,0x00, // Y
133:               0xF8,0x10,0x20,0x40,0x80,0x80,0xF8,0x00, // Z
134:               0x60,0x40,0x40,0x40,0x40,0x40,0x60,0x00, // [
135:               0x00,0x80,0x40,0x20,0x10,0x08,0x00,0x00, // '\'
136:               0x18,0x08,0x08,0x08,0x08,0x08,0x18,0x00, // ]
137:               0x20,0x50,0x88,0x00,0x00,0x00,0x00,0x00, // ^
138:               0x00,0x00,0x00,0x00,0x00,0x00,0xF8,0x00, // _
139:               0x40,0x20,0x10,0x00,0x00,0x00,0x00,0x00, // `
140:               0x00,0x00,0x70,0x08,0x78,0x88,0x78,0x00, // a
141:               0x80,0x80,0x80,0xB0,0xC8,0x88,0xF0,0x00, // b
142:               0x00,0x00,0x70,0x80,0x80,0x88,0x70,0x00, // c
143:               0x08,0x08,0x08,0x68,0x98,0x88,0x78,0x00, // d
144:               0x00,0x00,0x70,0x88,0xF8,0x80,0x70,0x00, // e
145:               0x30,0x48,0x40,0xE0,0x40,0x40,0x40,0x00, // f
146:               0x00,0x00,0x78,0x88,0x88,0x78,0x08,0x70, // g
147:               0x80,0x80,0xB0,0xC8,0x88,0x88,0x88,0x00, // h
148:               0x00,0x20,0x00,0x20,0x20,0x20,0x20,0x00, // i
149:               0x10,0x00,0x30,0x10,0x10,0x90,0x60,0x00, // j
150:               0x80,0x80,0x90,0xA0,0xC0,0xA0,0x90,0x00, // k
151:               0x60,0x20,0x20,0x20,0x20,0x20,0x70,0x00, // l
152:               0x00,0x00,0xD0,0xA8,0xA8,0x88,0x88,0x00, // m
153:               0x00,0x00,0xB0,0xC8,0x88,0x88,0x88,0x00, // n
154:               0x00,0x00,0x70,0x88,0x88,0x88,0x70,0x00, // o
155:               0x00,0x00,0xF0,0x88,0x88,0xF0,0x80,0x80, // p
156:               0x00,0x00,0x68,0x90,0x90,0xB0,0x50,0x18, // q
157:               0x00,0x00,0xB0,0xC8,0x80,0x80,0x80,0x00, // r
158:               0x00,0x00,0x70,0x80,0x70,0x08,0xF0,0x00, // s
159:               0x40,0x40,0xE0,0x40,0x40,0x48,0x30,0x00, // t
160:               0x00,0x00,0x88,0x88,0x88,0x98,0x68,0x00, // u
161:               0x00,0x00,0x88,0x88,0x88,0x50,0x20,0x00, // v
162:               0x00,0x00,0x88,0x88,0xA8,0xA8,0x50,0x00, // w
163:               0x00,0x00,0x88,0x50,0x20,0x50,0x88,0x00, // x
164:               0x00,0x00,0x88,0x88,0x88,0x78,0x08,0x70, // y
165:               0x00,0x00,0xF8,0x10,0x20,0x40,0xF8,0x00, // z
166:               0x20,0x40,0x40,0x80,0x40,0x40,0x20,0x00, // {
167:               0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x00, // |
168:               0x40,0x20,0x20,0x10,0x20,0x20,0x40,0x00, // }
169:               0x00,0x00,0x40,0xA8,0x10,0x00,0x00,0x00, // ~
170:               0xFC,0xFC,0xFC,0xFC,0xFC,0xFC,0xFC,0xFC, // 95 rectangle
171:               0x40,0x20,0x10,0xF8,0x10,0x20,0x40,0x00,// 96 flèche droite
172:               0x10,0x20,0x40,0xF8,0x40,0x20,0x10,0x00,// 97 flèche gauche
173:               0x20,0x70,0xA8,0x20,0x20,0x20,0x00,0x00,// 98 flèche haut
174:               0x00,0x20,0x20,0x20,0xA8,0x70,0x20,0x00,// 99 flèche bas
175:               0x00,0x70,0xF8,0xF8,0xF8,0x70,0x00,0x00,// 100 rond			
176:               };
177:               
178:               uint8_t font=FONT_ASCII;
179:               uint8_t xpos=0, ypos=0;
180:               	
181:               void select_font(uint8_t font_id){
182:               	font=font_id;
004086  B7FD4A     MOV.B WREG, font
183:               }
004088  060000     RETURN
184:               
185:               void new_line(){
186:               	xpos=0;
00408A  EF7D4C     CLR.B xpos
187:               	switch (font){
00408C  21D4A4     MOV #0x1D4A, W4
00408E  784214     MOV.B [W4], W4
004090  524FE1     SUB.B W4, #0x1, [W15]
004092  320013     BRA Z, 0x40BA
004094  390003     BRA NC, 0x409C
004096  524FE2     SUB.B W4, #0x2, [W15]
004098  3A002D     BRA NZ, 0x40F4
00409A  37001E     BRA 0x40D8
188:               	case FONT_SHEX:
189:               		if ((ypos+SHEX_HEIGHT)<=(VRES-SHEX_HEIGHT+1)){
00409C  21D4D4     MOV #0x1D4D, W4
00409E  784214     MOV.B [W4], W4
0040A0  FB8304     ZE W4, W6
0040A2  430366     ADD W6, #0x6, W6
0040A4  2003B5     MOV #0x3B, W5
0040A6  530F85     SUB W6, W5, [W15]
0040A8  3C0005     BRA GT, 0x40B4
190:               			ypos+=SHEX_HEIGHT;
0040AA  424266     ADD.B W4, #0x6, W4
0040AC  FD0200     EXCH W0, W4
0040AE  B7FD4D     MOV.B WREG, ypos
0040B0  FD0200     EXCH W0, W4
0040B2  370020     BRA 0x40F4
191:               		}else{
192:               			scroll_up(SHEX_HEIGHT);
0040B4  B3C060     MOV.B #0x6, W0
0040B6  07FF31     RCALL scroll_up
0040B8  37001D     BRA 0x40F4
193:               		}
194:               		break;
195:               	case FONT_LHEX:
196:               		if ((ypos+LHEX_HEIGHT)<=(VRES-LHEX_HEIGHT+1)){
0040BA  21D4D4     MOV #0x1D4D, W4
0040BC  784214     MOV.B [W4], W4
0040BE  FB8304     ZE W4, W6
0040C0  43036A     ADD W6, #0xA, W6
0040C2  200375     MOV #0x37, W5
0040C4  530F85     SUB W6, W5, [W15]
0040C6  3C0005     BRA GT, 0x40D2
197:               			ypos+=LHEX_HEIGHT;
0040C8  42426A     ADD.B W4, #0xA, W4
0040CA  FD0200     EXCH W0, W4
0040CC  B7FD4D     MOV.B WREG, ypos
0040CE  FD0200     EXCH W0, W4
0040D0  370011     BRA 0x40F4
198:               		}else{
199:               			scroll_up(LHEX_HEIGHT);
0040D2  B3C0A0     MOV.B #0xA, W0
0040D4  07FF22     RCALL scroll_up
0040D6  37000E     BRA 0x40F4
200:               		}
201:               		break;
202:               	case FONT_ASCII:
203:               		if ((ypos+CHAR_HEIGHT)<=(VRES-CHAR_HEIGHT+1)){
0040D8  21D4D4     MOV #0x1D4D, W4
0040DA  784214     MOV.B [W4], W4
0040DC  FB8304     ZE W4, W6
0040DE  430368     ADD W6, #0x8, W6
0040E0  200395     MOV #0x39, W5
0040E2  530F85     SUB W6, W5, [W15]
0040E4  3C0005     BRA GT, 0x40F0
204:               			ypos+=CHAR_HEIGHT;
0040E6  424268     ADD.B W4, #0x8, W4
0040E8  FD0200     EXCH W0, W4
0040EA  B7FD4D     MOV.B WREG, ypos
0040EC  FD0200     EXCH W0, W4
0040EE  370002     BRA 0x40F4
205:               		}else{
206:               			scroll_up(CHAR_HEIGHT);
0040F0  B3C080     MOV.B #0x8, W0
0040F2  07FF13     RCALL scroll_up
207:               		}
208:               		break;	
209:               	}//swtich
210:               
211:               }
0040F4  060000     RETURN
212:               
213:               void put_char(uint8_t c){
214:               	switch(font){
0040F6  21D4A4     MOV #0x1D4A, W4
0040F8  784214     MOV.B [W4], W4
0040FA  524FE1     SUB.B W4, #0x1, [W15]
0040FC  32001A     BRA Z, 0x4132
0040FE  390003     BRA NC, 0x4106
004100  524FE2     SUB.B W4, #0x2, [W15]
004102  3A004A     BRA NZ, 0x4198
004104  37002C     BRA 0x415E
215:               	case FONT_SHEX:	
216:               		if (c<16){
004106  504FEF     SUB.B W0, #0xF, [W15]
004108  3E0047     BRA GTU, 0x4198
217:               			put_sprite(xpos,ypos,SHEX_HEIGHT,&font_hex_4x6[c*SHEX_HEIGHT]);
00410A  B3C062     MOV.B #0x6, W2
00410C  BC4004     MUL.B WREG2
00410E  29BBA3     MOV #0x9BBA, W3
004110  418182     ADD W3, W2, W3
004112  B3C062     MOV.B #0x6, W2
004114  21D4D1     MOV #0x1D4D, W1
004116  784091     MOV.B [W1], W1
004118  BFDD4C     MOV.B xpos, WREG
00411A  07FDB1     RCALL put_sprite
218:               			xpos+=SHEX_WIDTH;
00411C  21D4C4     MOV #0x1D4C, W4
00411E  784214     MOV.B [W4], W4
004120  424264     ADD.B W4, #0x4, W4
004122  FD0200     EXCH W0, W4
004124  B7FD4C     MOV.B WREG, xpos
004126  FD0200     EXCH W0, W4
219:               			if (xpos>(HRES-SHEX_WIDTH+1)){
004128  B3C7D5     MOV.B #0x7D, W5
00412A  524F85     SUB.B W4, W5, [W15]
00412C  360035     BRA LEU, 0x4198
220:               				new_line();
00412E  07FFAD     RCALL new_line
004130  370033     BRA 0x4198
221:               			}
222:               		}
223:               		break;
224:               	case FONT_LHEX:
225:               		if (c<16){
004132  504FEF     SUB.B W0, #0xF, [W15]
004134  3E0031     BRA GTU, 0x4198
226:               			put_sprite(xpos,ypos,LHEX_HEIGHT,&font_hex_8x10[c*LHEX_HEIGHT]);
004136  B3C0A2     MOV.B #0xA, W2
004138  BC4004     MUL.B WREG2
00413A  29C1A3     MOV #0x9C1A, W3
00413C  418182     ADD W3, W2, W3
00413E  B3C0A2     MOV.B #0xA, W2
004140  21D4D1     MOV #0x1D4D, W1
004142  784091     MOV.B [W1], W1
004144  BFDD4C     MOV.B xpos, WREG
004146  07FD9B     RCALL put_sprite
227:               			xpos+=LHEX_WIDTH;
004148  21D4C4     MOV #0x1D4C, W4
00414A  784214     MOV.B [W4], W4
00414C  424268     ADD.B W4, #0x8, W4
00414E  FD0200     EXCH W0, W4
004150  B7FD4C     MOV.B WREG, xpos
004152  FD0200     EXCH W0, W4
228:               			if (xpos>(HRES-LHEX_WIDTH+1)){
004154  B3C795     MOV.B #0x79, W5
004156  524F85     SUB.B W4, W5, [W15]
004158  36001F     BRA LEU, 0x4198
229:               				new_line();
00415A  07FF97     RCALL new_line
00415C  37001D     BRA 0x4198
230:               			}
231:               		}
232:               		break;
233:               	case FONT_ASCII:
234:               		if (c=='\n'){
00415E  504FEA     SUB.B W0, #0xA, [W15]
004160  3A0002     BRA NZ, 0x4166
235:               			new_line();
004162  07FF93     RCALL new_line
004164  370019     BRA 0x4198
236:               		}else if ((c>31) && (c<(FONT_SIZE+32))){
004166  B3CE05     MOV.B #0xE0, W5
004168  404285     ADD.B W0, W5, W5
00416A  B3C644     MOV.B #0x64, W4
00416C  52CF84     SUB.B W5, W4, [W15]
00416E  3E0014     BRA GTU, 0x4198
237:               			put_sprite(xpos,ypos,CHAR_HEIGHT,&font_6x8[(c-32)*CHAR_HEIGHT]);
004170  FB8000     ZE W0, W0
004172  B10200     SUB #0x20, W0
004174  DD0043     SL W0, #3, W0
004176  29CBA3     MOV #0x9CBA, W3
004178  418180     ADD W3, W0, W3
00417A  B3C082     MOV.B #0x8, W2
00417C  21D4D1     MOV #0x1D4D, W1
00417E  784091     MOV.B [W1], W1
004180  BFDD4C     MOV.B xpos, WREG
004182  07FD7D     RCALL put_sprite
238:               			xpos+=CHAR_WIDTH;
004184  21D4C4     MOV #0x1D4C, W4
004186  784214     MOV.B [W4], W4
004188  424266     ADD.B W4, #0x6, W4
00418A  FD0200     EXCH W0, W4
00418C  B7FD4C     MOV.B WREG, xpos
00418E  FD0200     EXCH W0, W4
239:               			if (xpos>(HRES-CHAR_WIDTH+1)){
004190  B3C7B5     MOV.B #0x7B, W5
004192  524F85     SUB.B W4, W5, [W15]
004194  360001     BRA LEU, 0x4198
240:               				new_line();
004196  07FF79     RCALL new_line
241:               			}
242:               		}
243:               		break;		
244:               	}
245:               }
004198  060000     RETURN
246:               
247:               void set_cursor(uint8_t x, uint8_t y){
248:               	xpos=x;
00419A  B7FD4C     MOV.B WREG, xpos
249:               	ypos=y;
00419C  780001     MOV W1, W0
00419E  B7FD4D     MOV.B WREG, ypos
250:               }
0041A0  060000     RETURN
251:               
252:               uint16_t get_cursor(){
253:               	return (xpos<<8)+ypos;
0041A2  BFDD4C     MOV.B xpos, WREG
0041A4  DD0048     SL W0, #8, W0
0041A6  21D4D4     MOV #0x1D4D, W4
0041A8  784214     MOV.B [W4], W4
0041AA  FB8204     ZE W4, W4
0041AC  400004     ADD W0, W4, W0
254:               }
0041AE  060000     RETURN
255:               
256:               void print(const char* str){
0041B0  781F88     MOV W8, [W15++]
0041B2  780400     MOV W0, W8
257:               	while (*str) put_char(*str++);
0041B4  784018     MOV.B [W8], W0
0041B6  504FE0     SUB.B W0, #0x0, [W15]
0041B8  320004     BRA Z, 0x41C2
0041BA  07FF9D     RCALL put_char
0041BC  784058     MOV.B [++W8], W0
0041BE  504FE0     SUB.B W0, #0x0, [W15]
0041C0  3AFFFC     BRA NZ, 0x41BA
258:               }
0041C2  78044F     MOV [--W15], W8
0041C4  060000     RETURN
259:               
260:               void print_int(uint16_t n){
0041C6  FA000C     LNK #0xC
0041C8  781F88     MOV W8, [W15++]
261:               	uint8_t nstr[12];
262:               	uint8_t i=11;
0041CA  B3C0B8     MOV.B #0xB, W8
263:               
264:               	do {
265:               		nstr[i--]=n%10+'0';
0041CC  2000A4     MOV #0xA, W4
0041CE  370001     BRA 0x41D2
0041D0  784405     MOV.B W5, W8
0041D2  FB8288     ZE W8, W5
0041D4  090011     REPEAT #0x11
0041D6  D88004     DIV.UW W0, W4
0041D8  B3C307     MOV.B #0x30, W7
0041DA  40C307     ADD.B W1, W7, W6
0041DC  784386     MOV.B W6, W7
0041DE  5780EE     SUB W15, #0xE, W1
0041E0  7AF087     MOV.B W7, [W1+W5]
0041E2  E94288     DEC.B W8, W5
266:               		n/=10;
267:               	}while (n);
0041E4  500FE0     SUB W0, #0x0, [W15]
0041E6  3AFFF4     BRA NZ, 0x41D0
268:               	put_char(' ');
0041E8  B3C200     MOV.B #0x20, W0
0041EA  07FF85     RCALL put_char
269:               	i++;
270:               	while (i<12) put_char(nstr[i++]);
0041EC  544FEB     SUB.B W8, #0xB, [W15]
0041EE  3E0007     BRA GTU, 0x41FE
0041F0  FB8208     ZE W8, W4
0041F2  5780EE     SUB W15, #0xE, W1
0041F4  7A4061     MOV.B [W1+W4], W0
0041F6  E84408     INC.B W8, W8
0041F8  07FF7E     RCALL put_char
0041FA  544FEB     SUB.B W8, #0xB, [W15]
0041FC  36FFF9     BRA LEU, 0x41F0
271:               }
0041FE  78044F     MOV [--W15], W8
004200  FA8000     ULNK
004202  060000     RETURN
272:               
273:               void print_hex(uint16_t n,uint8_t width){
004204  FA0004     LNK #0x4
004206  BE9F88     MOV.D W8, [W15++]
004208  BE9F8A     MOV.D W10, [W15++]
00420A  784481     MOV.B W1, W9
274:               	uint8_t hex[4];
275:               	uint8_t i=3,h;
00420C  B3C038     MOV.B #0x3, W8
276:               	
277:               	do{
278:               		h=n&0xf;
00420E  60426F     AND.B W0, #0xF, W4
279:               		if (h<10) hex[i]=h+'0'; else hex[i]=h+'A'-10;
004210  524FE9     SUB.B W4, #0x9, [W15]
004212  3E0006     BRA GTU, 0x4220
004214  FB8288     ZE W8, W5
004216  B04304     ADD.B #0x30, W4
004218  784384     MOV.B W4, W7
00421A  57836C     SUB W15, #0xC, W6
00421C  7AF307     MOV.B W7, [W6+W5]
00421E  370005     BRA 0x422A
004220  FB8288     ZE W8, W5
004222  B04374     ADD.B #0x37, W4
004224  784384     MOV.B W4, W7
004226  57836C     SUB W15, #0xC, W6
004228  7AF307     MOV.B W7, [W6+W5]
280:               		n>>=4;
00422A  DE0044     LSR W0, #4, W0
281:               		i--;
00422C  E94408     DEC.B W8, W8
004236  784508     MOV.B W8, W10
282:               		width--;
00422E  E94489     DEC.B W9, W9
004234  784589     MOV.B W9, W11
283:               	}while (n);
004230  500FE0     SUB W0, #0x0, [W15]
004232  3AFFED     BRA NZ, 0x420E
284:               	put_char(' ');
004238  B3C200     MOV.B #0x20, W0
00423A  07FF5D     RCALL put_char
285:               	while (width){hex[i--]='0'; width--;}
00423C  54CFE0     SUB.B W9, #0x0, [W15]
00423E  320008     BRA Z, 0x4250
004240  B3C305     MOV.B #0x30, W5
004242  FB8208     ZE W8, W4
004244  57836C     SUB W15, #0xC, W6
004246  7A7305     MOV.B W5, [W6+W4]
004248  E94408     DEC.B W8, W8
00424A  E94489     DEC.B W9, W9
00424C  3AFFFA     BRA NZ, 0x4242
00424E  55440B     SUB.B W10, W11, W8
286:               	i++;
004250  E84408     INC.B W8, W8
287:               	while (i<4) put_char(hex[i++]);
004252  544FE3     SUB.B W8, #0x3, [W15]
004254  3E0007     BRA GTU, 0x4264
004256  FB8208     ZE W8, W4
004258  5782EC     SUB W15, #0xC, W5
00425A  7A4065     MOV.B [W5+W4], W0
00425C  E84408     INC.B W8, W8
00425E  07FF4B     RCALL put_char
004260  544FE3     SUB.B W8, #0x3, [W15]
004262  36FFF9     BRA LEU, 0x4256
288:               }
004264  BE054F     MOV.D [--W15], W10
004266  BE044F     MOV.D [--W15], W8
004268  FA8000     ULNK
00426A  060000     RETURN
289:               
290:               void cursor_left(){
291:               	switch(font){
00426C  21D4A4     MOV #0x1D4A, W4
00426E  784214     MOV.B [W4], W4
004270  524FE1     SUB.B W4, #0x1, [W15]
004272  32000E     BRA Z, 0x4290
004274  390003     BRA NC, 0x427C
004276  524FE2     SUB.B W4, #0x2, [W15]
004278  3A001D     BRA NZ, 0x42B4
00427A  370014     BRA 0x42A4
292:               	case FONT_SHEX:
293:               		if (xpos-SHEX_WIDTH>=0) xpos-=SHEX_WIDTH;
00427C  21D4C4     MOV #0x1D4C, W4
00427E  784214     MOV.B [W4], W4
004280  FB8284     ZE W4, W5
004282  5282E4     SUB W5, #0x4, W5
004284  330017     BRA N, 0x42B4
004286  524264     SUB.B W4, #0x4, W4
004288  FD0200     EXCH W0, W4
00428A  B7FD4C     MOV.B WREG, xpos
00428C  FD0200     EXCH W0, W4
00428E  370012     BRA 0x42B4
294:               		break;
295:               	case FONT_LHEX:
296:               		if (xpos-LHEX_WIDTH>=0) xpos-=LHEX_WIDTH;
004290  21D4C4     MOV #0x1D4C, W4
004292  784214     MOV.B [W4], W4
004294  FB8284     ZE W4, W5
004296  5282E8     SUB W5, #0x8, W5
004298  33000D     BRA N, 0x42B4
00429A  524268     SUB.B W4, #0x8, W4
00429C  FD0200     EXCH W0, W4
00429E  B7FD4C     MOV.B WREG, xpos
0042A0  FD0200     EXCH W0, W4
0042A2  370008     BRA 0x42B4
297:               		break;
298:               	case FONT_ASCII:
299:               		if (xpos-CHAR_WIDTH>=0) xpos-=CHAR_WIDTH;
0042A4  21D4C4     MOV #0x1D4C, W4
0042A6  784214     MOV.B [W4], W4
0042A8  FB8284     ZE W4, W5
0042AA  5282E6     SUB W5, #0x6, W5
0042AC  330003     BRA N, 0x42B4
0042AE  524266     SUB.B W4, #0x6, W4
0042B0  780004     MOV W4, W0
0042B2  B7FD4C     MOV.B WREG, xpos
300:               		break;	
301:               	}
302:               }
0042B4  060000     RETURN
303:               
304:               void text_scroller(const char *text, uint8_t speed){
0042B6  BE9F88     MOV.D W8, [W15++]
0042B8  BE9F8A     MOV.D W10, [W15++]
0042BA  BE9F8C     MOV.D W12, [W15++]
0042BC  780500     MOV W0, W10
0042BE  784581     MOV.B W1, W11
0042CE  B3C08D     MOV.B #0x8, W13
0042F6  78440D     MOV.B W13, W8
004326  B3C388     MOV.B #0x38, W8
305:               	uint8_t c,j;
306:                       uint16_t frame_delay;
307:                       
308:               	cls();
0042C0  07FE11     RCALL cls
309:               	select_font(FONT_ASCII);
0042C2  B3C020     MOV.B #0x2, W0
0042C4  07FEE0     RCALL select_font
310:               	c=*text++;
0042C6  78441A     MOV.B [W10], W8
0042CC  E8050A     INC W10, W10
311:               	while (c){
0042C8  544FE0     SUB.B W8, #0x0, [W15]
0042CA  32002D     BRA Z, 0x4326
00431E  544FE0     SUB.B W8, #0x0, [W15]
004320  320002     BRA Z, 0x4326
312:               		set_cursor(0,7*CHAR_HEIGHT);
0042D2  B3C381     MOV.B #0x38, W1
0042D4  EB4000     CLR.B W0
0042D6  07FF61     RCALL set_cursor
313:               		while (c && c!='\n'){
0042D8  544FE0     SUB.B W8, #0x0, [W15]
0042DA  32000D     BRA Z, 0x42F6
0042DC  544FEA     SUB.B W8, #0xA, [W15]
0042DE  32000B     BRA Z, 0x42F6
0042E0  78048A     MOV W10, W9
0042F2  544FE0     SUB.B W8, #0x0, [W15]
0042F4  3A0003     BRA NZ, 0x42FC
0042FC  544FEA     SUB.B W8, #0xA, [W15]
0042FE  3AFFF1     BRA NZ, 0x42E2
004300  37FFFA     BRA 0x42F6
314:               			put_char(c);
0042E2  784008     MOV.B W8, W0
0042E4  07FF08     RCALL put_char
315:               			c=*text++;
0042E6  784439     MOV.B [W9++], W8
0042F0  780509     MOV W9, W10
316:                               if (any_key()) goto break_out;
0042E8  801614     MOV PORTA, W4
0042EA  62027F     AND W4, #0x1F, W4
0042EC  520FFF     SUB W4, #0x1F, [W15]
0042EE  3A002B     BRA NZ, 0x4346
317:               		}
318:               		for (j=0;j<CHAR_HEIGHT;j++){
00431A  3AFFF3     BRA NZ, 0x4302
319:               			frame_delay=frame_counter+speed;
0042D0  FB860B     ZE W11, W12
004302  80E365     MOV frame_counter, W5
004304  460285     ADD W12, W5, W5
320:               			while(frame_delay>frame_counter);
004306  80E364     MOV frame_counter, W4
004308  528F84     SUB W5, W4, [W15]
00430A  3EFFFD     BRA GTU, 0x4306
321:               			scroll_up(1);
0042F8  B3C019     MOV.B #0x1, W9
0042FA  370003     BRA 0x4302
00430C  784009     MOV.B W9, W0
00430E  07FE05     RCALL scroll_up
322:                               if (any_key()) goto break_out;
004310  801614     MOV PORTA, W4
004312  62027F     AND W4, #0x1F, W4
004314  520FFF     SUB W4, #0x1F, [W15]
004316  3A0017     BRA NZ, 0x4346
004318  E94408     DEC.B W8, W8
323:               		}
324:               		c=*text++;
00431C  78441A     MOV.B [W10], W8
004322  E8050A     INC W10, W10
004324  37FFD6     BRA 0x42D2
325:               	}//while
326:               	for (c=0;c<7*CHAR_HEIGHT;c++){
004344  3AFFF3     BRA NZ, 0x432C
327:               		frame_delay=frame_counter+speed;
004328  FB858B     ZE W11, W11
00432C  80E365     MOV frame_counter, W5
00432E  458285     ADD W11, W5, W5
328:               		while(frame_delay>frame_counter);
004330  80E364     MOV frame_counter, W4
004332  528F84     SUB W5, W4, [W15]
004334  3EFFFD     BRA GTU, 0x4330
329:               		scroll_up(1);
00432A  B3C019     MOV.B #0x1, W9
004336  784009     MOV.B W9, W0
004338  07FDF0     RCALL scroll_up
330:                               if (any_key()) goto break_out;
00433A  801614     MOV PORTA, W4
00433C  62027F     AND W4, #0x1F, W4
00433E  520FFF     SUB W4, #0x1F, [W15]
004340  3A0002     BRA NZ, 0x4346
004342  E94408     DEC.B W8, W8
331:               	}//for
332:               break_out:	
333:               	cls();
004346  07FDCE     RCALL cls
334:               }
004348  BE064F     MOV.D [--W15], W12
00434A  BE054F     MOV.D [--W15], W10
00434C  BE044F     MOV.D [--W15], W8
00434E  060000     RETURN
---  C:/Users/Jacques/Documents/GitHub/PicVisionPortable/PICVisionPortable.X/main.c  --------------------
1:                 /*
2:                  * Projet: CHIPCON portable
3:                  * File:   main.c
4:                  * Author: Jacques Deschênes
5:                  * Description: Console de jeux CHIPCON utilisant un LCD avec affichage graphique de 128x64 monochrome.
6:                  *      afficage: DFrobot.com: #produit: FIT0021
7:                  * Liens utiles:
8:                  *      http://www.dfrobot.com/wiki/index.php?title=128x64_Graphic_LCD_%28SKU:FIT0021%29
9:                  *      https://www.dfrobot.com/index.php?route=product/product&product_id=240&search=FIT0021+&description=true
10:                 *      http://mikenz.geek.nz/blog/1006/mindkits-128x64-graphic-lcd-and-arduino/
11:                 *      http://www.embeddedrelated.com/groups/lpc2000/show/36610.php
12:                 *      http://fr.scribd.com/doc/190131117/MH-Datasheet-LCD12864ZW#scribd
13:                 *
14:                 * Created on 20 janvier 2015, 22:56
15:                 */
16:                
17:                // PIC24FJ64GA002 Configuration Bit Settings
18:                // 'C' source line config statements
19:                #include <xc.h>
20:                // CONFIG2
21:                #pragma config POSCMOD = NONE           // Primary Oscillator Select (Primary oscillator disabled)
22:                #pragma config I2C1SEL = PRI            // I2C1 Pin Location Select (Use default SCL1/SDA1 pins)
23:                #pragma config IOL1WAY = ON             // IOLOCK Protection (Once IOLOCK is set, cannot be changed)
24:                #pragma config OSCIOFNC = ON            // Primary Oscillator Output Function (OSC2/CLKO/RC15 functions as port I/O (RC15))
25:                #pragma config FCKSM = CSDCMD           // Clock switching and Fail-Safe Clock Monitor are disabled
26:                #pragma config FNOSC = FRCPLL           // Oscillator Select (Fast RC Oscillator with PLL module (FRCPLL))
27:                #pragma config SOSCSEL = SOSC           // Sec Oscillator Select (Default Secondary Oscillator (SOSC))
28:                #pragma config WUTSEL = LEG             // Wake-up timer Select (Legacy Wake-up Timer)
29:                #pragma config IESO = OFF               // Internal External Switch Over Mode (IESO mode (Two-Speed Start-up) disabled)
30:                // CONFIG1
31:                #pragma config WDTPS = PS32768          // Watchdog Timer Postscaler (1:32,768)
32:                #pragma config FWPSA = PR128            // WDT Prescaler (Prescaler ratio of 1:128)
33:                #pragma config WINDIS = OFF             // Watchdog Timer Window (Windowed Watchdog Timer enabled; FWDTEN must be 1)
34:                #pragma config FWDTEN = OFF             // Watchdog Timer Enable (Watchdog Timer is disabled)
35:                #pragma config ICS = PGx1               // Comm Channel Select (Emulator EMUC1/EMUD1 pins are shared with PGC1/PGD1)
36:                #pragma config GWRP = OFF               // General Code Segment Write Protect (Writes to program memory are allowed)
37:                #pragma config GCP = OFF                // General Code Segment Code Protect (Code protection is disabled)
38:                #pragma config JTAGEN = OFF             // JTAG Port Enable (JTAG port is disabled)
39:                // end config
40:                
41:                #include <string.h>
42:                #include <stdlib.h>
43:                
44:                #include "Hardware/HardwareProfile.h"
45:                #include "Hardware/LCDout.h"
46:                #include "display.h"
47:                #include "text.h"
48:                #include "tone.h"
49:                #include "chip8.h"
50:                #include "keypad.h"
51:                #include "games/game_info.h"
52:                #if SDC_SUPPORT
53:                #include "filesys.h"
54:                #endif
55:                
56:                //****** jeux intégrés ***********
57:                #include "games/blinky/blinky.h"
58:                #include "games/sokoban/sokoban.h"
59:                #include "c8test.h"
60:                #include "games/lem/lem.h"
61:                
62:                #define GAMES_COUNT (4)
63:                
64:                // jeux en mémoire flash
65:                const game_info_t flash_games[GAMES_COUNT]={
66:                    {"c8test",C8TEST_SIZE,c8test,NULL},
67:                    {"sokoban",SOKOBAN_SIZE,sokoban,(const char*)sokoban_info},
68:                    {"blinky",BLINKY_SIZE,blinky,(const char*)blinky_info},
69:                    {"LEM",LEM_SIZE,lem,lem_info}
70:                };
71:                
72:                //********************************
73:                
74:                #define MAX_ENTRIES (PROG_SPACE/ENTRY_SIZE)
75:                #define DISPLAY_LINES (8)
76:                
77:                uint8_t display_page(int16_t page){
004350  FA0020     LNK #0x20
004352  BE9F88     MOV.D W8, [W15++]
004354  781F8A     MOV W10, [W15++]
00436E  E80489     INC W9, W9
004370  DD4CC5     SL W9, #5, W9
004372  420489     ADD W4, W9, W9
78:                    char fname[ENTRY_SIZE];
79:                    uint8_t i;
80:                
81:                    for (i=0;i<DISPLAY_LINES;i++){
004366  EB4400     CLR.B W8
00439A  E84408     INC.B W8, W8
00439C  544FE8     SUB.B W8, #0x8, [W15]
00439E  3AFFEC     BRA NZ, 0x4378
82:                        memcpy(fname,&chip_prog[page*DISPLAY_LINES*ENTRY_SIZE+(i*ENTRY_SIZE)],ENTRY_SIZE);
004356  208004     MOV #0x800, W4
004358  DD04C3     SL W0, #3, W9
00435A  DD0048     SL W0, #8, W0
00435C  2FFDA5     MOV #0xFFDA, W5
00435E  478285     ADD W15, W5, W5
004360  420300     ADD W4, W0, W6
004362  09001F     REPEAT #0x1F
004364  785AB6     MOV.B [W6++], [W5++]
004378  2FFDA6     MOV #0xFFDA, W6
00437A  478306     ADD W15, W6, W6
00437C  09001F     REPEAT #0x1F
00437E  785B39     MOV.B [W9++], [W6++]
004380  B10209     SUB #0x20, W9
004382  B00209     ADD #0x20, W9
83:                        if (strlen((char *)fname)){
004368  97DAAF     MOV.B [W15-38], W5
00436A  52CF88     SUB.B W5, W8, [W15]
00436C  320019     BRA Z, 0x43A0
004384  97DA2F     MOV.B [W15-38], W4
004386  524FE0     SUB.B W4, #0x0, [W15]
004388  32000B     BRA Z, 0x43A0
84:                            put_char(' ');
004374  B3C20A     MOV.B #0x20, W10
004376  370009     BRA 0x438A
00438A  78400A     MOV.B W10, W0
00438C  07FEB4     RCALL put_char
85:                            print(fname);
00438E  2FFDA0     MOV #0xFFDA, W0
004390  40000F     ADD W0, W15, W0
004392  07FF0E     RCALL print
86:                            if (i<7) new_line();
004394  544FE6     SUB.B W8, #0x6, [W15]
004396  3E0001     BRA GTU, 0x439A
004398  07FE78     RCALL new_line
87:                        }else{
88:                            break;
89:                        }
90:                    }
91:                    return i;
92:                }
0043A0  784008     MOV.B W8, W0
0043A2  78054F     MOV [--W15], W10
0043A4  BE044F     MOV.D [--W15], W8
0043A6  FA8000     ULNK
0043A8  060000     RETURN
93:                
94:                inline void display_cursor(uint8_t line){
95:                    put_sprite(0,line*CHAR_HEIGHT,8,&font_6x8[(RIGHT_ARROW-32)*CHAR_HEIGHT]);
0043AA  200034     MOV #0x3, W4
0043AC  DD0084     SL W0, W4, W1
0043AE  29FBA3     MOV #0x9FBA, W3
0043B0  B3C082     MOV.B #0x8, W2
0043B2  EB4000     CLR.B W0
0043B4  07FC64     RCALL put_sprite
96:                }
0043B6  060000     RETURN
97:                
98:                // sélectionne un fichier
99:                // à partir de la liste
100:               // affichée à l'écran
101:               int16_t select_file(int16_t fcount){
0043B8  4787E4     ADD W15, #0x4, W15
0043BA  BE9F88     MOV.D W8, [W15++]
0043BC  BE9F8A     MOV.D W10, [W15++]
0043BE  BE9F8C     MOV.D W12, [W15++]
0043C0  781F8E     MOV W14, [W15++]
0043C2  9FBF80     MOV W0, [W15-16]
102:                   int16_t page, selected;
103:                   uint8_t key, pg_lines;
104:                   uint16_t frame_delay;
105:               
106:                   print("'S' selection\n");
0043C4  2A59E0     MOV #0xA59E, W0
0043C6  07FEF4     RCALL print
107:                   print("'L' page precedante\n");
0043C8  2A5AD0     MOV #0xA5AD, W0
0043CA  07FEF2     RCALL print
108:                   print("'R' page suivante\n");
0043CC  2A5C20     MOV #0xA5C2, W0
0043CE  07FEF0     RCALL print
109:                   print("'U' vers le haut\n");
0043D0  2A5D50     MOV #0xA5D5, W0
0043D2  07FEEE     RCALL print
110:                   print("'D' vers le bas\n");
0043D4  2A5E70     MOV #0xA5E7, W0
0043D6  07FEEC     RCALL print
111:                   prompt_key();
0043D8  0703AA     RCALL prompt_key
112:                   cls();
0043DA  07FD84     RCALL cls
113:                   page=0;
0043EE  780709     MOV W9, W14
114:                   selected=0;
0043EC  EB0480     CLR W9
115:                   frame_delay=frame_counter+2;
0043DC  80E365     MOV frame_counter, W5
0043DE  E88285     INC2 W5, W5
116:                   while (frame_delay>frame_counter);
0043E0  80E364     MOV frame_counter, W4
0043E2  528F84     SUB W5, W4, [W15]
0043E4  3EFFFD     BRA GTU, 0x43E0
117:                   pg_lines=display_page(page);
0043E6  EB0000     CLR W0
0043E8  07FFB3     RCALL display_page
0043EA  784580     MOV.B W0, W11
118:                   while (1){
119:                       display_cursor(selected);
0043F4  784009     MOV.B W9, W0
0043F6  07FFD9     RCALL display_cursor
120:                       key=wait_key();
0043F8  07038B     RCALL wait_key
0043FA  784400     MOV.B W0, W8
121:                       key_tone(key,6,false);
0043FC  EB4100     CLR.B W2
0043FE  200061     MOV #0x6, W1
004400  784008     MOV.B W8, W0
004402  070345     RCALL key_tone
122:                       display_cursor(selected);
004404  784009     MOV.B W9, W0
004406  07FFD1     RCALL display_cursor
123:                       switch(key){
0043F0  20004C     MOV #0x4, W12
0043F2  20000D     MOV #0x0, W13
004408  FB8208     ZE W8, W4
00440A  200005     MOV #0x0, W5
00440C  520F8C     SUB W4, W12, [W15]
00440E  5A8F8D     SUBB W5, W13, [W15]
004410  3E004B     BRA GTU, 0x44A8
004412  016004     BRA W4
004414  370025     BRA 0x4460
004416  370031     BRA 0x447A
004418  37000A     BRA 0x442E
00441A  370013     BRA 0x4442
00441C  370000     BRA 0x441E
124:                       case SELECT:
125:                           return page*DISPLAY_LINES+selected;
00441E  DD7743     SL W14, #3, W14
004420  470009     ADD W14, W9, W0
126:                           break;
127:                       case LEFT: // LEFT arrow
128:                           if (page){
004430  570F89     SUB W14, W9, [W15]
004432  32003A     BRA Z, 0x44A8
129:                               page--;
004434  E9070E     DEC W14, W14
130:                               selected=7;
00443E  200079     MOV #0x7, W9
004440  370033     BRA 0x44A8
131:                               cls();
004436  07FD56     RCALL cls
132:                               pg_lines=display_page(page);
004438  78000E     MOV W14, W0
00443A  07FF8A     RCALL display_page
00443C  784580     MOV.B W0, W11
133:                           }else{
134:                               selected=0;
00442E  EB0480     CLR W9
135:                           }
136:                           break;
137:                       case RIGHT: // RIGHT arrow
138:                           if ((page*DISPLAY_LINES+DISPLAY_LINES)<fcount){
004442  E8048E     INC W14, W9
004444  DD4A43     SL W9, #3, W4
004446  97BA8F     MOV [W15-16], W5
004448  520F85     SUB W4, W5, [W15]
00444A  3D0007     BRA GE, 0x445A
139:                               page++;
004454  780709     MOV W9, W14
140:                               selected=0;
004456  EB0480     CLR W9
004458  370027     BRA 0x44A8
141:                               cls();
00444C  07FD4B     RCALL cls
142:                               pg_lines=display_page(page);
00444E  780009     MOV W9, W0
004450  07FF7F     RCALL display_page
004452  784580     MOV.B W0, W11
143:                           }else{
144:                               selected=pg_lines-1;
00445A  FB848B     ZE W11, W9
00445C  E90489     DEC W9, W9
00445E  370024     BRA 0x44A8
145:                           }
146:                           break;
147:                       case UP: // UP  arrow
148:                           if (selected){
004460  548FE0     SUB W9, #0x0, [W15]
004462  320002     BRA Z, 0x4468
149:                               selected--;
004464  E90489     DEC W9, W9
004466  370020     BRA 0x44A8
150:                           }else if (page){
004468  570FE0     SUB W14, #0x0, [W15]
00446A  32001E     BRA Z, 0x44A8
151:                               page--;
00446C  E9070E     DEC W14, W14
152:                               selected=7;
004476  200079     MOV #0x7, W9
004478  370017     BRA 0x44A8
153:                               cls();
00446E  07FD3A     RCALL cls
154:                               pg_lines=display_page(page);
004470  78000E     MOV W14, W0
004472  07FF6E     RCALL display_page
004474  784580     MOV.B W0, W11
155:                           }
156:                           break;
157:                       case DOWN: // DOWN arrow
158:                           if (selected<(pg_lines-1)){
00447A  FB820B     ZE W11, W4
00447C  E90204     DEC W4, W4
00447E  548F84     SUB W9, W4, [W15]
004480  3D0002     BRA GE, 0x4486
159:                               selected++;
004482  E80489     INC W9, W9
004484  370011     BRA 0x44A8
160:                           }else if ((page*DISPLAY_LINES+DISPLAY_LINES)<fcount){
004486  E8050E     INC W14, W10
004488  DD5243     SL W10, #3, W4
00448A  97BA8F     MOV [W15-16], W5
00448C  528F84     SUB W5, W4, [W15]
00448E  34000C     BRA LE, 0x44A8
161:                               page++;
004498  78070A     MOV W10, W14
162:                               selected=0;
00449A  EB0480     CLR W9
00449C  370005     BRA 0x44A8
163:                               cls();
004490  07FD29     RCALL cls
164:                               pg_lines=display_page(page);
004492  78000A     MOV W10, W0
004494  07FF5D     RCALL display_page
004496  784580     MOV.B W0, W11
165:                           }
166:                           break;
167:                       default:
168:                           break;
169:                       }//switch
170:                       while (keypad_read()!=NO_KEY)key_tone(key,2,false);
00449E  78410A     MOV.B W10, W2
0044A0  200021     MOV #0x2, W1
0044A2  784008     MOV.B W8, W0
0044A4  0702F4     RCALL key_tone
0044A6  370001     BRA 0x44AA
0044A8  EB4500     CLR.B W10
0044AA  070319     RCALL keypad_read
0044AC  404FE1     ADD.B W0, #0x1, [W15]
0044AE  32FFA2     BRA Z, 0x43F4
0044B0  37FFF6     BRA 0x449E
171:                   }//while
172:               }
004422  78074F     MOV [--W15], W14
004424  BE064F     MOV.D [--W15], W12
004426  BE054F     MOV.D [--W15], W10
004428  BE044F     MOV.D [--W15], W8
00442A  B1004F     SUB #0x4, W15
00442C  060000     RETURN
173:               
174:               #if SDC_SUPPORT
175:               // copie la liste des fichiers
176:               // du répertoire racine
177:               // dans le tableau CHIP_PROG
178:               int16_t sdc_files(){
0044B2  FA004C     LNK #0x4C
0044B4  BE9F88     MOV.D W8, [W15++]
179:               		uint8_t fname[ENTRY_SIZE];
180:               		int16_t entry_nbr;
181:                       struct fat_dir_entry_struct dir_entry;
182:               
183:                       /* charge les fichiers dans la SRAM */
184:               		entry_nbr=0;
0044BA  EB0400     CLR W8
185:               		fname[ENTRY_SIZE-1]=0;
0044B6  EB4200     CLR.B W4
0044B8  9FCFF4     MOV.B W4, [W15-49]
186:                       while((entry_nbr<MAX_ENTRIES) && fs_read_dir(&dir_entry))
0044BC  2007F9     MOV #0x7F, W9
0044BE  37001E     BRA 0x44FC
0044F8  540F89     SUB W8, W9, [W15]
0044FA  3C0005     BRA GT, 0x4506
0044FC  2FFD00     MOV #0xFFD0, W0
0044FE  40000F     ADD W0, W15, W0
004500  0701FF     RCALL fs_read_dir
004502  504FE0     SUB.B W0, #0x0, [W15]
004504  3AFFDD     BRA NZ, 0x44C0
187:                       {
188:                           if (!(dir_entry.attributes & FAT_ATTRIB_DIR)){
0044C0  97F20F     MOV.B [W15-16], W4
0044C2  620270     AND W4, #0x10, W4
0044C4  3A0019     BRA NZ, 0x44F8
189:                               if (strstr(dir_entry.long_name,".pvp")||strstr(dir_entry.long_name,".PVP")){
0044C6  2A5F81     MOV #0xA5F8, W1
0044C8  2FFD00     MOV #0xFFD0, W0
0044CA  40000F     ADD W0, W15, W0
0044CC  07DF69     RCALL _strstr
0044CE  500FE0     SUB W0, #0x0, [W15]
0044D0  3A0006     BRA NZ, 0x44DE
0044D2  2A5FD1     MOV #0xA5FD, W1
0044D4  2FFD00     MOV #0xFFD0, W0
0044D6  40000F     ADD W0, W15, W0
0044D8  07DF63     RCALL _strstr
0044DA  500FE0     SUB W0, #0x0, [W15]
0044DC  32000D     BRA Z, 0x44F8
190:                                   strcpy((char*)fname,dir_entry.long_name);
0044DE  2FFD01     MOV #0xFFD0, W1
0044E0  40808F     ADD W1, W15, W1
0044E2  2FFB00     MOV #0xFFB0, W0
0044E4  40000F     ADD W0, W15, W0
0044E6  07DF3E     RCALL _strcpy
191:                                   memmove(&chip_prog[entry_nbr*ENTRY_SIZE],fname,ENTRY_SIZE);
0044E8  DD4045     SL W8, #5, W0
0044EA  208004     MOV #0x800, W4
0044EC  400004     ADD W0, W4, W0
0044EE  200202     MOV #0x20, W2
0044F0  2FFB01     MOV #0xFFB0, W1
0044F2  40808F     ADD W1, W15, W1
0044F4  07DEF3     RCALL _memmove
192:                                   entry_nbr++;
0044F6  E80408     INC W8, W8
193:                               }
194:                           }
195:                       }
196:                       fname[0]=0;
197:                       chip_prog[entry_nbr*ENTRY_SIZE]=0;
004506  DD4245     SL W8, #5, W4
004508  208005     MOV #0x800, W5
00450A  428204     ADD W5, W4, W4
00450C  EB4A00     CLR.B [W4]
198:                       return entry_nbr;
199:               }
00450E  780008     MOV W8, W0
004510  BE044F     MOV.D [--W15], W8
004512  FA8000     ULNK
004514  060000     RETURN
200:               
201:               void games_on_sdcard(){
202:                   int16_t fcount, selected;
203:               
204:                   if (!fs_mount()){
004516  070153     RCALL fs_mount
004518  504FE0     SUB.B W0, #0x0, [W15]
00451A  3A0003     BRA NZ, 0x4522
205:                       print("fs_mount() failed");
00451C  2A6020     MOV #0xA602, W0
00451E  07FE48     RCALL print
206:                       return;
004520  37001A     BRA 0x4556
207:                   }
208:                   if (!fs_open_dir("/")){
004522  2A6140     MOV #0xA614, W0
004524  07017C     RCALL fs_open_dir
004526  504FE0     SUB.B W0, #0x0, [W15]
004528  3A0003     BRA NZ, 0x4530
209:                       print("fs_open_dir() failed");
00452A  2A6160     MOV #0xA616, W0
00452C  07FE41     RCALL print
210:                       return;
00452E  370013     BRA 0x4556
211:                   }
212:                   fcount=sdc_files();
004530  07FFC0     RCALL sdc_files
213:                   if (fcount && ((selected=select_file(fcount))>-1)){
004532  500FE0     SUB W0, #0x0, [W15]
004534  32000D     BRA Z, 0x4550
004536  07FF40     RCALL select_file
004538  500FE0     SUB W0, #0x0, [W15]
00453A  35000A     BRA LT, 0x4550
214:                       if (fs_load_file(selected)){
00453C  0701B7     RCALL fs_load_file
00453E  504FE0     SUB.B W0, #0x0, [W15]
004540  320007     BRA Z, 0x4550
215:                           cls();
004542  07FCD0     RCALL cls
216:                           if (schip(F_RESET)==CHIP_BAD_OPCODE){
004544  B3C020     MOV.B #0x2, W0
004546  07F608     RCALL schip
004548  504FE2     SUB.B W0, #0x2, [W15]
00454A  3A0002     BRA NZ, 0x4550
217:                               print_vms("CRASH! bad opcode\n");
00454C  2A62B0     MOV #0xA62B, W0
00454E  07F5CA     RCALL print_vms
218:                           }
219:                       }
220:                   }
221:                   fs_close_dir();
004550  07017B     RCALL fs_close_dir
222:                   fs_umount();
004552  07015C     RCALL fs_umount
223:                   cls();
004554  07FCC7     RCALL cls
224:               }
004556  060000     RETURN
225:               #endif
226:               
227:               
228:               // sélection et exécution
229:               // d'un jeux qui est en
230:               // mémoire flash
231:               void games_in_flash(){
004558  BE9F88     MOV.D W8, [W15++]
00455A  BE9F8A     MOV.D W10, [W15++]
232:               	uint16_t i,selected;
233:               
234:                       for (i=0;i<GAMES_COUNT;i++){
00455C  208009     MOV #0x800, W9
00455E  EB0400     CLR W8
00456C  E80408     INC W8, W8
00456E  B00209     ADD #0x20, W9
004570  540FE4     SUB W8, #0x4, [W15]
004572  3AFFF8     BRA NZ, 0x4564
235:                           strcpy((char*)chip_prog+i*ENTRY_SIZE,flash_games[i].name);
004560  20026A     MOV #0x26, W10
004562  2A63EB     MOV #0xA63E, W11
004564  B9C20A     MUL.SS W8, W10, W4
004566  458084     ADD W11, W4, W1
004568  780009     MOV W9, W0
00456A  07DEFC     RCALL _strcpy
236:                       }
237:               	cls();
004574  07FCB7     RCALL cls
238:               	selected=select_file(GAMES_COUNT);
004576  200040     MOV #0x4, W0
004578  07FF1F     RCALL select_file
00457A  780400     MOV W0, W8
239:                       if (flash_games[selected].description){
00457C  200264     MOV #0x26, W4
00457E  B9C204     MUL.SS W8, W4, W4
004580  B00244     ADD #0x24, W4
004582  2A63E5     MOV #0xA63E, W5
004584  7A0065     MOV [W5+W4], W0
004586  500FE0     SUB W0, #0x0, [W15]
004588  320002     BRA Z, 0x458E
240:                           text_scroller(flash_games[selected].description,2);
00458A  B3C021     MOV.B #0x2, W1
00458C  07FE94     RCALL text_scroller
241:                       }
242:                       memcpy(chip_prog,flash_games[selected].binary,flash_games[selected].size);
00458E  200264     MOV #0x26, W4
004590  B9C404     MUL.SS W8, W4, W8
004592  200205     MOV #0x20, W5
004594  428288     ADD W5, W8, W5
004596  2A63E4     MOV #0xA63E, W4
004598  B00228     ADD #0x22, W8
00459A  7C00E4     MOV [W4+W8], W1
00459C  7A8164     MOV [W4+W5], W2
00459E  208000     MOV #0x800, W0
0045A0  07DE96     RCALL _memcpy
243:                       cls();
0045A2  07FCA0     RCALL cls
244:               #if FW_DEBUG
245:               	schip(F_DEBUG|F_RESET);
246:               #else
247:               	if (schip(F_RESET)==CHIP_BAD_OPCODE){
0045A4  B3C020     MOV.B #0x2, W0
0045A6  07F5D8     RCALL schip
0045A8  504FE2     SUB.B W0, #0x2, [W15]
0045AA  3A0002     BRA NZ, 0x45B0
248:               		print("CRASH! bad opcode\n");
0045AC  2A62B0     MOV #0xA62B, W0
0045AE  07FE00     RCALL print
249:               	};
250:               #endif
251:               }
0045B0  BE054F     MOV.D [--W15], W10
0045B2  BE044F     MOV.D [--W15], W8
0045B4  060000     RETURN
252:               
253:               const char credits[]=
254:               	"FAT driver\n"
255:               	"Copyright 2006-2012\n"
256:               	"Roland Riegel\n";
257:               
258:               #include "splash.h"
259:               
260:               void splash_screen(){
0045B6  BE9F88     MOV.D W8, [W15++]
261:               	uint16_t frame_delay;
262:               
263:                       screen_restore((uint8_t*)splash);
0045B8  29FE20     MOV #0x9FE2, W0
0045BA  07FD5E     RCALL screen_restore
264:               	frame_delay=frame_counter+25;
0045BC  80E365     MOV frame_counter, W5
0045BE  4282F9     ADD W5, #0x19, W5
265:               	while (frame_delay>frame_counter){
0045C4  370008     BRA 0x45D6
0045D6  80E364     MOV frame_counter, W4
0045D8  520F85     SUB W4, W5, [W15]
0045DA  39FFF5     BRA NC, 0x45C6
266:                           if (any_key()){
0045C6  801614     MOV PORTA, W4
0045C8  62027F     AND W4, #0x1F, W4
0045CA  520FFF     SUB W4, #0x1F, [W15]
0045CC  320004     BRA Z, 0x45D6
267:                                tone(1000,2);
0045C0  200028     MOV #0x2, W8
0045C2  203E89     MOV #0x3E8, W9
0045CE  780088     MOV W8, W1
0045D0  780009     MOV W9, W0
0045D2  070242     RCALL tone
268:                                frame_delay=frame_counter;
0045D4  80E365     MOV frame_counter, W5
269:                           }
270:               	}
271:               	wait_key_release();
0045DC  801614     MOV PORTA, W4
0045DE  62027F     AND W4, #0x1F, W4
0045E0  520FFF     SUB W4, #0x1F, [W15]
0045E2  3AFFFC     BRA NZ, 0x45DC
272:                       text_scroller(credits,2);
0045E4  B3C021     MOV.B #0x2, W1
0045E6  2A6D60     MOV #0xA6D6, W0
0045E8  07FE66     RCALL text_scroller
273:                       cls();
0045EA  07FC7C     RCALL cls
274:               }
0045EC  BE044F     MOV.D [--W15], W8
0045EE  060000     RETURN
275:               
276:               int main() {
0045F0  BE9F88     MOV.D W8, [W15++]
277:                   uint32_t size;
278:               
279:                   HardwareInit();
0045F2  07018A     RCALL HardwareInit
280:                   tone(500,250);
0045F4  200FA1     MOV #0xFA, W1
0045F6  201F40     MOV #0x1F4, W0
0045F8  07022F     RCALL tone
281:                   LCDout_init();
0045FA  070068     RCALL LCDout_init
282:                   splash_screen();
0045FC  07FFDC     RCALL splash_screen
283:                   srand(TMR1);
0045FE  800800     MOV TMR1, W0
004600  07DE85     RCALL _srand
284:                   while(1){noise(2000);pause(2500);}
004602  207D08     MOV #0x7D0, W8
004604  209C49     MOV #0x9C4, W9
004606  780008     MOV W8, W0
004608  070250     RCALL noise
00460A  780009     MOV W9, W0
00460C  0701B9     RCALL pause
00460E  37FFFB     BRA 0x4606
285:                   while(1){
286:                       select_font(FONT_ASCII);
287:                       set_cursor(0,0);
288:                       memset(chip_prog,0,PROG_SPACE);
289:                       if (sdcard_available){
290:                           games_on_sdcard();
291:                       }else{
292:                           games_in_flash();
293:                       }
294:                   }
295:                   return (EXIT_SUCCESS);
296:               }
297:               
---  C:/Users/Jacques/Documents/GitHub/PicVisionPortable/PICVisionPortable.X/keypad.c  ------------------
1:                 /*
2:                 * Copyright 2014, Jacques Deschênes
3:                 * This file is part of CHIPcon.
4:                 *
5:                 *     CHIPcon is free software: you can redistribute it and/or modify
6:                 *     it under the terms of the GNU General Public License as published by
7:                 *     the Free Software Foundation, either version 3 of the License, or
8:                 *     (at your option) any later version.
9:                 *
10:                *     CHIPcon is distributed in the hope that it will be useful,
11:                *     but WITHOUT ANY WARRANTY; without even the implied warranty of
12:                *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
13:                *     GNU General Public License for more details.
14:                *
15:                *     You should have received a copy of the GNU General Public License
16:                *     along with CHIPcon.  If not, see <http://www.gnu.org/licenses/>.
17:                */
18:                
19:                /*
20:                 * keypad.c
21:                 *
22:                 * Created: 2014-10-03 12:29:17
23:                 *  Author: Jacques Deschênes
24:                 */ 
25:                
26:                #include "keypad.h"
27:                #include "display.h"
28:                #include "text.h"
29:                #include "tone.h"
30:                
31:                
32:                // quels boutons sont enfoncés
33:                // certaines combinaisons sont signalées comme invalides
34:                // sur les 32 possibles 16 sont valides
35:                const uint8_t BUTTONS_DOWN[32]={ // S-R-L-D-U
36:                  NO_KEY,       // 0-0-0-0-0
37:                  UP,           // 0-0-0-0-U
38:                  DOWN,         // 0-0-0-D-0
39:                  UP_DOWN,      // 0-0-0-D-U
40:                  LEFT,         // 0-0-L-0-0
41:                  LEFT_UP,      // 0-0-L-0-U
42:                  DOWN_LEFT,    // 0-0-L-D-0
43:                  INVALID,      // 0-0-L-D-U
44:                  RIGHT,        // 0-R-0-0-0
45:                  UP_RIGHT,     // 0-R-0-0-U
46:                  RIGHT_DOWN,   // 0-R-0-D-0
47:                  INVALID,      // 0-R-0-D-U
48:                  LEFT_RIGHT,   // 0-R-L-0-0
49:                  LR_UP,        // 0-R-L-0-U
50:                  INVALID,      // 0-R-L-D-0
51:                  INVALID,      // 0-R-L-D-U
52:                  SELECT,       // S-0-0-0-0
53:                  S_UP,         // S-0-0-0-U
54:                  S_DOWN,       // S-0-0-D-0
55:                  INVALID,      // S-0-0-D-U
56:                  S_LEFT,       // S-0-L-0-0
57:                  INVALID,      // S-0-L-0-U
58:                  INVALID,      // S-0-L-D-0
59:                  INVALID,      // S-0-L-D-U
60:                  S_RIGHT,      // S-R-0-0-0
61:                  INVALID,      // S-R-0-0-U
62:                  INVALID,      // S-R-0-D-0
63:                  INVALID,      // S-R-0-D-U
64:                  INVALID,      // S-R-L-0-0
65:                  INVALID,      // S-R-L-0-U
66:                  INVALID,      // S-R-L-D-0
67:                  INVALID       // S-R-L-D-U
68:                };
69:                
70:                #define BOUNCING_DLY (10)
71:                
72:                uint8_t keypad_read(){
73:                    uint8_t code,latch;
74:                    uint32_t t0;
75:                    t0=systick+BOUNCING_DLY;
004ADE  80E9D4     MOV systick, W4
004AE0  80E9E5     MOV 0x1D3C, W5
004AE2  42006A     ADD W4, #0xA, W0
004AE4  4A80E0     ADDC W5, #0x0, W1
76:                    code=KP_MASK;
004AE6  B3C1F6     MOV.B #0x1F, W6
77:                    while (t0>systick){
004AE8  37000A     BRA 0x4AFE
004AFE  80E9D4     MOV systick, W4
004B00  80E9E5     MOV 0x1D3C, W5
004B02  520F80     SUB W4, W0, [W15]
004B04  5A8F81     SUBB W5, W1, [W15]
004B06  39FFF1     BRA NC, 0x4AEA
78:                        latch=keypad_latch();
004AEA  801614     MOV PORTA, W4
004AEC  EAC204     COM.B W4, W4
004AEE  62427F     AND.B W4, #0x1F, W4
004AFC  784304     MOV.B W4, W6
79:                        if (latch!=code){
004AF0  524F86     SUB.B W4, W6, [W15]
004AF2  320005     BRA Z, 0x4AFE
80:                            t0=systick+BOUNCING_DLY;
004AF4  80E9D6     MOV systick, W6
004AF6  80E9E7     MOV 0x1D3C, W7
004AF8  43006A     ADD W6, #0xA, W0
004AFA  4B80E0     ADDC W7, #0x0, W1
81:                            code=latch;
82:                        }
83:                    }
84:                    code=BUTTONS_DOWN[code];
004B08  FB8306     ZE W6, W6
004B0A  2A8AE4     MOV #0xA8AE, W4
004B0C  7B4064     MOV.B [W4+W6], W0
85:                    return code;
86:                }
004B0E  060000     RETURN
87:                
88:                uint8_t wait_key(){
89:                    uint8_t key;
90:                    while ((key=keypad_read())==NO_KEY);
004B10  07FFE6     RCALL keypad_read
004B12  404FE1     ADD.B W0, #0x1, [W15]
004B14  32FFFD     BRA Z, wait_key
91:                    return key;
92:                }
004B16  060000     RETURN
93:                
94:                bool key_down(uint8_t key){
95:                    key = key&15;
004B1E  60406F     AND.B W0, #0xF, W0
96:                    return (BUTTONS_DOWN[keypad_latch()]==key);
004B18  801614     MOV PORTA, W4
004B1A  EA8204     COM W4, W4
004B1C  62027F     AND W4, #0x1F, W4
004B20  2A8AE5     MOV #0xA8AE, W5
004B22  7A4265     MOV.B [W5+W4], W4
004B24  684004     XOR.B W0, W4, W0
004B26  FB8000     ZE W0, W0
004B28  E90000     DEC W0, W0
004B2A  DE004F     LSR W0, #15, W0
97:                }//f()
004B2C  060000     RETURN
98:                
99:                void prompt_key(){
004B2E  BE9F88     MOV.D W8, [W15++]
100:                   uint8_t key;
101:               
102:                   select_font(FONT_ASCII);
004B30  B3C020     MOV.B #0x2, W0
004B32  07FAA9     RCALL select_font
103:                   while (keypad_read()!=NO_KEY);
004B34  07FFD4     RCALL keypad_read
004B36  404FE1     ADD.B W0, #0x1, [W15]
004B38  3AFFFD     BRA NZ, 0x4B34
104:                   print("une touche...");
004B3A  2A8A00     MOV #0xA8A0, W0
004B3C  07FB39     RCALL print
105:                   wait_key();
004B3E  07FFE8     RCALL wait_key
106:                   while ((key=keypad_read())!=NO_KEY) key_tone(key,20,false);
004B40  EB4400     CLR.B W8
004B42  200149     MOV #0x14, W9
004B44  370003     BRA 0x4B4C
004B46  784108     MOV.B W8, W2
004B48  780089     MOV W9, W1
004B4A  07FFA1     RCALL key_tone
004B4C  07FFC8     RCALL keypad_read
004B4E  404FE1     ADD.B W0, #0x1, [W15]
004B50  3AFFFA     BRA NZ, 0x4B46
107:               }
004B52  BE044F     MOV.D [--W15], W8
004B54  060000     RETURN
108:               
109:               
110:               // KEY_UP and KEY_DOWN pressed at same time
111:               bool keypad_break(){
112:                   return ((KP_PORT & KP_BREAK)==0);
004B56  801610     MOV PORTA, W0
004B58  600063     AND W0, #0x3, W0
004B5A  E90000     DEC W0, W0
004B5C  DE004F     LSR W0, #15, W0
113:               }//f()
004B5E  060000     RETURN
114:               
115:               
116:               
---  C:/Users/Jacques/Documents/GitHub/PicVisionPortable/PICVisionPortable.X/filesys.c  -----------------
1:                 /*
2:                  * filesys.c
3:                  *
4:                  * Created: 2014-10-11 21:08:50
5:                  *  Author: Jacques Deschênes
6:                  *  une seule partition ouverte
7:                  *  un seul système de fichier ouvert
8:                  *  un seul répertoire ouvert.
9:                  *  un seul fichier ouvert.
10:                 */ 
11:                
12:                #include <string.h>
13:                
14:                #include "filesys.h"
15:                #include "keypad.h"
16:                #include "text.h"
17:                #include "sram.h"
18:                #include "hardware/LCDout.h"
19:                #include "display.h"
20:                #include "chip8.h"
21:                
22:                
23:                
24:                static struct fat_fs_struct *fs;
25:                static struct fat_dir_struct *dd;
26:                static struct fat_file_struct *fd;
27:                static struct partition_struct *partition;
28:                
29:                
30:                void bad_sdcard(const char *msg){
0047AA  781F88     MOV W8, [W15++]
0047AC  780400     MOV W0, W8
31:                    cls();
0047AE  07FB9A     RCALL cls
32:                    select_font(FONT_ASCII);
0047B0  B3C020     MOV.B #0x2, W0
0047B2  07FC69     RCALL select_font
33:                    print(msg);
0047B4  780008     MOV W8, W0
0047B6  07FCFC     RCALL print
34:                    prompt_key();
0047B8  0701BA     RCALL prompt_key
35:                }
0047BA  78044F     MOV [--W15], W8
0047BC  060000     RETURN
36:                
37:                
38:                uint8_t fs_mount(){
39:                    if (get_pin_available()){
0047BE  801654     MOV PORTB, W4
0047C0  620268     AND W4, #0x8, W4
0047C4  3A0022     BRA NZ, 0x480A
40:                        // pas de carte SD
41:                        // dans le lecteur
42:                        return 0;
0047C2  EB4000     CLR.B W0
43:                    }
44:                    /* ouvre la première partition */
45:                    partition = partition_open(sd_raw_read, sd_raw_read_interval, 0, 0, 0);
0047C6  784200     MOV.B W0, W4
0047C8  EB0180     CLR W3
0047CA  780103     MOV W3, W2
0047CC  238FE1     MOV #0x38FE, W1
0047CE  238760     MOV #0x3876, W0
0047D0  0700FB     RCALL partition_open
0047D2  88EA30     MOV W0, partition
46:                    if(!partition)
0047D4  500FE0     SUB W0, #0x0, [W15]
0047D6  3A000D     BRA NZ, 0x47F2
47:                    {
48:                        /* Si la partition n'a pas ouvert essaie
49:                         * pour  "superfloppy", i.e. pas de MBR.
50:                         */
51:                        partition = partition_open(sd_raw_read, sd_raw_read_interval, 0, 0, -1);
0047D8  EBC200     SETM.B W4
0047DA  EB0180     CLR W3
0047DC  780103     MOV W3, W2
0047DE  238FE1     MOV #0x38FE, W1
0047E0  238760     MOV #0x3876, W0
0047E2  0700F2     RCALL partition_open
0047E4  88EA30     MOV W0, partition
52:                        if(!partition)
0047E6  500FE0     SUB W0, #0x0, [W15]
0047E8  3A0004     BRA NZ, 0x47F2
53:                        {   // rien à faire avec cette carte
54:                            bad_sdcard("Echec acces partition\n");
0047EA  2A8480     MOV #0xA848, W0
0047EC  07FFDE     RCALL bad_sdcard
55:                            return 0;
0047EE  EB4000     CLR.B W0
0047F0  37000C     BRA 0x480A
56:                        }
57:                    }
58:                
59:                    /* ouvre le système de fichiers */
60:                    fs = fat_open(partition);
0047F2  80EA30     MOV partition, W0
0047F4  07F255     RCALL fat_open
0047F6  780200     MOV W0, W4
0047F8  88EA24     MOV W4, fs
61:                    if(!fs)
0047FC  520FE0     SUB W4, #0x0, [W15]
0047FE  3A0005     BRA NZ, 0x480A
62:                    {
63:                        bad_sdcard("Echec acces fichiers\n");
004800  2A85F0     MOV #0xA85F, W0
004802  07FFD3     RCALL bad_sdcard
64:                        partition_close(partition);
004804  80EA30     MOV partition, W0
004806  070121     RCALL partition_close
65:                        return 0;
004808  EB4000     CLR.B W0
66:                    }
67:                
68:                    return 1;
0047FA  B3C010     MOV.B #0x1, W0
69:                }
00480A  060000     RETURN
70:                
71:                void fs_umount(){
72:                    fat_close_file(fd);
00480C  80EA10     MOV fd, W0
00480E  07F278     RCALL fat_close_file
73:                    fat_close_dir(dd);
004810  80EA00     MOV dd, W0
004812  07F350     RCALL fat_close_dir
74:                    fat_close(fs);
004814  80EA20     MOV fs, W0
004816  07F258     RCALL fat_close
75:                    partition_close(partition);
004818  80EA30     MOV partition, W0
00481A  070117     RCALL partition_close
76:                }
00481C  060000     RETURN
77:                
78:                
79:                uint8_t  fs_open_dir(const char *dir_name){
00481E  FA002C     LNK #0x2C
80:                    /* ouvre le répertoire dir_name */
81:                    struct fat_dir_entry_struct directory;
82:                    fat_get_dir_entry_of_path(fs, dir_name, &directory);
004820  2FFD42     MOV #0xFFD4, W2
004822  41010F     ADD W2, W15, W2
004824  780080     MOV W0, W1
004826  80EA20     MOV fs, W0
004828  07F3B4     RCALL fat_get_dir_entry_of_path
83:                    dd = fat_open_dir(fs, &directory);
00482A  2FFD41     MOV #0xFFD4, W1
00482C  40808F     ADD W1, W15, W1
00482E  80EA20     MOV fs, W0
004830  07F323     RCALL fat_open_dir
004832  88EA00     MOV W0, dd
84:                    if(!dd)
004836  500FE0     SUB W0, #0x0, [W15]
004838  3A0004     BRA NZ, 0x4842
85:                    {
86:                        bad_sdcard("Echec acces repert.\n");
00483A  2A8750     MOV #0xA875, W0
00483C  07FFB6     RCALL bad_sdcard
87:                        fs_umount();
00483E  07FFE6     RCALL fs_umount
88:                        return 0;
004840  EB4200     CLR.B W4
89:                    }
90:                    return 1;
004834  B3C014     MOV.B #0x1, W4
91:                }
004842  784004     MOV.B W4, W0
004844  FA8000     ULNK
004846  060000     RETURN
92:                
93:                void fs_close_dir(){
94:                    fat_close_dir(dd);
004848  80EA00     MOV dd, W0
00484A  07F334     RCALL fat_close_dir
95:                }
00484C  060000     RETURN
96:                
97:                uint8_t fs_open_file(const char *file_name){
00484E  FA002C     LNK #0x2C
004850  781F88     MOV W8, [W15++]
004852  780400     MOV W0, W8
98:                    uint8_t found=0;
99:                    struct fat_dir_entry_struct dir_entry;
100:                   while(fat_read_dir(dd, &dir_entry))
004854  370011     BRA 0x4878
004878  2FFD21     MOV #0xFFD2, W1
00487A  40808F     ADD W1, W15, W1
00487C  80EA00     MOV dd, W0
00487E  07F328     RCALL fat_read_dir
004880  504FE0     SUB.B W0, #0x0, [W15]
004882  3AFFE9     BRA NZ, 0x4856
004884  370003     BRA 0x488C
101:                   {
102:                       if(strcmp(dir_entry.long_name, file_name) == 0)
004856  780088     MOV W8, W1
004858  2FFD20     MOV #0xFFD2, W0
00485A  40000F     ADD W0, W15, W0
00485C  07DD7C     RCALL _strcmp
00485E  500FE0     SUB W0, #0x0, [W15]
004860  3A000B     BRA NZ, 0x4878
103:                       {
104:                           fat_reset_dir(dd);
004862  80EA00     MOV dd, W0
004864  07F32B     RCALL fat_reset_dir
105:                           found= 1;
106:                           break;
107:                       }
108:                   }
109:               
110:                   if (!found) return 0;
111:                   fd=fat_open_file(fs, &dir_entry);
004866  2FFD21     MOV #0xFFD2, W1
004868  40808F     ADD W1, W15, W1
00486A  80EA20     MOV fs, W0
00486C  07F231     RCALL fat_open_file
00486E  88EA10     MOV W0, fd
112:                   if(!fd){
004870  500FE0     SUB W0, #0x0, [W15]
004872  320009     BRA Z, 0x4886
113:                       bad_sdcard("Echec ouvert. fich.\n");
004886  2A88A0     MOV #0xA88A, W0
004888  07FF90     RCALL bad_sdcard
114:                       return 0;
00488A  EB4000     CLR.B W0
115:                   }
116:                   //print(fd->dir_entry.long_name);
117:                   return 1;
004874  B3C010     MOV.B #0x1, W0
004876  37000A     BRA 0x488C
118:               }
00488C  78044F     MOV [--W15], W8
00488E  FA8000     ULNK
004890  060000     RETURN
119:               
120:               
121:               void fs_close_file(){
122:                   fat_close_file(fd);
004892  80EA10     MOV fd, W0
004894  07F235     RCALL fat_close_file
123:               }
004896  060000     RETURN
124:               
125:               void fs_file_reset(){
126:                   fat_seek_file(fd,0,FAT_SEEK_SET);
004898  EB4100     CLR.B W2
00489A  EB0080     CLR W1
00489C  80EA10     MOV fd, W0
00489E  07F2C5     RCALL fat_seek_file
127:               }//f()
0048A0  060000     RETURN
128:               
129:               intptr_t fs_read_file(uint8_t* buffer, uintptr_t buffer_len){
130:                   return fat_read_file(fd,buffer,buffer_len);
0048A2  780101     MOV W1, W2
0048A4  780080     MOV W0, W1
0048A6  80EA10     MOV fd, W0
0048A8  07F22F     RCALL fat_read_file
131:               }//f()
0048AA  060000     RETURN
132:               
133:               #define BUFF_SIZE (256)
134:               // charge le fichier CHIP-8 dans la SRAM
135:               // retourne nombres d'octets
136:               uint8_t fs_load_file(uint16_t file_no){
0048AC  FA0100     LNK #0x100
0048AE  BE9F88     MOV.D W8, [W15++]
0048B0  BE9F8A     MOV.D W10, [W15++]
137:                   uint16_t byte_count=0;
138:                   uint16_t count;
139:                   uint8_t buffer[256];
140:                   memmove(&buffer, &chip_prog[ENTRY_SIZE*file_no],ENTRY_SIZE);
0048B2  DD00C5     SL W0, #5, W1
0048B4  208004     MOV #0x800, W4
0048B6  408084     ADD W1, W4, W1
0048B8  200202     MOV #0x20, W2
0048BA  2FEF80     MOV #0xFEF8, W0
0048BC  40000F     ADD W0, W15, W0
0048BE  07DD0E     RCALL _memmove
141:                   if (fs_open_file((char*)buffer)){
0048C0  2FEF80     MOV #0xFEF8, W0
0048C2  40000F     ADD W0, W15, W0
0048C4  07FFC4     RCALL fs_open_file
0048C6  EB0400     CLR W8
0048C8  504FE0     SUB.B W0, #0x0, [W15]
0048CA  3A000A     BRA NZ, 0x48E0
0048CC  370014     BRA 0x48F6
142:                       //print(fd->dir_entry.long_name);new_line();
143:                       while((byte_count<PROG_SPACE) && (count = fat_read_file(fd, buffer, 256))){
0048DA  540F8B     SUB W8, W11, [W15]
0048DC  360003     BRA LEU, 0x48E4
0048DE  37000A     BRA 0x48F4
0048E2  20FFFB     MOV #0xFFF, W11
0048E4  201002     MOV #0x100, W2
0048E6  2FEF81     MOV #0xFEF8, W1
0048E8  40808F     ADD W1, W15, W1
0048EA  80EA10     MOV fd, W0
0048EC  07F20D     RCALL fat_read_file
0048EE  780480     MOV W0, W9
0048F0  548FE0     SUB W9, #0x0, [W15]
0048F2  3AFFED     BRA NZ, 0x48CE
144:                           memmove(&chip_prog[byte_count],buffer,count);
0048CE  44000A     ADD W8, W10, W0
0048D0  780109     MOV W9, W2
0048D2  2FEF81     MOV #0xFEF8, W1
0048D4  40808F     ADD W1, W15, W1
0048D6  07DD02     RCALL _memmove
0048E0  20800A     MOV #0x800, W10
145:                           byte_count+=count;
0048D8  440409     ADD W8, W9, W8
146:                       }
147:                       fs_close_file();
0048F4  07FFCE     RCALL fs_close_file
148:                   }
149:                   return byte_count;
150:               }
0048F6  784008     MOV.B W8, W0
0048F8  BE054F     MOV.D [--W15], W10
0048FA  BE044F     MOV.D [--W15], W8
0048FC  FA8000     ULNK
0048FE  060000     RETURN
151:               
152:               inline uint8_t fs_read_dir(struct fat_dir_entry_struct *dir_entry){
153:                   return fat_read_dir(dd, dir_entry);
004900  780080     MOV W0, W1
004902  80EA00     MOV dd, W0
004904  07F2E5     RCALL fat_read_dir
154:               }
004906  060000     RETURN
155:               
---  C:/Users/Jacques/Documents/GitHub/PicVisionPortable/PICVisionPortable.X/display.c  -----------------
1:                 /*
2:                 * Copyright 2014, Jacques Deschênes
3:                 * This file is part of CHIPcon.
4:                 *
5:                 *     CHIPcon is free software: you can redistribute it and/or modify
6:                 *     it under the terms of the GNU General Public License as published by
7:                 *     the Free Software Foundation, either version 3 of the License, or
8:                 *     (at your option) any later version.
9:                 *
10:                *     CHIPcon is distributed in the hope that it will be useful,
11:                *     but WITHOUT ANY WARRANTY; without even the implied warranty of
12:                *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
13:                *     GNU General Public License for more details.
14:                *
15:                *     You should have received a copy of the GNU General Public License
16:                *     along with CHIPcon.  If not, see <http://www.gnu.org/licenses/>.
17:                */
18:                
19:                /*
20:                 * tvout.c
21:                 *
22:                 * Created: 2014-09-25 12:35:29
23:                 *  Author: Jacques Deschênes
24:                 */ 
25:                
26:                #include <stdlib.h>
27:                #include <string.h>
28:                
29:                #include "hardware/HardwareProfile.h"
30:                #include "Hardware/LCDout.h"
31:                #include "display.h"
32:                #include "text.h"
33:                #include "tone.h"
34:                
35:                // dessine un point à l'écran
36:                void plot(int8_t x, int8_t y, optype op){
003C0A  784381     MOV.B W1, W7
37:                    int8_t xbyte,xbit;
38:                
39:                    if ((x<0)||(x>=HRES)||(y<0)||(y>=VRES)) return;
003C0C  504FE0     SUB.B W0, #0x0, [W15]
003C0E  350036     BRA LT, 0x3C7C
003C10  53CFE0     SUB.B W7, #0x0, [W15]
003C12  350034     BRA LT, 0x3C7C
003C14  B3C3F4     MOV.B #0x3F, W4
003C16  53CF84     SUB.B W7, W4, [W15]
003C18  3C0031     BRA GT, 0x3C7C
40:                    xbyte= x/8;
003C1A  FB0000     SE W0, W0
003C1C  200084     MOV #0x8, W4
003C1E  090011     REPEAT #0x11
003C20  D80004     DIV.SW W0, W4
003C22  780281     MOV W1, W5
41:                    xbit = 7-x%8;
003C24  B3C076     MOV.B #0x7, W6
003C26  534285     SUB.B W6, W5, W5
42:                    switch (op){
003C28  510FE1     SUB W2, #0x1, [W15]
003C2A  320010     BRA Z, 0x3C4C
003C2C  390003     BRA NC, 0x3C34
003C2E  510FE2     SUB W2, #0x2, [W15]
003C30  3A0025     BRA NZ, 0x3C7C
003C32  370019     BRA 0x3C66
43:                        case WHITE:
44:                        display_buffer[y][xbyte] |= (1<<xbit);
003C34  FB0087     SE W7, W1
003C36  FB0000     SE W0, W0
003C38  2186C4     MOV #0x186C, W4
003C3A  DD08C4     SL W1, #4, W1
003C3C  408000     ADD W1, W0, W0
003C3E  420380     ADD W4, W0, W7
003C40  FB0285     SE W5, W5
003C42  200016     MOV #0x1, W6
003C44  DD3285     SL W6, W5, W5
003C46  784264     MOV.B [W4+W0], W4
003C48  724B85     IOR.B W4, W5, [W7]
45:                        break;
003C4A  370018     BRA 0x3C7C
46:                        case BLACK:
47:                        display_buffer[y][xbyte] &= ~(1<<xbit);
003C4C  FB0087     SE W7, W1
003C4E  FB0000     SE W0, W0
003C50  2186C4     MOV #0x186C, W4
003C52  DD08C4     SL W1, #4, W1
003C54  408000     ADD W1, W0, W0
003C56  420380     ADD W4, W0, W7
003C58  FB0285     SE W5, W5
003C5A  200016     MOV #0x1, W6
003C5C  DD3285     SL W6, W5, W5
003C5E  EAC285     COM.B W5, W5
003C60  784264     MOV.B [W4+W0], W4
003C62  62CB84     AND.B W5, W4, [W7]
48:                        break;
003C64  37000B     BRA 0x3C7C
49:                        case INVERT:
50:                        display_buffer[y][xbyte] ^= (1<<xbit);
003C66  FB0087     SE W7, W1
003C68  FB0000     SE W0, W0
003C6A  2186C4     MOV #0x186C, W4
003C6C  DD08C4     SL W1, #4, W1
003C6E  408000     ADD W1, W0, W0
003C70  420380     ADD W4, W0, W7
003C72  FB0285     SE W5, W5
003C74  200016     MOV #0x1, W6
003C76  DD3285     SL W6, W5, W5
003C78  784264     MOV.B [W4+W0], W4
003C7A  6A4B85     XOR.B W4, W5, [W7]
51:                        break;
52:                    }
53:                }
003C7C  060000     RETURN
54:                
55:                
56:                // dessine un sprite 8 pixels par n pixels
57:                // s'il y a collision retourne une valeur 1
58:                // autrement 0.
59:                int8_t put_sprite(int8_t x, int8_t y, uint8_t n, const uint8_t *sprite){
003C7E  4787EA     ADD W15, #0xA, W15
003C80  BE9F88     MOV.D W8, [W15++]
003C82  BE9F8A     MOV.D W10, [W15++]
003C84  BE9F8C     MOV.D W12, [W15++]
003C86  781F8E     MOV W14, [W15++]
003CA8  E84281     INC.B W1, W5
003CF6  E84281     INC.B W1, W5
003D62  FB8306     ZE W6, W6
003D64  EA0306     NEG W6, W6
60:                    int8_t xbyte, shl, shr, row, collision;
61:                    uint8_t sprite_row;
62:                
63:                
64:                    // contrôle des limites
65:                    if ((x<-7)||(x>=HRES)||(y<=-n)||y>=VRES){return 0;}
003C88  EB4300     CLR.B W6
003C8A  404FE7     ADD.B W0, #0x7, [W15]
003C8C  35006D     BRA LT, 0x3D68
003C8E  FB8102     ZE W2, W2
003C90  FB0281     SE W1, W5
003C92  EA0202     NEG W2, W4
003C94  528F84     SUB W5, W4, [W15]
003C96  340068     BRA LE, 0x3D68
003C98  B3C3F4     MOV.B #0x3F, W4
003C9A  50CF84     SUB.B W1, W4, [W15]
003C9C  3C0065     BRA GT, 0x3D68
003D66  DE334F     LSR W6, #15, W6
66:                    collision=0;
67:                    if (x<0){
003C9E  504F86     SUB.B W0, W6, [W15]
003CA0  3D0022     BRA GE, 0x3CE6
68:                        shl=-x;
003CA2  EA4580     NEG.B W0, W11
69:                        for (row=0;row<n;row++){
003CA4  510FE0     SUB W2, #0x0, [W15]
003CA6  340060     BRA LE, 0x3D68
003CAA  784206     MOV.B W6, W4
003CB4  E84081     INC.B W1, W1
003CB6  E84285     INC.B W5, W5
003CDC  E84204     INC.B W4, W4
003CDE  FB0384     SE W4, W7
003CE0  510F87     SUB W2, W7, [W15]
003CE2  3CFFE8     BRA GT, 0x3CB4
003CE4  37003E     BRA 0x3D62
70:                            if (y>=VRES) break;
003CB0  B3C3FA     MOV.B #0x3F, W10
003CB2  370004     BRA 0x3CBC
003CB8  504F8A     SUB.B W0, W10, [W15]
003CBA  3C0053     BRA GT, 0x3D62
71:                            if (y<0){y++;continue;}
003CBC  50CFE0     SUB.B W1, #0x0, [W15]
003CBE  3D0002     BRA GE, 0x3CC4
003CC0  784005     MOV.B W5, W0
003CC2  37000C     BRA 0x3CDC
72:                            sprite_row=sprite[row];
003CCA  FB0004     SE W4, W0
73:                            collision |= display_buffer[y][0] & (sprite_row<<shl);
003CAC  2186C9     MOV #0x186C, W9
003CAE  FB058B     SE W11, W11
003CC4  FB0401     SE W1, W8
003CC6  DD4444     SL W8, #4, W8
003CC8  7C43E9     MOV.B [W9+W8], W7
003CCC  784063     MOV.B [W3+W0], W0
003CCE  FB8000     ZE W0, W0
003CD0  DD000B     SL W0, W11, W0
003CD2  604607     AND.B W0, W7, W12
003CD4  73430C     IOR.B W6, W12, W6
74:                            display_buffer[y][0] ^= sprite_row<<shl;
003CD6  448408     ADD W9, W8, W8
003CD8  684C07     XOR.B W0, W7, [W8]
003CDA  784005     MOV.B W5, W0
75:                            y++;
76:                        }//for
77:                    }else{
78:                        shr= x&7;
003CE6  6043E7     AND.B W0, #0x7, W7
79:                        shl=(8-shr)&7;
003CE8  EA4707     NEG.B W7, W14
003CEA  674767     AND.B W14, #0x7, W14
80:                        xbyte=x>>3;
003CEC  FB0000     SE W0, W0
003CEE  DE0043     LSR W0, #3, W0
81:                        for (row=0;row<n;row++){
003CF0  EB4300     CLR.B W6
003CF2  510FE0     SUB W2, #0x0, [W15]
003CF4  340039     BRA LE, 0x3D68
003CF8  784206     MOV.B W6, W4
003D10  E84081     INC.B W1, W1
003D12  E84285     INC.B W5, W5
003D5A  E84204     INC.B W4, W4
003D5C  FB0384     SE W4, W7
003D5E  510F87     SUB W2, W7, [W15]
003D60  3CFFD7     BRA GT, 0x3D10
82:                            if (y>=VRES) break;
003D0C  B3C3FD     MOV.B #0x3F, W13
003D0E  370004     BRA 0x3D18
003D14  504F8D     SUB.B W0, W13, [W15]
003D16  3C0025     BRA GT, 0x3D62
83:                            if (y<0){y++;continue;}
003D18  50CFE0     SUB.B W1, #0x0, [W15]
003D1A  3D0002     BRA GE, 0x3D20
003D1C  784005     MOV.B W5, W0
003D1E  37001D     BRA 0x3D5A
84:                            sprite_row=sprite[row];
003D2A  FB0004     SE W4, W0
85:                            collision |= display_buffer[y][xbyte] & (sprite_row>>shr);
003CFA  FB0000     SE W0, W0
003CFC  9FBF80     MOV W0, [W15-16]
003CFE  2186C9     MOV #0x186C, W9
003D00  FB0387     SE W7, W7
003D02  9FB7F7     MOV W7, [W15-18]
003D20  FB0581     SE W1, W11
003D22  DD5C44     SL W11, #4, W8
003D24  97BE0F     MOV [W15-16], W12
003D26  44040C     ADD W8, W12, W8
003D28  7C43E9     MOV.B [W9+W8], W7
003D2C  784563     MOV.B [W3+W0], W10
003D2E  FB850A     ZE W10, W10
003D30  97B67F     MOV [W15-18], W12
003D32  DED00C     ASR W10, W12, W0
003D34  604607     AND.B W0, W7, W12
003D36  73430C     IOR.B W6, W12, W6
86:                            display_buffer[y][xbyte] ^= sprite_row>>shr;
003D38  448408     ADD W9, W8, W8
003D3A  684C07     XOR.B W0, W7, [W8]
87:                            if (shl && (xbyte+1<HBYTES)){
003D04  E80000     INC W0, W0
003D06  9FB7E0     MOV W0, [W15-20]
003D3C  574FE0     SUB.B W14, #0x0, [W15]
003D3E  32000C     BRA Z, 0x3D58
003D40  97B06F     MOV [W15-20], W0
003D42  500FEF     SUB W0, #0xF, [W15]
003D44  3C0009     BRA GT, 0x3D58
88:                                collision |= display_buffer[y][xbyte+1] & (sprite_row<<shl);
003D08  FB038E     SE W14, W7
003D0A  9FB7D7     MOV W7, [W15-22]
003D46  DD5DC4     SL W11, #4, W11
003D48  458580     ADD W11, W0, W11
003D4A  7DC3E9     MOV.B [W9+W11], W7
003D4C  97B65F     MOV [W15-22], W12
003D4E  DD550C     SL W10, W12, W10
003D50  654007     AND.B W10, W7, W0
003D52  734300     IOR.B W6, W0, W6
89:                                display_buffer[y][xbyte+1] ^= sprite_row<<shl;
003D54  44858B     ADD W9, W11, W11
003D56  6D4D87     XOR.B W10, W7, [W11]
003D58  784005     MOV.B W5, W0
90:                            }
91:                            y++;
92:                        }
93:                    }
94:                    if (collision) collision=1;
95:                    return collision;
96:                }
003D68  784006     MOV.B W6, W0
003D6A  78074F     MOV [--W15], W14
003D6C  BE064F     MOV.D [--W15], W12
003D6E  BE054F     MOV.D [--W15], W10
003D70  BE044F     MOV.D [--W15], W8
003D72  B100AF     SUB #0xA, W15
003D74  060000     RETURN
97:                
98:                //dessine un sprite 16x16pixels
99:                // le sprite est en mémoire RAM
100:               // s'il y a collision retourne 1,
101:               // autrement 0.
102:               int8_t put_big_sprite(int8_t x, int8_t y,const uint8_t *sprite){
003D76  4787EC     ADD W15, #0xC, W15
003D78  BE9F88     MOV.D W8, [W15++]
003D7A  BE9F8A     MOV.D W10, [W15++]
003D7C  BE9F8C     MOV.D W12, [W15++]
003D7E  781F8E     MOV W14, [W15++]
003D98  E80102     INC W2, W2
003D9A  B3C105     MOV.B #0x10, W5
003E2C  E80102     INC W2, W2
003E2E  B3C105     MOV.B #0x10, W5
003ED0  FB8204     ZE W4, W4
003ED2  EA0204     NEG W4, W4
103:                   int8_t xbyte, shl, shr, row, collision;
104:                   uint8_t sprite_row;
105:               
106:                   // contrôle des limites
107:                   if ((x<-15)||(x>=HRES)||(y<-15)||(y>=VRES)) return 0;
003D80  EB4200     CLR.B W4
003D82  404FEF     ADD.B W0, #0xF, [W15]
003D84  3500A8     BRA LT, 0x3ED6
003D86  40CFEF     ADD.B W1, #0xF, [W15]
003D88  3500A6     BRA LT, 0x3ED6
003D8A  B3C3F5     MOV.B #0x3F, W5
003D8C  50CF85     SUB.B W1, W5, [W15]
003D8E  3C00A3     BRA GT, 0x3ED6
003ED4  DE224F     LSR W4, #15, W4
108:                   collision=0;
003D9C  EB4200     CLR.B W4
003DD2  EB4200     CLR.B W4
003E30  EB4200     CLR.B W4
109:                   if (x<-7){ // x {-7..-15}
003D90  404FE7     ADD.B W0, #0x7, [W15]
003D92  3D001A     BRA GE, 0x3DC8
110:                       shl=-x-8;
003D94  B3CF84     MOV.B #0xF8, W4
003D96  524000     SUB.B W4, W0, W0
111:                       for (row=0;row<32;row+=2){
003DC2  52CFE0     SUB.B W5, #0x0, [W15]
003DC4  3AFFEF     BRA NZ, 0x3DA4
003DC6  370084     BRA 0x3ED0
112:                           if ((y<0) || (y>= VRES)){y++; continue;}
003D9E  B3C3F8     MOV.B #0x3F, W8
003DA4  50CF88     SUB.B W1, W8, [W15]
003DA6  3E000A     BRA GTU, 0x3DBC
113:                           sprite_row=sprite[row+1];
114:                           collision |= display_buffer[y][0] & (sprite_row<<shl);
003DA0  2186C9     MOV #0x186C, W9
003DA2  FB0000     SE W0, W0
003DA8  FB0301     SE W1, W6
003DAA  DD3344     SL W6, #4, W6
003DAC  7B43E9     MOV.B [W9+W6], W7
003DAE  784512     MOV.B [W2], W10
003DB0  FB818A     ZE W10, W3
003DB2  DD1980     SL W3, W0, W3
003DB4  61C507     AND.B W3, W7, W10
003DB6  72420A     IOR.B W4, W10, W4
115:                           display_buffer[y][0] ^= sprite_row<<shl;
003DB8  448306     ADD W9, W6, W6
003DBA  69CB07     XOR.B W3, W7, [W6]
003DBC  E94285     DEC.B W5, W5
003DBE  E84081     INC.B W1, W1
003DC0  E88102     INC2 W2, W2
116:                           y++;
117:                       }
118:                   }else if (x<0){ // x {-1..-7}
003DC8  504FE0     SUB.B W0, #0x0, [W15]
003DCA  3D002B     BRA GE, 0x3E22
119:                       shl=-x;
120:                       shr=8-shl;
003DCC  EA4600     NEG.B W0, W12
003DCE  404368     ADD.B W0, #0x8, W6
003DD0  B3C105     MOV.B #0x10, W5
121:                       for (row=0;row<32;row+=2){
003E1C  52CFE0     SUB.B W5, #0x0, [W15]
003E1E  3AFFDF     BRA NZ, 0x3DDE
003E20  370057     BRA 0x3ED0
122:                           if ((y<0) || (y>= VRES)){y++; continue;}
003DD4  B3C3FD     MOV.B #0x3F, W13
003DDE  50CF8D     SUB.B W1, W13, [W15]
003DE0  3E001A     BRA GTU, 0x3E16
123:                           sprite_row=sprite[row];
124:                           collision|=display_buffer[y][0] & (sprite_row<<shl);
003DD6  2186C0     MOV #0x186C, W0
003DD8  FB060C     SE W12, W12
003DE2  FB0301     SE W1, W6
003DE4  DD3344     SL W6, #4, W6
003DE6  7B4560     MOV.B [W0+W6], W10
003DE8  784712     MOV.B [W2], W14
003DEA  FB858E     ZE W14, W11
003DEC  DD5D8C     SL W11, W12, W11
003E06  65C50A     AND.B W11, W10, W10
003E08  77470A     IOR.B W14, W10, W14
125:                           display_buffer[y][0] ^= sprite_row<<shl;
003DEE  6DC38A     XOR.B W11, W10, W7
003DF0  400186     ADD W0, W6, W3
003DF2  784987     MOV.B W7, [W3]
126:                           sprite_row=sprite[row+1];
127:                           collision|=display_buffer[y][0] & (sprite_row>>shr);
003DDA  FB0306     SE W6, W6
003DDC  9FBF86     MOV W6, [W15-16]
003DF4  904412     MOV.B [W2+1], W8
003DF6  FB8408     ZE W8, W8
003DF8  97BF0F     MOV [W15-16], W14
003DFA  DEC48E     ASR W8, W14, W9
003E0A  64C387     AND.B W9, W7, W7
003E0C  774387     IOR.B W14, W7, W7
128:                           display_buffer[y][0] ^= sprite_row>>shr;
003DFC  6CC987     XOR.B W9, W7, [W3]
129:                           collision|=display_buffer[y][1] & (sprite_row<<shl);
003DFE  E80186     INC W6, W3
003E00  79C1E0     MOV.B [W0+W3], W3
003E02  DD440C     SL W8, W12, W8
003E04  644703     AND.B W8, W3, W14
003E0E  724207     IOR.B W4, W7, W4
130:                           display_buffer[y][1] ^= sprite_row<<shl;
003E10  2186D7     MOV #0x186D, W7
003E12  430307     ADD W6, W7, W6
003E14  6C4B03     XOR.B W8, W3, [W6]
003E16  E94285     DEC.B W5, W5
003E18  E84081     INC.B W1, W1
003E1A  E88102     INC2 W2, W2
131:                           y++;
132:                       }
133:                   }else{ // x {0..HRES-1}
134:                       shr= x&7;
003E22  6046E7     AND.B W0, #0x7, W13
135:                       shl=(8-shr)&7;
003E24  EA420D     NEG.B W13, W4
003E26  624267     AND.B W4, #0x7, W4
003E28  9FEFE4     MOV.B W4, [W15-18]
136:                       xbyte=x>>3;
003E2A  FB0000     SE W0, W0
137:                       for (row=0;row<32;row+=2){
003ECC  52CFE0     SUB.B W5, #0x0, [W15]
003ECE  3AFFBC     BRA NZ, 0x3E48
138:                           if ((y<0) || (y>=VRES)){y++; continue;}
003E32  B3C3FA     MOV.B #0x3F, W10
003E48  50CF8A     SUB.B W1, W10, [W15]
003E4A  3E003D     BRA GTU, 0x3EC6
139:                           sprite_row=sprite[row];
140:                           collision |= display_buffer[y][xbyte] & (sprite_row>>shr);
003E34  DE8043     ASR W0, #3, W0
003E36  9FBF80     MOV W0, [W15-16]
003E38  2186C6     MOV #0x186C, W6
003E3A  FB068D     SE W13, W13
003E4C  FB0381     SE W1, W7
003E4E  DD3CC4     SL W7, #4, W9
003E50  97BF0F     MOV [W15-16], W14
003E52  44848E     ADD W9, W14, W9
003E54  7CC066     MOV.B [W6+W9], W0
003E56  97FDF2     MOV.B [W2-1], W11
003E58  FB858B     ZE W11, W11
003E5A  DED98D     ASR W11, W13, W3
003E5C  61C700     AND.B W3, W0, W14
003E5E  72420E     IOR.B W4, W14, W4
141:                           display_buffer[y][xbyte] ^= sprite_row>>shr;
003E60  430489     ADD W6, W9, W9
003E62  69CC80     XOR.B W3, W0, [W9]
142:                           if ((xbyte+1)<HBYTES){
003E3C  E80600     INC W0, W12
003E64  560FEF     SUB W12, #0xF, [W15]
003E66  3C002F     BRA GT, 0x3EC6
143:                               if (shl){
003E68  97E86F     MOV.B [W15-18], W0
003E6A  504FE0     SUB.B W0, #0x0, [W15]
003E6C  320016     BRA Z, 0x3E9A
144:                                       collision |= display_buffer[y][xbyte+1] & (sprite_row<<shl);
003E3E  97EC6F     MOV.B [W15-18], W8
003E40  FB0408     SE W8, W8
003E42  9FB7D8     MOV W8, [W15-22]
003E6E  DD39C4     SL W7, #4, W3
003E70  41818C     ADD W3, W12, W3
003E72  79C4E6     MOV.B [W6+W3], W9
003E74  97B75F     MOV [W15-22], W14
003E76  DD5D8E     SL W11, W14, W11
003E8A  65C489     AND.B W11, W9, W9
003E8C  774489     IOR.B W14, W9, W9
145:                                       display_buffer[y][xbyte+1] ^= sprite_row<<shl;
003E78  6DC009     XOR.B W11, W9, W0
003E7A  430183     ADD W6, W3, W3
003E7C  784980     MOV.B W0, [W3]
146:                               }
147:                               sprite_row=sprite[row+1];
148:                               collision |= display_buffer[y][xbyte+1] & (sprite_row>>shr);
003E7E  784412     MOV.B [W2], W8
003E80  FB8408     ZE W8, W8
003E82  9FB7E8     MOV W8, [W15-20]
003E84  780708     MOV W8, W14
003E86  DEF40D     ASR W14, W13, W8
003E88  604708     AND.B W0, W8, W14
003E8E  724209     IOR.B W4, W9, W4
003E9A  DD3BC4     SL W7, #4, W7
003E9C  43838C     ADD W7, W12, W7
003E9E  7BC1E6     MOV.B [W6+W7], W3
003EA0  784412     MOV.B [W2], W8
003EA2  FB8008     ZE W8, W0
003EA4  DE800D     ASR W0, W13, W0
003EA6  61C400     AND.B W3, W0, W8
003EA8  724208     IOR.B W4, W8, W4
149:                               display_buffer[y][xbyte+1] ^= (sprite_row>>shr);
003E90  684988     XOR.B W0, W8, [W3]
003EAA  430387     ADD W6, W7, W7
003EAC  69CB80     XOR.B W3, W0, [W7]
003EAE  37000B     BRA 0x3EC6
150:                               if (shl && ((xbyte+2)<HBYTES)){
003E44  E88480     INC2 W0, W9
003E46  9FB7C9     MOV W9, [W15-24]
003E92  97B04F     MOV [W15-24], W0
003E94  500FEF     SUB W0, #0xF, [W15]
003E96  34000C     BRA LE, 0x3EB0
003E98  370016     BRA 0x3EC6
151:                                       collision |= display_buffer[y][xbyte+2] & (sprite_row<<shl);
003EB0  DD3BC4     SL W7, #4, W7
003EB2  97B44F     MOV [W15-24], W8
003EB4  438388     ADD W7, W8, W7
003EB6  7BC066     MOV.B [W6+W7], W0
003EB8  97B4EF     MOV [W15-20], W9
003EBA  97B75F     MOV [W15-22], W14
003EBC  DD498E     SL W9, W14, W3
003EBE  61C400     AND.B W3, W0, W8
003EC0  724208     IOR.B W4, W8, W4
152:                                       display_buffer[y][xbyte+2] ^=(sprite_row<<shl);
003EC2  430387     ADD W6, W7, W7
003EC4  69CB80     XOR.B W3, W0, [W7]
003EC6  E94285     DEC.B W5, W5
003EC8  E84081     INC.B W1, W1
003ECA  E88102     INC2 W2, W2
153:                               }
154:                           }
155:                           y++;
156:                       }
157:                   }
158:                   if (collision) collision=1;
159:                   return collision;
160:               }
003ED6  784004     MOV.B W4, W0
003ED8  78074F     MOV [--W15], W14
003EDA  BE064F     MOV.D [--W15], W12
003EDC  BE054F     MOV.D [--W15], W10
003EDE  BE044F     MOV.D [--W15], W8
003EE0  B100CF     SUB #0xC, W15
003EE2  060000     RETURN
161:               
162:               
163:               void cls(){
164:                   suspend_update();
003EE4  A90095     BCLR 0x95, #0
165:                   memset(display_buffer,0,VRES*HBYTES);
003EE6  2186C4     MOV #0x186C, W4
003EE8  0903FF     REPEAT #0x3FF
003EEA  EB5A00     CLR.B [W4++]
166:                   set_cursor(0,0);
003EEC  EB4080     CLR.B W1
003EEE  784001     MOV.B W1, W0
003EF0  070154     RCALL set_cursor
167:                   restart_update();
003EF2  A80095     BSET 0x95, #0
168:               }
003EF4  060000     RETURN
169:               
170:               
171:               // lines {1..31}
172:               void scroll_down(uint8_t lines){
003EF6  BE9F88     MOV.D W8, [W15++]
173:                   if (!lines) return;
003EF8  504FE0     SUB.B W0, #0x0, [W15]
003EFA  32000D     BRA Z, 0x3F16
174:                   lines &=0x1f;
175:                   memmove(&display_buffer[lines][0],&display_buffer,HBYTES*VRES-HBYTES*lines);
003EFC  6004FF     AND W0, #0x1F, W9
003EFE  200402     MOV #0x40, W2
003F00  510109     SUB W2, W9, W2
003F02  DD1144     SL W2, #4, W2
003F04  DD4CC4     SL W9, #4, W9
003F06  2186C8     MOV #0x186C, W8
003F08  448008     ADD W9, W8, W0
003F0A  780088     MOV W8, W1
003F0C  07E1E7     RCALL _memmove
176:                   memset(&display_buffer,0,HBYTES*lines);
003F0E  780109     MOV W9, W2
003F10  EB0080     CLR W1
003F12  780008     MOV W8, W0
003F14  07E1F4     RCALL _memset
177:               }
003F16  BE044F     MOV.D [--W15], W8
003F18  060000     RETURN
178:               
179:               
180:               // lines {1..31}
181:               void scroll_up(uint8_t lines){
003F1A  BE9F88     MOV.D W8, [W15++]
003F1C  781F8A     MOV W10, [W15++]
182:                   if (!lines) return;
003F1E  504FE0     SUB.B W0, #0x0, [W15]
003F20  32000E     BRA Z, 0x3F3E
183:                   lines &=0x1f;
184:                   memmove(&display_buffer,&display_buffer[lines],HBYTES*VRES-HBYTES*lines);
003F22  60057F     AND W0, #0x1F, W10
003F24  200409     MOV #0x40, W9
003F26  54848A     SUB W9, W10, W9
003F28  DD4CC4     SL W9, #4, W9
003F2A  DD5544     SL W10, #4, W10
003F2C  2186C8     MOV #0x186C, W8
003F2E  450088     ADD W10, W8, W1
003F30  780109     MOV W9, W2
003F32  780008     MOV W8, W0
003F34  07E1D3     RCALL _memmove
185:                   memset(&display_buffer[VRES-lines],0,HBYTES*lines);
003F36  448008     ADD W9, W8, W0
003F38  78010A     MOV W10, W2
003F3A  EB0080     CLR W1
003F3C  07E1E0     RCALL _memset
186:               }
003F3E  78054F     MOV [--W15], W10
003F40  BE044F     MOV.D [--W15], W8
003F42  060000     RETURN
187:               
188:               // pixels {1..8}
189:               void scroll_right(uint8_t pixels){
003F44  BE9F88     MOV.D W8, [W15++]
003F46  BE9F8A     MOV.D W10, [W15++]
003F4E  21C6CA     MOV #0x1C6C, W10
003F66  2187B3     MOV #0x187B, W3
003F6A  203F1A     MOV #0x3F1, W10
003F6C  450503     ADD W10, W3, W10
003F74  780203     MOV W3, W4
003F76  51806F     SUB W3, #0xF, W0
003F78  780283     MOV W3, W5
190:                   uint8_t line, column;
191:                   uint8_t *line_buffer;
192:               
193:                   if (pixels==8){
003F48  504FE8     SUB.B W0, #0x8, [W15]
003F4A  3A000D     BRA NZ, 0x3F66
003F4C  2186C8     MOV #0x186C, W8
194:                       for (line=0;line<VRES;line++){
003F60  540F8A     SUB W8, W10, [W15]
003F62  3AFFF8     BRA NZ, 0x3F54
003F64  37001B     BRA 0x3F9C
195:                           line_buffer=(uint8_t*)&display_buffer+HBYTES*line;
196:                           memmove(line_buffer+1,line_buffer,HBYTES-1);
003F50  2000FB     MOV #0xF, W11
003F54  E80008     INC W8, W0
003F56  78010B     MOV W11, W2
003F58  780088     MOV W8, W1
003F5A  07E1C0     RCALL _memmove
197:                           *line_buffer=0;
003F52  EB4480     CLR.B W9
003F5C  784C09     MOV.B W9, [W8]
003F5E  440470     ADD W8, #0x10, W8
198:                       }
199:                   }else{
200:                       pixels &=0x7;
003F68  2186C8     MOV #0x186C, W8
201:                       for (line=1;line<=VRES;line++){
003F98  540F8A     SUB W8, W10, [W15]
003F9A  3AFFEC     BRA NZ, 0x3F74
202:                           line_buffer=(uint8_t*)&display_buffer+HBYTES*line-1;
203:                           for (column=HBYTES-1;column;column--){
003F88  520F80     SUB W4, W0, [W15]
003F8A  3AFFF7     BRA NZ, 0x3F7A
204:                                   *line_buffer=(*line_buffer>>pixels)|(*(line_buffer-1))<<(8-pixels);
003F6E  6000E7     AND W0, #0x7, W1
003F70  108168     SUBR W1, #0x8, W2
003F72  780481     MOV W1, W9
003F7A  784314     MOV.B [W4], W6
003F7C  FB8386     ZE W6, W7
003F7E  DEBB81     ASR W7, W1, W7
003F80  7845C4     MOV.B [--W4], W11
003F82  FB830B     ZE W11, W6
003F84  DD3302     SL W6, W2, W6
003F86  73D286     IOR.B W7, W6, [W5--]
205:                                   --line_buffer;
206:                           }
207:                           *line_buffer>>=pixels;
003F8C  784298     MOV.B [W8], W5
003F8E  FB8205     ZE W5, W4
003F90  DEA209     ASR W4, W9, W4
003F92  784C04     MOV.B W4, [W8]
003F94  4181F0     ADD W3, #0x10, W3
003F96  440470     ADD W8, #0x10, W8
208:                       }
209:                   }
210:               }
003F9C  BE054F     MOV.D [--W15], W10
003F9E  BE044F     MOV.D [--W15], W8
003FA0  060000     RETURN
211:               
212:               // optimisé pour la VM chip8()
213:               // décale de 4 pixels
214:               void chip_scroll_right(){
003FA2  781F88     MOV W8, [W15++]
003FA4  2187B1     MOV #0x187B, W1
003FA6  2186C2     MOV #0x186C, W2
003FA8  203F13     MOV #0x3F1, W3
003FAA  418181     ADD W3, W1, W3
003FAC  780201     MOV W1, W4
003FAE  50806F     SUB W1, #0xF, W0
003FB0  780281     MOV W1, W5
215:                   uint8_t line, column;
216:                   uint8_t *line_buffer;
217:               
218:                   for (line=0;line<VRES;line++){
003FD0  510F83     SUB W2, W3, [W15]
003FD2  3AFFEC     BRA NZ, 0x3FAC
219:                       line_buffer=(uint8_t*)&display_buffer[line][HBYTES-1];
220:                       for (column=HBYTES-1;column;column--){
003FC0  520F80     SUB W4, W0, [W15]
003FC2  3AFFF7     BRA NZ, 0x3FB2
221:                           *line_buffer=(*line_buffer>>4)|((*(line_buffer-1))<<4);
003FB2  784314     MOV.B [W4], W6
003FB4  FB8386     ZE W6, W7
003FB6  DE3BC4     LSR W7, #4, W7
003FB8  784444     MOV.B [--W4], W8
003FBA  FB8308     ZE W8, W6
003FBC  DD3344     SL W6, #4, W6
003FBE  73D286     IOR.B W7, W6, [W5--]
222:                           --line_buffer;
223:                       }
224:                       *line_buffer>>=4;
003FC4  784292     MOV.B [W2], W5
003FC6  FB8205     ZE W5, W4
003FC8  DE2244     LSR W4, #4, W4
003FCA  784904     MOV.B W4, [W2]
003FCC  4080F0     ADD W1, #0x10, W1
003FCE  410170     ADD W2, #0x10, W2
225:                   }
226:               }
003FD4  78044F     MOV [--W15], W8
003FD6  060000     RETURN
227:               
228:               //pixels {1..8}
229:               void scroll_left(uint8_t pixels){
003FD8  BE9F88     MOV.D W8, [W15++]
003FDA  BE9F8A     MOV.D W10, [W15++]
003FE2  21C6CA     MOV #0x1C6C, W10
003FFC  41846F     ADD W3, #0xF, W8
003FFE  203F1A     MOV #0x3F1, W10
004000  450508     ADD W10, W8, W10
004008  780203     MOV W3, W4
00400A  41806F     ADD W3, #0xF, W0
00400C  780283     MOV W3, W5
230:                   uint8_t line, column;
231:                   uint8_t  *line_buffer;
232:               
233:                   if (pixels==8){
003FDC  504FE8     SUB.B W0, #0x8, [W15]
003FDE  3A000D     BRA NZ, 0x3FFA
003FE0  2186C8     MOV #0x186C, W8
234:                       for (line=0;line<VRES;line++){
003FF4  540F8A     SUB W8, W10, [W15]
003FF6  3AFFF8     BRA NZ, 0x3FE8
003FF8  37001B     BRA 0x4030
235:                           line_buffer=(uint8_t*)&display_buffer+HBYTES*line;
236:                           memmove(line_buffer,line_buffer+1,HBYTES-1);
003FE4  2000FB     MOV #0xF, W11
003FE8  E80088     INC W8, W1
003FEA  78010B     MOV W11, W2
003FEC  780008     MOV W8, W0
003FEE  07E176     RCALL _memmove
237:                           *(line_buffer+HBYTES-1)=0;
003FE6  EB4480     CLR.B W9
003FF0  984C79     MOV.B W9, [W8+15]
003FF2  440470     ADD W8, #0x10, W8
238:                       }
239:                   }else{
240:                       pixels &=0x7;
003FFA  2186C3     MOV #0x186C, W3
241:                       for (line=0;line<VRES;line++){
00402C  518F8A     SUB W3, W10, [W15]
00402E  3AFFEC     BRA NZ, 0x4008
242:                           line_buffer=(uint8_t*)&display_buffer+HBYTES*line;
243:                           for (column=0;column<(HBYTES-1);column++){
00401C  520F80     SUB W4, W0, [W15]
00401E  3AFFF7     BRA NZ, 0x400E
244:                               *line_buffer=(*line_buffer<<pixels)|(*(line_buffer+1)>>(8-pixels));
004002  6000E7     AND W0, #0x7, W1
004004  108168     SUBR W1, #0x8, W2
004006  780481     MOV W1, W9
00400E  784314     MOV.B [W4], W6
004010  FB8386     ZE W6, W7
004012  DD3B81     SL W7, W1, W7
004014  7845D4     MOV.B [++W4], W11
004016  FB830B     ZE W11, W6
004018  DEB302     ASR W6, W2, W6
00401A  73DA86     IOR.B W7, W6, [W5++]
245:                               ++line_buffer;
246:                           }
247:                           *line_buffer<<=pixels;
004020  784298     MOV.B [W8], W5
004022  FB8205     ZE W5, W4
004024  DD2209     SL W4, W9, W4
004026  784C04     MOV.B W4, [W8]
004028  4181F0     ADD W3, #0x10, W3
00402A  440470     ADD W8, #0x10, W8
248:                       }
249:                   }
250:               }
004030  BE054F     MOV.D [--W15], W10
004032  BE044F     MOV.D [--W15], W8
004034  060000     RETURN
251:               
252:               // optimisé pour la VM chip8()
253:               // décale de 4 pixels
254:               void chip_scroll_left(){
004036  BE9F88     MOV.D W8, [W15++]
004038  2186C1     MOV #0x186C, W1
00403A  40816F     ADD W1, #0xF, W2
00403C  203F18     MOV #0x3F1, W8
00403E  440402     ADD W8, W2, W8
004042  780201     MOV W1, W4
004044  40806F     ADD W1, #0xF, W0
004046  780281     MOV W1, W5
255:                   uint8_t line, column;
256:                   uint8_t  *line_buffer;
257:                   for (line=0;line<VRES;line++){
004064  508F88     SUB W1, W8, [W15]
004066  3AFFED     BRA NZ, 0x4042
258:                       line_buffer=(uint8_t*)&display_buffer[line];
259:                       for (column=0;column<(HBYTES-1);column++){
004056  520F80     SUB W4, W0, [W15]
004058  3AFFF7     BRA NZ, 0x4048
260:                           *line_buffer=(*line_buffer<<4)|((*(line_buffer+1))>>4);
004048  784314     MOV.B [W4], W6
00404A  FB8386     ZE W6, W7
00404C  DD3BC4     SL W7, #4, W7
00404E  7844D4     MOV.B [++W4], W9
004050  FB8309     ZE W9, W6
004052  DE3344     LSR W6, #4, W6
004054  73DA86     IOR.B W7, W6, [W5++]
261:                           ++line_buffer;
262:                       }
263:                       *line_buffer<<=4;
004040  200043     MOV #0x4, W3
00405A  784212     MOV.B [W2], W4
00405C  DD2203     SL W4, W3, W4
00405E  784904     MOV.B W4, [W2]
004060  4080F0     ADD W1, #0x10, W1
004062  410170     ADD W2, #0x10, W2
264:                   }
265:               }//f()
004068  BE044F     MOV.D [--W15], W8
00406A  060000     RETURN
266:               
267:               
268:               void screen_save(uint8_t* buffer){
269:                   suspend_update();
00406C  A90095     BCLR 0x95, #0
270:                   memmove(buffer,display_buffer,LCD_BUFF_SIZE);
00406E  204002     MOV #0x400, W2
004070  2186C1     MOV #0x186C, W1
004072  07E134     RCALL _memmove
271:                   restart_update();
004074  A80095     BSET 0x95, #0
272:               }//f()
004076  060000     RETURN
273:               
274:               void screen_restore(uint8_t* buffer){
275:                   suspend_update();
004078  A90095     BCLR 0x95, #0
276:                   memmove(display_buffer,buffer,LCD_BUFF_SIZE);
00407A  204002     MOV #0x400, W2
00407C  780080     MOV W0, W1
00407E  2186C0     MOV #0x186C, W0
004080  07E12D     RCALL _memmove
277:                   restart_update();
004082  A80095     BSET 0x95, #0
278:               }//f()
004084  060000     RETURN
---  C:/Users/Jacques/Documents/GitHub/PicVisionPortable/PICVisionPortable.X/chip8.c  -------------------
1:                 /*
2:                 * Copyright 2014, Jacques Deschênes
3:                 * This file is part of CHIPcon.
4:                 *
5:                 *     CHIPcon is free software: you can redistribute it and/or modify
6:                 *     it under the terms of the GNU General Public License as published by
7:                 *     the Free Software Foundation, either version 3 of the License, or
8:                 *     (at your option) any later version.
9:                 *
10:                *     CHIPcon is distributed in the hope that it will be useful,
11:                *     but WITHOUT ANY WARRANTY; without even the implied warranty of
12:                *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
13:                *     GNU General Public License for more details.
14:                *
15:                *     You should have received a copy of the GNU General Public License
16:                *     along with CHIPcon.  If not, see <http://www.gnu.org/licenses/>.
17:                */
18:                
19:                /*
20:                 * chip8.c
21:                 *
22:                 * Created: 2014-09-26 10:10:45
23:                 *  Author: Jacques Deschênes
24:                 *  Description: machine virtuelle qui exécute du byte code super CHIP
25:                 */ 
26:                
27:                // doit-être inclus avant <util/delay.h>
28:                #include <stdlib.h>
29:                #include <string.h>
30:                #include "Hardware/HardwareProfile.h"
31:                #include "chip8.h"
32:                #include "text.h"
33:                #include "tone.h"
34:                #include "keypad.h"
35:                #include "display.h"
36:                
37:                #define caddr(b1,b2) (((b1&0xf)<<8)+b2)
38:                #define rx(b1)  (b1&0xf)
39:                #define ry(b2)  ((b2&0xf0)>>4)
40:                
41:                // état de la machine virtuelle
42:                static vm_state_t vms;
43:                
44:                uint8_t chip_prog[PROG_SPACE];
45:                
46:                typedef enum sprite_src {SMALL_HEX,LARGE_HEX,PROG_MEM} sprite_src_t;
47:                
48:                // origine du sprite
49:                sprite_src_t sprite_org;
50:                
51:                // stockage temporaire sprite
52:                //static uint8_t block[32];
53:                
54:                
55:                void print_vms(const char *msg){
0030E4  BE9F88     MOV.D W8, [W15++]
0030E6  781F8A     MOV W10, [W15++]
0030E8  780400     MOV W0, W8
00312E  440570     ADD W8, #0x10, W10
56:                //	screen_save();
57:                	cls();
0030EA  0706FC     RCALL cls
58:                	select_font(FONT_ASCII);
0030EC  B3C020     MOV.B #0x2, W0
0030EE  0707CB     RCALL select_font
59:                	print(msg);
0030F0  780008     MOV W8, W0
0030F2  07085E     RCALL print
60:                	print("PC:");
0030F4  2A8CE0     MOV #0xA8CE, W0
0030F6  07085C     RCALL print
61:                	print_hex(vms.pc-2,4);
0030F8  ED9802     DEC2 vms, WREG
0030FA  B3C041     MOV.B #0x4, W1
0030FC  070883     RCALL print_hex
62:                	print_hex(vms.b1,2);
0030FE  BFD828     MOV.B 0x1828, WREG
003100  FB8000     ZE W0, W0
003102  B3C021     MOV.B #0x2, W1
003104  07087F     RCALL print_hex
63:                	print_hex(vms.b2,2);
003106  BFD829     MOV.B 0x1829, WREG
003108  FB8000     ZE W0, W0
00310A  B3C021     MOV.B #0x2, W1
00310C  07087B     RCALL print_hex
64:                	new_line();
00310E  0707BD     RCALL new_line
65:                	print("I:");
003110  2A8D20     MOV #0xA8D2, W0
003112  07084E     RCALL print
66:                	print_hex(vms.ix,4);
003114  B3C041     MOV.B #0x4, W1
003116  80C020     MOV 0x1804, W0
003118  070875     RCALL print_hex
67:                	print(" SP:");
00311A  2A8D50     MOV #0xA8D5, W0
00311C  070849     RCALL print
68:                	print_hex(vms.sp,2);
00311E  BFD806     MOV.B 0x1806, WREG
003120  FB8000     ZE W0, W0
003122  B3C021     MOV.B #0x2, W1
003124  07086F     RCALL print_hex
69:                	new_line();
003126  0707B1     RCALL new_line
70:                	print("var[]:");
003128  2A8DA0     MOV #0xA8DA, W0
00312A  070842     RCALL print
00312C  218068     MOV #0x1806, W8
71:                        int i;
72:                	for (i=0;i<16;i++){
00313A  540F8A     SUB W8, W10, [W15]
00313C  3AFFFA     BRA NZ, 0x3132
73:                		print_hex(vms.var[i],2);
003130  B3C029     MOV.B #0x2, W9
003132  784258     MOV.B [++W8], W4
003134  FB8004     ZE W4, W0
003136  784089     MOV.B W9, W1
003138  070865     RCALL print_hex
74:                	}
75:                	new_line();
00313E  0707A5     RCALL new_line
76:                /*	
77:                	prt_pstr("rpl[]:");
78:                	for (int i=0;i<16;i++){
79:                		print_hex(vms.rpl[i++],2);
80:                	}
81:                */	
82:                	print("'S' exit trace or any");
003140  2A8E10     MOV #0xA8E1, W0
003142  070836     RCALL print
83:                	if (wait_key()==SELECT) vms.trace=0;
003144  070CE5     RCALL wait_key
003146  504FE4     SUB.B W0, #0x4, [W15]
003148  3A0001     BRA NZ, 0x314C
00314A  A9386A     BCLR 0x186A, #1
84:                	while (keypad_read()!=NO_KEY);
00314C  070CC8     RCALL keypad_read
00314E  404FE1     ADD.B W0, #0x1, [W15]
003150  3AFFFD     BRA NZ, 0x314C
85:                	//screen_restore();
86:                }
003152  78054F     MOV [--W15], W10
003154  BE044F     MOV.D [--W15], W8
003156  060000     RETURN
87:                
88:                #if FW_DEBUG
89:                
90:                #define MAX_BREAK  (10)
91:                
92:                static uint16_t break_points[MAX_BREAK]={0,0,0,0,0,0,0,0,0,0};
93:                
94:                void set_break_point(uint16_t addr){
95:                	uint8_t i;
96:                	for (i=0;i<MAX_BREAK;i++)
97:                		if (!break_points[i]) break_points[i]=addr;
98:                }
99:                
100:               void clr_break_point(uint16_t addr){
101:               	uint8_t i;
102:               	for (i=0;i<MAX_BREAK;i++){ 
103:               		if (break_points[i]==addr){ 
104:               			break_points[i]=0;
105:               			break;
106:               		}
107:               	}
108:               }
109:               
110:               
111:               static uint8_t is_break_point(uint16_t addr){
112:               	uint8_t i;
113:               	for (i=0;i<MAX_BREAK;i++){
114:               		if (break_points[i]==addr){
115:               			return 1;
116:               		}
117:               	}
118:               	return 0;	
119:               }
120:               #endif
121:               
122:               #define GAME_SPEED (50)
123:               
124:               // machine virtuelle CHIPcon
125:               uint8_t schip(uint8_t flags){
003158  BE9F88     MOV.D W8, [W15++]
00315A  BE9F8A     MOV.D W10, [W15++]
00315C  BE9F8C     MOV.D W12, [W15++]
00315E  781F8E     MOV W14, [W15++]
126:                   uint8_t x,y,n;
127:                   uint16_t code;
128:               
129:                   vms.debug=0;
003160  A9186A     BCLR 0x186A, #0
130:                   vms.trace=0;
003162  A9386A     BCLR 0x186A, #1
131:                   if (flags&F_RESET){
003164  600062     AND W0, #0x2, W0
003166  320006     BRA Z, 0x3174
132:                       vms.pc=0;
003168  EB0200     CLR W4
00316A  88C014     MOV W4, vms
133:                       vms.sp=0;
00316C  FD0200     EXCH W0, W4
00316E  B7F806     MOV.B WREG, 0x1806
003170  FD0200     EXCH W0, W4
134:                       vms.ix=0;
003172  88C024     MOV W4, 0x1804
135:                   }
136:               #if FW_DEBUG
137:                   if (flags&F_DEBUG) vms.debug=1;
138:                   if (flags&F_TRACE) vms.trace=1;
139:               #endif	
140:                   while (1){
141:               #if FW_DEBUG
142:                       if (vms.debug && keypad_break()){
143:                               vms.trace^=1;
144:                       }
145:               #else		
146:                       if (keypad_break()) return CHIP_EXIT_OK;
00317E  070CEB     RCALL keypad_break
003180  504FE0     SUB.B W0, #0x0, [W15]
003182  3A02C5     BRA NZ, 0x370E
00370E  B3C010     MOV.B #0x1, W0
003710  370001     BRA 0x3714
147:               #endif
148:                       vms.b1=chip_prog[vms.pc];
003184  80C015     MOV vms, W5
003186  208004     MOV #0x800, W4
003188  7AC464     MOV.B [W4+W5], W8
00318A  FD0400     EXCH W0, W8
00318C  B7F828     MOV.B WREG, 0x1828
00318E  FD0400     EXCH W0, W8
149:                       vms.pc++;
003190  E80285     INC W5, W5
150:                       vms.b2=chip_prog[vms.pc];
003192  7AC164     MOV.B [W4+W5], W2
003194  FD0100     EXCH W0, W2
003196  B7F829     MOV.B WREG, 0x1829
003198  FD0100     EXCH W0, W2
151:                       vms.pc++;
00319A  E80285     INC W5, W5
00319C  88C015     MOV W5, vms
152:               #if FW_DEBUG		
153:                       if (vms.trace || (vms.debug && is_break_point(vms.pc-2))){
154:                               vms.trace=1;
155:                               print_vms("Trace print\n");
156:                       }
157:               #endif		
158:                       x=rx(vms.b1);
0031E2  64446F     AND.B W8, #0xF, W8
159:                       y=ry(vms.b2);
0031E4  FB8582     ZE W2, W11
0031E6  DE5DC4     LSR W11, #4, W11
160:                       // décodeur d'instruction
161:                       code=(vms.b1&0xf0)<<4;
00319E  FB8208     ZE W8, W4
0031A0  780304     MOV W4, W6
0031A2  B20F06     AND #0xF0, W6
0031A4  DD3344     SL W6, #4, W6
162:                       switch (code){
003174  209009     MOV #0x900, W9
0031A6  530F89     SUB W6, W9, [W15]
0031A8  320019     BRA Z, 0x31DC
0031AA  3E0006     BRA GTU, 0x31B8
0031AC  530FE0     SUB W6, #0x0, [W15]
0031AE  32000B     BRA Z, 0x31C6
0031B0  208007     MOV #0x800, W7
0031B2  530F87     SUB W6, W7, [W15]
0031B4  3A0016     BRA NZ, 0x31E2
0031B6  370012     BRA 0x31DC
0031B8  20E007     MOV #0xE00, W7
0031BA  530F87     SUB W6, W7, [W15]
0031BC  32000B     BRA Z, 0x31D4
0031BE  B01007     ADD #0x100, W7
0031C0  530F87     SUB W6, W7, [W15]
0031C2  3A000F     BRA NZ, 0x31E2
0031C4  370007     BRA 0x31D4
163:                       case 0x000:
164:                           if ((vms.b2&0xf0)==0xc0) code=0xc0; else code=vms.b2;
0031C6  780382     MOV W2, W7
0031C8  B20F07     AND #0xF0, W7
0031CA  200C06     MOV #0xC0, W6
0031CC  538F86     SUB W7, W6, [W15]
0031CE  3200AF     BRA Z, 0x332E
0031D0  FB8302     ZE W2, W6
0031D2  370007     BRA 0x31E2
165:                           break;
166:                       case 0xe00:
167:                       case 0xf00:
168:                           code |= vms.b2;
0031D4  FB8382     ZE W2, W7
0031D6  738386     IOR W7, W6, W7
0031D8  780307     MOV W7, W6
169:                           break;
0031DA  370003     BRA 0x31E2
170:                       case 0x800:
171:                       case 0x900:
172:                           code |= vms.b2&0xf;
0031DC  6103EF     AND W2, #0xF, W7
0031DE  738386     IOR W7, W6, W7
0031E0  780307     MOV W7, W6
173:                           break;
174:                       }
175:                       // exécution de l'instruction
176:                       switch(code){
003176  2080EA     MOV #0x80E, W10
00317A  20F07C     MOV #0xF07, W12
00317C  20F30E     MOV #0xF30, W14
0031E8  530F8A     SUB W6, W10, [W15]
0031EA  320164     BRA Z, 0x34B4
0031EC  3E004D     BRA GTU, 0x3288
0031EE  204007     MOV #0x400, W7
0031F0  530F87     SUB W6, W7, [W15]
0031F2  3200CF     BRA Z, 0x3392
0031F4  3E0021     BRA GTU, 0x3238
0031F6  200FD7     MOV #0xFD, W7
0031F8  530F87     SUB W6, W7, [W15]
0031FA  320097     BRA Z, 0x332A
0031FC  3E0012     BRA GTU, 0x3222
0031FE  200EE4     MOV #0xEE, W4
003200  530F84     SUB W6, W4, [W15]
003202  32009A     BRA Z, 0x3338
003204  3E0007     BRA GTU, 0x3214
003206  200C04     MOV #0xC0, W4
003208  530F84     SUB W6, W4, [W15]
00320A  320091     BRA Z, 0x332E
00320C  200E04     MOV #0xE0, W4
00320E  530F84     SUB W6, W4, [W15]
003210  3A0280     BRA NZ, 0x3712
003212  370090     BRA 0x3334
003214  200FB4     MOV #0xFB, W4
003216  530F84     SUB W6, W4, [W15]
003218  32009C     BRA Z, 0x3352
00321A  E80204     INC W4, W4
00321C  530F84     SUB W6, W4, [W15]
00321E  3A0279     BRA NZ, 0x3712
003220  37009A     BRA 0x3356
003222  201007     MOV #0x100, W7
003224  530F87     SUB W6, W7, [W15]
003226  320099     BRA Z, 0x335A
003228  39FFAA     BRA NC, 0x317E
00322A  202007     MOV #0x200, W7
00322C  530F87     SUB W6, W7, [W15]
00322E  32009B     BRA Z, 0x3366
003230  203004     MOV #0x300, W4
003232  530F84     SUB W6, W4, [W15]
003234  3A026E     BRA NZ, 0x3712
003236  3700A4     BRA 0x3380
003238  208024     MOV #0x802, W4
00323A  530F84     SUB W6, W4, [W15]
00323C  3200DE     BRA Z, 0x33FA
00323E  3E0012     BRA GTU, 0x3264
003240  B11024     SUB #0x102, W4
003242  530F84     SUB W6, W4, [W15]
003244  3200BF     BRA Z, 0x33C4
003246  3E0007     BRA GTU, 0x3256
003248  B12004     SUB #0x200, W4
00324A  530F84     SUB W6, W4, [W15]
00324C  3200AB     BRA Z, 0x33A4
00324E  B01004     ADD #0x100, W4
003250  530F84     SUB W6, W4, [W15]
003252  3A025F     BRA NZ, 0x3712
003254  3700B3     BRA 0x33BC
003256  208004     MOV #0x800, W4
003258  530F84     SUB W6, W4, [W15]
00325A  3200BC     BRA Z, 0x33D4
00325C  E80204     INC W4, W4
00325E  530F84     SUB W6, W4, [W15]
003260  3A0258     BRA NZ, 0x3712
003262  3700C0     BRA 0x33E4
003264  208054     MOV #0x805, W4
003266  530F84     SUB W6, W4, [W15]
003268  3200F4     BRA Z, 0x3452
00326A  3E0007     BRA GTU, 0x327A
00326C  E98204     DEC2 W4, W4
00326E  530F84     SUB W6, W4, [W15]
003270  3200CF     BRA Z, 0x3410
003272  E80204     INC W4, W4
003274  530F84     SUB W6, W4, [W15]
003276  3A024D     BRA NZ, 0x3712
003278  3700D6     BRA 0x3426
00327A  208064     MOV #0x806, W4
00327C  530F84     SUB W6, W4, [W15]
00327E  3200FB     BRA Z, 0x3476
003280  E80204     INC W4, W4
003282  530F84     SUB W6, W4, [W15]
003284  3A0246     BRA NZ, 0x3712
003286  370104     BRA 0x3490
003288  530F8C     SUB W6, W12, [W15]
00328A  3201D3     BRA Z, 0x3632
00328C  3E0027     BRA GTU, 0x32DC
00328E  20A007     MOV #0xA00, W7
003290  530F87     SUB W6, W7, [W15]
003292  320165     BRA Z, 0x355E
003294  3E0011     BRA GTU, 0x32B8
003296  209024     MOV #0x902, W4
003298  530F84     SUB W6, W4, [W15]
00329A  320131     BRA Z, 0x34FE
00329C  3E0006     BRA GTU, 0x32AA
00329E  530F89     SUB W6, W9, [W15]
0032A0  320116     BRA Z, 0x34CE
0032A2  E90204     DEC W4, W4
0032A4  530F84     SUB W6, W4, [W15]
0032A6  3A0235     BRA NZ, 0x3712
0032A8  37011E     BRA 0x34E6
0032AA  209034     MOV #0x903, W4
0032AC  530F84     SUB W6, W4, [W15]
0032AE  320141     BRA Z, 0x3532
0032B0  E88204     INC2 W4, W4
0032B2  530F84     SUB W6, W4, [W15]
0032B4  3A022E     BRA NZ, 0x3712
0032B6  370147     BRA 0x3546
0032B8  20D005     MOV #0xD00, W5
0032BA  530F85     SUB W6, W5, [W15]
0032BC  32016A     BRA Z, 0x3592
0032BE  3E0007     BRA GTU, 0x32CE
0032C0  B12005     SUB #0x200, W5
0032C2  530F85     SUB W6, W5, [W15]
0032C4  320154     BRA Z, 0x356E
0032C6  20C004     MOV #0xC00, W4
0032C8  530F84     SUB W6, W4, [W15]
0032CA  3A0223     BRA NZ, 0x3712
0032CC  37015A     BRA 0x3582
0032CE  20E9E4     MOV #0xE9E, W4
0032D0  530F84     SUB W6, W4, [W15]
0032D2  32019D     BRA Z, 0x360E
0032D4  420263     ADD W4, #0x3, W4
0032D6  530F84     SUB W6, W4, [W15]
0032D8  3A021C     BRA NZ, 0x3712
0032DA  3701A2     BRA 0x3620
0032DC  530F8E     SUB W6, W14, [W15]
0032DE  3201D5     BRA Z, 0x368A
0032E0  3E0012     BRA GTU, 0x3306
0032E2  20F184     MOV #0xF18, W4
0032E4  530F84     SUB W6, W4, [W15]
0032E6  3201B8     BRA Z, 0x3658
0032E8  3E0007     BRA GTU, 0x32F8
0032EA  52026E     SUB W4, #0xE, W4
0032EC  530F84     SUB W6, W4, [W15]
0032EE  3201A7     BRA Z, 0x363E
0032F0  42026B     ADD W4, #0xB, W4
0032F2  530F84     SUB W6, W4, [W15]
0032F4  3A020E     BRA NZ, 0x3712
0032F6  3701A8     BRA 0x3648
0032F8  20F1E4     MOV #0xF1E, W4
0032FA  530F84     SUB W6, W4, [W15]
0032FC  3201B6     BRA Z, 0x366A
0032FE  42026B     ADD W4, #0xB, W4
003300  530F84     SUB W6, W4, [W15]
003302  3A0207     BRA NZ, 0x3712
003304  3701B9     BRA 0x3678
003306  20F654     MOV #0xF65, W4
003308  530F84     SUB W6, W4, [W15]
00330A  3201E2     BRA Z, 0x36D0
00330C  3E0007     BRA GTU, 0x331C
00330E  B10324     SUB #0x32, W4
003310  530F84     SUB W6, W4, [W15]
003312  3201C5     BRA Z, 0x369E
003314  B00224     ADD #0x22, W4
003316  530F84     SUB W6, W4, [W15]
003318  3A01FC     BRA NZ, 0x3712
00331A  3701D3     BRA 0x36C2
00331C  20F754     MOV #0xF75, W4
00331E  530F84     SUB W6, W4, [W15]
003320  3201DF     BRA Z, 0x36E0
003322  420270     ADD W4, #0x10, W4
003324  530F84     SUB W6, W4, [W15]
003326  3A01F5     BRA NZ, 0x3712
003328  3701E7     BRA 0x36F8
0036E0  EB4200     CLR.B W4
0036F8  EB4200     CLR.B W4
177:                       case 0xc0: // 00CN, (mode schip seulement) glisse l'affichage N lignes vers le bas
178:                           scroll_down(vms.b2&0xf);
00332E  61406F     AND.B W2, #0xF, W0
003330  0705E2     RCALL scroll_down
179:                           break;
003332  37FF25     BRA 0x317E
180:                       case 0xe0: // 00E0, efface l'écran
181:                           cls();
003334  0705D7     RCALL cls
182:                           break;
003336  37FF23     BRA 0x317E
183:                       case 0xee: // 00EE, sortie de sous-routine
184:                           vms.pc=vms.stack[vms.sp--];
003338  218064     MOV #0x1806, W4
00333A  784214     MOV.B [W4], W4
00333C  FB8284     ZE W4, W5
00333E  4282F4     ADD W5, #0x14, W5
003340  428285     ADD W5, W5, W5
003342  218026     MOV #0x1802, W6
003344  7A8366     MOV [W6+W5], W6
003346  88C016     MOV W6, vms
003348  E94204     DEC.B W4, W4
00334A  FD0200     EXCH W0, W4
00334C  B7F806     MOV.B WREG, 0x1806
00334E  FD0200     EXCH W0, W4
185:                           break;
003350  37FF16     BRA 0x317E
186:                       case 0xfb: // 00FB, (mode schip seulement) glisse l'affichage vers la droite de 4 pixels
187:                           chip_scroll_right();
003352  070627     RCALL chip_scroll_right
188:                           break;
003354  37FF14     BRA 0x317E
189:                       case 0xfc: // 00FC, (mode schip seulement) glisse l'affichage vers la gauche de 4 pixels
190:                           chip_scroll_left();
003356  07066F     RCALL chip_scroll_left
191:                           break;
003358  37FF12     BRA 0x317E
192:                       case 0xfd:// 00FD, (mode schip seulement) sortie de l'interpréteur.
193:                           return CHIP_EXIT_OK;
00332A  B3C010     MOV.B #0x1, W0
00332C  3701F3     BRA 0x3714
194:                       case 0xfe: //00FE, (mode schip seulement) revient au vms.mode par défaut chip-8 résolution 64x32
195:                           break; // ignore ce code
196:                       case 0xff:  //00FF, (mode schip seulement) passe en vms.mode schip résolution 128x64
197:                           break; // ignore ce code
198:                       case 0x100: // 1NNN saut vers l'adresse NNN
199:                           vms.pc=caddr(vms.b1,vms.b2);
00335A  62026F     AND W4, #0xF, W4
00335C  DD2248     SL W4, #8, W4
00335E  FB8102     ZE W2, W2
003360  420102     ADD W4, W2, W2
003362  88C012     MOV W2, vms
200:                           break;
003364  37FF0C     BRA 0x317E
201:                       case 0x200: // 2NNN  appelle la sous-routine à l'adresse NNN
202:                           vms.stack[++vms.sp]=vms.pc;
003366  EC5806     INC.B 0x1806, WREG
003368  B7F806     MOV.B WREG, 0x1806
00336A  FB8300     ZE W0, W6
00336C  430374     ADD W6, #0x14, W6
00336E  430306     ADD W6, W6, W6
003370  218027     MOV #0x1802, W7
003372  7B3385     MOV W5, [W7+W6]
203:                           vms.pc=caddr(vms.b1,vms.b2);
003374  62026F     AND W4, #0xF, W4
003376  DD2248     SL W4, #8, W4
003378  FB8102     ZE W2, W2
00337A  420102     ADD W4, W2, W2
00337C  88C012     MOV W2, vms
204:                           break;
00337E  37FEFF     BRA 0x317E
205:                       case 0x300: // 3XKK   saute l'instruction suivante si VX == KK
206:                           if (vms.var[x]==vms.b2) vms.pc+=2;
003380  FB8408     ZE W8, W8
003382  218064     MOV #0x1806, W4
003384  440404     ADD W8, W4, W8
003386  904218     MOV.B [W8+1], W4
003388  514F84     SUB.B W2, W4, [W15]
00338A  3AFEF9     BRA NZ, 0x317E
00338C  E88285     INC2 W5, W5
00338E  88C015     MOV W5, vms
003390  37FEF6     BRA 0x317E
207:                           break;
208:                       case 0x400: // 4XKK  Saute l'instruction suivante si VX <> KK
209:                           if (vms.var[x]!=vms.b2)vms.pc+=2;
003392  FB8408     ZE W8, W8
003394  218064     MOV #0x1806, W4
003396  440404     ADD W8, W4, W8
003398  904218     MOV.B [W8+1], W4
00339A  514F84     SUB.B W2, W4, [W15]
00339C  32FEF0     BRA Z, 0x317E
00339E  E88285     INC2 W5, W5
0033A0  88C015     MOV W5, vms
0033A2  37FEED     BRA 0x317E
210:                           break;
211:                       case 0x500: // 5XY0     Saute l'instruction suivante si VX == VY
212:                           if (vms.var[x]==vms.var[y]) vms.pc+=2;
0033A4  FB8408     ZE W8, W8
0033A6  218024     MOV #0x1802, W4
0033A8  420408     ADD W4, W8, W8
0033AA  FB858B     ZE W11, W11
0033AC  42020B     ADD W4, W11, W4
0033AE  904358     MOV.B [W8+5], W6
0033B0  904254     MOV.B [W4+5], W4
0033B2  534F84     SUB.B W6, W4, [W15]
0033B4  3AFEE4     BRA NZ, 0x317E
0033B6  E88285     INC2 W5, W5
0033B8  88C015     MOV W5, vms
0033BA  37FEE1     BRA 0x317E
213:                           break;
214:                       case 0x600: // 6XKK     VX := KK
215:                           vms.var[x]=vms.b2;
0033BC  FB8408     ZE W8, W8
0033BE  468408     ADD W13, W8, W8
0033C0  984412     MOV.B W2, [W8+1]
216:                           break;
0033C2  37FEDD     BRA 0x317E
217:                       case 0x700: // 7XKK     VX := VX + KK
218:                           vms.var[x]+=vms.b2;
0033C4  FB8408     ZE W8, W8
0033C6  468208     ADD W13, W8, W4
0033C8  218065     MOV #0x1806, W5
0033CA  440405     ADD W8, W5, W8
0033CC  904298     MOV.B [W8+1], W5
0033CE  42C102     ADD.B W5, W2, W2
0033D0  984212     MOV.B W2, [W4+1]
219:                           break;
0033D2  37FED5     BRA 0x317E
220:                       case 0x800: // 8XY0     VX := VY
221:                           vms.var[x]=vms.var[y];
0033D4  FB8408     ZE W8, W8
0033D6  468408     ADD W13, W8, W8
0033D8  FB858B     ZE W11, W11
0033DA  218064     MOV #0x1806, W4
0033DC  458584     ADD W11, W4, W11
0033DE  90459B     MOV.B [W11+1], W11
0033E0  98441B     MOV.B W11, [W8+1]
222:                           break;
0033E2  37FECD     BRA 0x317E
223:                       case 0x801: // 8XY1     VX := VX OR VY
224:                           vms.var[x]|=vms.var[y];
0033E4  FB8408     ZE W8, W8
0033E6  468288     ADD W13, W8, W5
0033E8  FB858B     ZE W11, W11
0033EA  218024     MOV #0x1802, W4
0033EC  42058B     ADD W4, W11, W11
0033EE  420408     ADD W4, W8, W8
0033F0  90435B     MOV.B [W11+5], W6
0033F2  904258     MOV.B [W8+5], W4
0033F4  734204     IOR.B W6, W4, W4
0033F6  984294     MOV.B W4, [W5+1]
225:                           break;
0033F8  37FEC2     BRA 0x317E
226:                       case 0x802: // 8XY2     VX := VX AND VY
227:                           vms.var[x]&=vms.var[y];
0033FA  FB8408     ZE W8, W8
0033FC  468288     ADD W13, W8, W5
0033FE  FB858B     ZE W11, W11
003400  218024     MOV #0x1802, W4
003402  42058B     ADD W4, W11, W11
003404  420408     ADD W4, W8, W8
003406  90435B     MOV.B [W11+5], W6
003408  904258     MOV.B [W8+5], W4
00340A  634204     AND.B W6, W4, W4
00340C  984294     MOV.B W4, [W5+1]
228:                           break;
00340E  37FEB7     BRA 0x317E
229:                       case 0x803: // 8XY3     VX := VX XOR VY
230:                           vms.var[x]^=vms.var[y];
003410  FB8408     ZE W8, W8
003412  468288     ADD W13, W8, W5
003414  FB858B     ZE W11, W11
003416  218024     MOV #0x1802, W4
003418  42058B     ADD W4, W11, W11
00341A  420408     ADD W4, W8, W8
00341C  90435B     MOV.B [W11+5], W6
00341E  904258     MOV.B [W8+5], W4
003420  6B4204     XOR.B W6, W4, W4
003422  984294     MOV.B W4, [W5+1]
231:                           break;
003424  37FEAC     BRA 0x317E
232:                       case 0x804: // 8XY4     VX := VX + VY, VF := carry
233:                           n=(vms.var[x]+vms.var[y])>255;
003426  FB8408     ZE W8, W8
003428  218025     MOV #0x1802, W5
00342A  428208     ADD W5, W8, W4
00342C  904254     MOV.B [W4+5], W4
00342E  FB858B     ZE W11, W11
003430  42828B     ADD W5, W11, W5
003432  9042D5     MOV.B [W5+5], W5
00343A  FB8285     ZE W5, W5
00343C  FB8204     ZE W4, W4
00343E  428204     ADD W5, W4, W4
003440  B3C016     MOV.B #0x1, W6
003442  200FF7     MOV #0xFF, W7
003444  520F87     SUB W4, W7, [W15]
003446  3C0001     BRA GT, 0x344A
003448  EB4300     CLR.B W6
234:                           vms.var[x]+=vms.var[y];
003434  468408     ADD W13, W8, W8
003436  42C304     ADD.B W5, W4, W6
003438  984416     MOV.B W6, [W8+1]
235:                           vms.var[15]=n;
00344A  FD0300     EXCH W0, W6
00344C  B7F816     MOV.B WREG, 0x1816
00344E  FD0300     EXCH W0, W6
236:                           break;
003450  37FE96     BRA 0x317E
237:                       case 0x805: // 8XY5     VX := VX - VY, VF := not borrow
238:                           n=vms.var[x]>=vms.var[y];
003452  FB8408     ZE W8, W8
003454  218024     MOV #0x1802, W4
003456  420288     ADD W4, W8, W5
003458  9042D5     MOV.B [W5+5], W5
00345A  FB858B     ZE W11, W11
00345C  42020B     ADD W4, W11, W4
00345E  904254     MOV.B [W4+5], W4
003466  B3C016     MOV.B #0x1, W6
003468  52CF84     SUB.B W5, W4, [W15]
00346A  310001     BRA C, 0x346E
00346C  EB4300     CLR.B W6
239:                           vms.var[x]-=vms.var[y];
003460  468408     ADD W13, W8, W8
003462  52C304     SUB.B W5, W4, W6
003464  984416     MOV.B W6, [W8+1]
240:                           vms.var[15]=n;
00346E  FD0300     EXCH W0, W6
003470  B7F816     MOV.B WREG, 0x1816
003472  FD0300     EXCH W0, W6
241:                           break;
003474  37FE84     BRA 0x317E
242:                       case 0x806: // 8XY6     VX := VX shr 1, VF := carry
243:                           n=(vms.var[x]&1u);
003476  FB8408     ZE W8, W8
003478  218064     MOV #0x1806, W4
00347A  440204     ADD W8, W4, W4
00347C  904214     MOV.B [W4+1], W4
003486  624261     AND.B W4, #0x1, W4
244:                           vms.var[x]>>=1;
00347E  468408     ADD W13, W8, W8
003480  FB8284     ZE W4, W5
003482  D10285     LSR W5, W5
003484  984415     MOV.B W5, [W8+1]
245:                           vms.var[15]=n;
003488  FD0200     EXCH W0, W4
00348A  B7F816     MOV.B WREG, 0x1816
00348C  FD0200     EXCH W0, W4
246:                           break;
00348E  37FE77     BRA 0x317E
247:                       case 0x807: // 8XY7     VX := VY - VX, VF := not borrow
248:                           n=vms.var[y]>=vms.var[x];
003490  FB858B     ZE W11, W11
003492  218024     MOV #0x1802, W4
003494  42058B     ADD W4, W11, W11
003496  9042DB     MOV.B [W11+5], W5
003498  FB8408     ZE W8, W8
00349A  420208     ADD W4, W8, W4
00349C  904254     MOV.B [W4+5], W4
0034A4  B3C016     MOV.B #0x1, W6
0034A6  52CF84     SUB.B W5, W4, [W15]
0034A8  310001     BRA C, 0x34AC
0034AA  EB4300     CLR.B W6
249:                           vms.var[x]=vms.var[y]-vms.var[x];
00349E  468408     ADD W13, W8, W8
0034A0  52C304     SUB.B W5, W4, W6
0034A2  984416     MOV.B W6, [W8+1]
250:                           vms.var[15]=n;
0034AC  FD0300     EXCH W0, W6
0034AE  B7F816     MOV.B WREG, 0x1816
0034B0  FD0300     EXCH W0, W6
251:                           break;
0034B2  37FE65     BRA 0x317E
252:                       case 0x80e: // 8XYE     VX := VX shl 1, VF := carry
253:                           n=(vms.var[x]&128)>>7;
0034B4  FB8408     ZE W8, W8
0034B6  218064     MOV #0x1806, W4
0034B8  440204     ADD W8, W4, W4
0034BA  904214     MOV.B [W4+1], W4
0034C2  FB8204     ZE W4, W4
0034C4  DE2247     LSR W4, #7, W4
254:                           vms.var[x]<<=1;
003178  21806D     MOV #0x1806, W13
0034BC  468408     ADD W13, W8, W8
0034BE  424284     ADD.B W4, W4, W5
0034C0  984415     MOV.B W5, [W8+1]
255:                           vms.var[15]=n;
0034C6  FD0200     EXCH W0, W4
0034C8  B7F816     MOV.B WREG, 0x1816
0034CA  FD0200     EXCH W0, W4
256:                           break;
0034CC  37FE58     BRA 0x317E
257:                       case 0x900: // 9XY0     Saute l'instruction suivante si VX <> VY
258:                           if (vms.var[x]!=vms.var[y]) vms.pc+=2;
0034CE  FB8408     ZE W8, W8
0034D0  218024     MOV #0x1802, W4
0034D2  420408     ADD W4, W8, W8
0034D4  FB858B     ZE W11, W11
0034D6  42020B     ADD W4, W11, W4
0034D8  904358     MOV.B [W8+5], W6
0034DA  904254     MOV.B [W4+5], W4
0034DC  534F84     SUB.B W6, W4, [W15]
0034DE  32FE4F     BRA Z, 0x317E
0034E0  E88285     INC2 W5, W5
0034E2  88C015     MOV W5, vms
0034E4  37FE4C     BRA 0x317E
259:                           break;
260:                       case 0x901: // 9XY1  TONE VX, VY  joue une note de la gamme tempérée.
261:                           key_tone(vms.var[x],vms.var[y]<<4,false);
0034E6  FB858B     ZE W11, W11
0034E8  218024     MOV #0x1802, W4
0034EA  42058B     ADD W4, W11, W11
0034EC  9040DB     MOV.B [W11+5], W1
0034EE  FB8081     ZE W1, W1
0034F0  DD08C4     SL W1, #4, W1
0034F2  FB8408     ZE W8, W8
0034F4  420208     ADD W4, W8, W4
0034F6  904054     MOV.B [W4+5], W0
0034F8  EB4100     CLR.B W2
0034FA  070AC9     RCALL key_tone
262:                           break;
0034FC  37FE40     BRA 0x317E
263:                       case 0x902: // 9XY2  PRT VX, VY  imprime le texte pointé par I. I est incrémenté.
264:                           select_font(FONT_ASCII);
0034FE  B3C020     MOV.B #0x2, W0
003500  0705C2     RCALL select_font
265:                           set_cursor(vms.var[x],vms.var[y]);
003502  FB858B     ZE W11, W11
003504  218024     MOV #0x1802, W4
003506  42058B     ADD W4, W11, W11
003508  9040DB     MOV.B [W11+5], W1
00350A  FB8408     ZE W8, W8
00350C  420208     ADD W4, W8, W4
00350E  904054     MOV.B [W4+5], W0
003510  070644     RCALL set_cursor
266:                           n=chip_prog[vms.ix++];
003512  80C024     MOV 0x1804, W4
003514  208005     MOV #0x800, W5
003516  7A4065     MOV.B [W5+W4], W0
003518  E80204     INC W4, W4
00351A  88C024     MOV W4, 0x1804
267:                           while (n){
00351C  504FE0     SUB.B W0, #0x0, [W15]
00351E  32FE2F     BRA Z, 0x317E
00352C  504FE0     SUB.B W0, #0x0, [W15]
00352E  3AFFF8     BRA NZ, 0x3520
003530  37FE26     BRA 0x317E
268:                               put_char(n);
003520  0705EA     RCALL put_char
269:                               n=chip_prog[vms.ix++];
003522  80C024     MOV 0x1804, W4
003524  208005     MOV #0x800, W5
003526  7A4065     MOV.B [W5+W4], W0
003528  E80204     INC W4, W4
00352A  88C024     MOV W4, 0x1804
270:                           }
271:                           break;
272:                       case 0x903: // 9XY3 PIXI VX, VY  inverse le pixel aux coordonnées indiquées par VX,VY
273:                           plot(vms.var[x],vms.var[y],INVERT);
003532  FB858B     ZE W11, W11
003534  218024     MOV #0x1802, W4
003536  42058B     ADD W4, W11, W11
003538  9040DB     MOV.B [W11+5], W1
00353A  FB8408     ZE W8, W8
00353C  420208     ADD W4, W8, W4
00353E  904054     MOV.B [W4+5], W0
003540  200022     MOV #0x2, W2
003542  070363     RCALL plot
274:                           break;
003544  37FE1C     BRA 0x317E
275:                       case 0x905: // 9XY5 TONE VX, VY, WAIT  joue une note de la gamme tempérée attend la fin avant de poursuivre
276:                           key_tone(vms.var[x],vms.var[y]<<4,true);
003546  FB858B     ZE W11, W11
003548  218024     MOV #0x1802, W4
00354A  42058B     ADD W4, W11, W11
00354C  9040DB     MOV.B [W11+5], W1
00354E  FB8081     ZE W1, W1
003550  DD08C4     SL W1, #4, W1
003552  FB8408     ZE W8, W8
003554  420208     ADD W4, W8, W4
003556  904054     MOV.B [W4+5], W0
003558  B3C012     MOV.B #0x1, W2
00355A  070A99     RCALL key_tone
277:                           break;
00355C  37FE10     BRA 0x317E
278:                       case 0xa00: // ANNN     I := NNN
279:                           vms.ix=caddr(vms.b1,vms.b2);  // adressse de 12 bits
00355E  62026F     AND W4, #0xF, W4
003560  DD2248     SL W4, #8, W4
003562  FB8102     ZE W2, W2
003564  420102     ADD W4, W2, W2
003566  88C022     MOV W2, 0x1804
280:                           sprite_org=PROG_MEM;
003568  200024     MOV #0x2, W4
00356A  88C004     MOV W4, sprite_org
281:                           break;
00356C  37FE08     BRA 0x317E
282:                       case 0xb00: // BNNN     saut à NNN+V0
283:                           vms.pc=vms.var[0]+caddr(vms.b1,vms.b2);
00356E  FB8102     ZE W2, W2
003570  218075     MOV #0x1807, W5
003572  784295     MOV.B [W5], W5
003574  FB8285     ZE W5, W5
003576  410105     ADD W2, W5, W2
003578  62026F     AND W4, #0xF, W4
00357A  DD2248     SL W4, #8, W4
00357C  410204     ADD W2, W4, W4
00357E  88C014     MOV W4, vms
284:                           break;
003580  37FDFE     BRA 0x317E
285:                       case 0xc00: //CXKK VX=random_number&KK
286:                           vms.var[x]=rand()&vms.b2;
003582  07E6CB     RCALL _rand
003584  FB8408     ZE W8, W8
003586  468408     ADD W13, W8, W8
003588  218294     MOV #0x1829, W4
00358A  784214     MOV.B [W4], W4
00358C  624200     AND.B W4, W0, W4
00358E  984414     MOV.B W4, [W8+1]
287:                           break;
003590  37FDF6     BRA 0x317E
288:                       case 0xd00: //DXYN dessine un sprite
289:                           n=vms.b2&0xf;
003592  61416F     AND.B W2, #0xF, W2
290:                           switch(sprite_org){
003594  80C004     MOV sprite_org, W4
003596  520FE1     SUB W4, #0x1, [W15]
003598  320011     BRA Z, 0x35BC
00359A  390003     BRA NC, 0x35A2
00359C  520FE2     SUB W4, #0x2, [W15]
00359E  3AFDEF     BRA NZ, 0x317E
0035A0  37001A     BRA 0x35D6
291:                           case SMALL_HEX:
292:                               vms.var[15]=put_sprite((int8_t)vms.var[x],(int8_t)vms.var[y],n,(const uint8_t*)&font_hex_4x6[vms.ix]);
0035A2  29BBA0     MOV #0x9BBA, W0
0035A4  B41804     ADD 0x1804, WREG
0035A6  780180     MOV W0, W3
0035A8  FB828B     ZE W11, W5
0035AA  218024     MOV #0x1802, W4
0035AC  420285     ADD W4, W5, W5
0035AE  9040D5     MOV.B [W5+5], W1
0035B0  FB8408     ZE W8, W8
0035B2  420208     ADD W4, W8, W4
0035B4  904054     MOV.B [W4+5], W0
0035B6  070363     RCALL put_sprite
0035B8  B7F816     MOV.B WREG, 0x1816
293:                               break;
0035BA  37FDE1     BRA 0x317E
294:                           case LARGE_HEX:
295:                               vms.var[15]=put_sprite((int8_t)vms.var[x],(int8_t)vms.var[y],n,(const uint8_t*)&font_hex_8x10[vms.ix]);
0035BC  29C1A0     MOV #0x9C1A, W0
0035BE  B41804     ADD 0x1804, WREG
0035C0  780180     MOV W0, W3
0035C2  FB828B     ZE W11, W5
0035C4  218024     MOV #0x1802, W4
0035C6  420285     ADD W4, W5, W5
0035C8  9040D5     MOV.B [W5+5], W1
0035CA  FB8408     ZE W8, W8
0035CC  420208     ADD W4, W8, W4
0035CE  904054     MOV.B [W4+5], W0
0035D0  070356     RCALL put_sprite
0035D2  B7F816     MOV.B WREG, 0x1816
296:                               break;
0035D4  37FDD4     BRA 0x317E
297:                           case PROG_MEM:
298:                               if (!n){
0035D6  514FE0     SUB.B W2, #0x0, [W15]
0035D8  3A000D     BRA NZ, 0x35F4
299:                                   vms.var[15]=put_big_sprite((int8_t)vms.var[x],(int8_t)vms.var[y],(const uint8_t*)&chip_prog[vms.ix]);
0035DA  208000     MOV #0x800, W0
0035DC  B41804     ADD 0x1804, WREG
0035DE  780100     MOV W0, W2
0035E0  FB828B     ZE W11, W5
0035E2  218024     MOV #0x1802, W4
0035E4  420285     ADD W4, W5, W5
0035E6  9040D5     MOV.B [W5+5], W1
0035E8  FB8408     ZE W8, W8
0035EA  420208     ADD W4, W8, W4
0035EC  904054     MOV.B [W4+5], W0
0035EE  0703C3     RCALL put_big_sprite
0035F0  B7F816     MOV.B WREG, 0x1816
0035F2  37FDC5     BRA 0x317E
300:                               }else{
301:                                   vms.var[15]=put_sprite((int8_t)vms.var[x],(int8_t)vms.var[y],n,(const uint8_t*)&chip_prog[vms.ix]);
0035F4  208000     MOV #0x800, W0
0035F6  B41804     ADD 0x1804, WREG
0035F8  780180     MOV W0, W3
0035FA  FB828B     ZE W11, W5
0035FC  218024     MOV #0x1802, W4
0035FE  420285     ADD W4, W5, W5
003600  9040D5     MOV.B [W5+5], W1
003602  FB8408     ZE W8, W8
003604  420208     ADD W4, W8, W4
003606  904054     MOV.B [W4+5], W0
003608  07033A     RCALL put_sprite
00360A  B7F816     MOV.B WREG, 0x1816
00360C  37FDB8     BRA 0x317E
302:                               }
303:                               break;
304:                           }
305:                           break;
306:                       case 0xe9e: //EX9E, saute l'instruction suivante si la touche VX est enfoncée
307:                           if (key_down(vms.var[x])) vms.pc+=2;
00360E  FB8408     ZE W8, W8
003610  218064     MOV #0x1806, W4
003612  440404     ADD W8, W4, W8
003614  904018     MOV.B [W8+1], W0
003616  070A80     RCALL key_down
003618  504FE0     SUB.B W0, #0x0, [W15]
00361A  32FDB1     BRA Z, 0x317E
00361C  ECB802     INC2 vms
00361E  37FDAF     BRA 0x317E
308:                           break;
309:                       case 0xea1: //EXA1, saute l'instruction suivante si la touche VX n'est pas enfoncée
310:                           if (!key_down(vms.var[x])) vms.pc+=2;
003620  FB8408     ZE W8, W8
003622  218064     MOV #0x1806, W4
003624  440404     ADD W8, W4, W8
003626  904018     MOV.B [W8+1], W0
003628  070A77     RCALL key_down
00362A  504FE0     SUB.B W0, #0x0, [W15]
00362C  3AFDA8     BRA NZ, 0x317E
00362E  ECB802     INC2 vms
003630  37FDA6     BRA 0x317E
311:                           break;
312:                       case 0xf07: // FX07     VX := game_timer/16
313:                           vms.var[x]=game_timer>>4;
003632  80E9F4     MOV game_timer, W4
003634  FB8408     ZE W8, W8
003636  468408     ADD W13, W8, W8
003638  DE2244     LSR W4, #4, W4
00363A  984414     MOV.B W4, [W8+1]
314:                           break;
00363C  37FDA0     BRA 0x317E
315:                       case 0xf0a: // FX0A     attend qu'une touche soit enfoncée et met sa valeur dans VX
316:                           vms.var[x]=wait_key();
00363E  070A68     RCALL wait_key
003640  FB8408     ZE W8, W8
003642  468408     ADD W13, W8, W8
003644  984410     MOV.B W0, [W8+1]
317:                           break;
003646  37FD9B     BRA 0x317E
318:                       case 0xf15: // FX15  démarre la minuterie game_timer avec la valeur de délais VX*16
319:                           game_timer=vms.var[x]<<4;
003648  FB8408     ZE W8, W8
00364A  218064     MOV #0x1806, W4
00364C  440404     ADD W8, W4, W8
00364E  904218     MOV.B [W8+1], W4
003650  FB8204     ZE W4, W4
003652  DD2244     SL W4, #4, W4
003654  88E9F4     MOV W4, game_timer
320:                           break;
003656  37FD93     BRA 0x317E
321:                       case 0xf18: // FX18     fait entendre un beep d'une durée VX (multiple de 16 msec)
322:                           tone(523,vms.var[x]<<4);
003658  FB8408     ZE W8, W8
00365A  218064     MOV #0x1806, W4
00365C  440404     ADD W8, W4, W8
00365E  904098     MOV.B [W8+1], W1
003660  FB8081     ZE W1, W1
003662  DD08C4     SL W1, #4, W1
003664  2020B0     MOV #0x20B, W0
003666  0709F8     RCALL tone
323:                           break;
003668  37FD8A     BRA 0x317E
324:                       case 0xf1e: // FX1E     I := I + VX
325:                           vms.ix += vms.var[x];
00366A  FB8408     ZE W8, W8
00366C  218064     MOV #0x1806, W4
00366E  440404     ADD W8, W4, W8
003670  904018     MOV.B [W8+1], W0
003672  FB8000     ZE W0, W0
003674  B43804     ADD 0x1804
326:                           break;
003676  37FD83     BRA 0x317E
327:                       case 0xf29: // FX29     fait pointé vms.ix vers le caractère VX dans la police FONT_SHEX
328:                           vms.ix=vms.var[x]*SHEX_HEIGHT;
003678  FB8408     ZE W8, W8
00367A  218064     MOV #0x1806, W4
00367C  440404     ADD W8, W4, W8
00367E  904218     MOV.B [W8+1], W4
003680  FB8204     ZE W4, W4
003682  B92266     MUL.SU W4, #6, W4
003684  88C024     MOV W4, 0x1804
329:                           sprite_org=SMALL_HEX;
003686  EF3800     CLR sprite_org
330:                           break;
003688  37FD7A     BRA 0x317E
331:                       case 0xf30: // FX30 (schip)    fait pointé vms.ix vers le caractère dans  VX (0..9) pour la police FONT_LHEX
332:                           vms.ix=vms.var[x]*LHEX_HEIGHT;
00368A  FB8408     ZE W8, W8
00368C  218064     MOV #0x1806, W4
00368E  440404     ADD W8, W4, W8
003690  904218     MOV.B [W8+1], W4
003692  FB8204     ZE W4, W4
003694  B9226A     MUL.SU W4, #10, W4
003696  88C024     MOV W4, 0x1804
333:                           sprite_org=LARGE_HEX;
003698  200014     MOV #0x1, W4
00369A  88C004     MOV W4, sprite_org
334:                           break;
00369C  37FD70     BRA 0x317E
335:                       case 0xf33: // FX33     met la représentation BCD de VX dans M(vms.ix)..M(vms.ix+2)
336:                           n=vms.var[x];
00369E  FB8408     ZE W8, W8
0036A0  218064     MOV #0x1806, W4
0036A2  440404     ADD W8, W4, W8
0036A4  904018     MOV.B [W8+1], W0
337:                           chip_prog[vms.ix+2]=n%10;
0036A6  80C025     MOV 0x1804, W5
0036A8  FB8000     ZE W0, W0
0036AA  2000A4     MOV #0xA, W4
0036AC  090011     REPEAT #0x11
0036AE  D88004     DIV.UW W0, W4
0036B0  208026     MOV #0x802, W6
0036B2  7AF301     MOV.B W1, [W6+W5]
338:                           n /=10;
339:                           chip_prog[vms.ix+1]=n%10;
0036B4  090011     REPEAT #0x11
0036B6  D88004     DIV.UW W0, W4
0036B8  E90306     DEC W6, W6
0036BA  7B7281     MOV.B W1, [W5+W6]
340:                           chip_prog[vms.ix]=n/10;
0036BC  208006     MOV #0x800, W6
0036BE  7AF300     MOV.B W0, [W6+W5]
341:                           break;
0036C0  37FD5E     BRA 0x317E
342:                       case 0xf55: // FX55     Sauvegarde les registres V0..VX dans chip_prog à l'adresse M(vms.ix)
343:                           memcpy(&chip_prog[vms.ix],vms.var,(x+1));
0036C2  208000     MOV #0x800, W0
0036C4  B41804     ADD 0x1804, WREG
0036C6  FB8108     ZE W8, W2
0036C8  E80102     INC W2, W2
0036CA  218071     MOV #0x1807, W1
0036CC  07E600     RCALL _memcpy
344:                           break;
0036CE  37FD57     BRA 0x317E
345:                       case 0xf65: // FX65     charge les registres V0..VX à partir de la mémoire SRAM à l'adresse M(vms.ix)
346:                           memcpy(vms.var,&chip_prog[vms.ix],(x+1));
0036D0  FB8108     ZE W8, W2
0036D2  E80102     INC W2, W2
0036D4  208000     MOV #0x800, W0
0036D6  B41804     ADD 0x1804, WREG
0036D8  780080     MOV W0, W1
0036DA  218070     MOV #0x1807, W0
0036DC  07E5F8     RCALL _memcpy
347:                           break;
0036DE  37FD4F     BRA 0x317E
348:                       case 0xf75: // FX75 (mode schip seulement) sauvegarde les registres V0..VX dans rpl
349:                           for (n=0;n<=x;n++){
0036F0  E84204     INC.B W4, W4
0036F2  544F84     SUB.B W8, W4, [W15]
0036F4  31FFF8     BRA C, 0x36E6
0036F6  37FD43     BRA 0x317E
350:                               vms.rpl[n]=vms.var[n];
0036E2  218160     MOV #0x1816, W0
0036E4  218027     MOV #0x1802, W7
0036E6  FB8284     ZE W4, W5
0036E8  400305     ADD W0, W5, W6
0036EA  438285     ADD W7, W5, W5
0036EC  9042D5     MOV.B [W5+5], W5
0036EE  984315     MOV.B W5, [W6+1]
351:                           }
352:                           break;
353:                       case 0xf85: // FX85 (mode schip seulement) charge les registres V0..VX à partir de rpl
354:                               for (n=0;n<=x;n++){
003706  E84204     INC.B W4, W4
003708  544F84     SUB.B W8, W4, [W15]
00370A  31FFF8     BRA C, 0x36FC
00370C  37FD38     BRA 0x317E
355:                                   vms.var[n]=vms.rpl[n];
0036FA  218027     MOV #0x1802, W7
0036FC  FB8284     ZE W4, W5
0036FE  468305     ADD W13, W5, W6
003700  438285     ADD W7, W5, W5
003702  9052D5     MOV.B [W5+21], W5
003704  984315     MOV.B W5, [W6+1]
356:                               }
357:                               break;
358:                       default:
359:               #if FW_DEBUG
360:                               print_vms("BAD OPCODE\n");
361:               #endif
362:                               return CHIP_BAD_OPCODE;
003712  B3C020     MOV.B #0x2, W0
363:                       }//switch
364:                   }//while(1)
365:               }
003714  78074F     MOV [--W15], W14
003716  BE064F     MOV.D [--W15], W12
003718  BE054F     MOV.D [--W15], W10
00371A  BE044F     MOV.D [--W15], W8
00371C  060000     RETURN
---  C:/Users/Jacques/Documents/GitHub/PicVisionPortable/PICVisionPortable.X/Hardware/LCDout.c  ---------
1:                 
2:                 
3:                 #include "LCDout.h"
4:                 
5:                 
6:                 uint8_t display_buffer[VRES][HBYTES];
7:                 
8:                 #define LCD_DELAY  (40)
9:                 #define FN_DELAY  (100) 
10:                
11:                #define pulse_e() LCD_LAT |=LCD_E;\
12:                                  __delay_us(2);\
13:                                  LCD_LAT&=~LCD_E;\
14:                                  __delay_us(2)
15:                
16:                unsigned char display_buffer[64][16];
17:                
18:                static void LCD_send_cmd(uint8_t b){
004610  BE9F88     MOV.D W8, [W15++]
004612  781F8A     MOV W10, [W15++]
19:                    LCD_LAT &= ~LCD_PINS;
004614  281FF4     MOV #0x81FF, W4
004616  202CC5     MOV #0x2CC, W5
004618  620A95     AND W4, [W5], [W5]
20:                    LCD_LAT |= (b&0xf0)<<5;
00461A  FB8400     ZE W0, W8
00461C  780008     MOV W8, W0
00461E  B20F00     AND #0xF0, W0
004620  DD0045     SL W0, #5, W0
004622  B722CC     IOR LATB
21:                    pulse_e();
004624  24000A     MOV #0x4000, W10
004626  78000A     MOV W10, W0
004628  B722CC     IOR LATB
00462A  200200     MOV #0x20, W0
00462C  200001     MOV #0x0, W1
00462E  0702EA     RCALL ___delay32
004630  2BFFF9     MOV #0xBFFF, W9
004632  202CC4     MOV #0x2CC, W4
004634  648A14     AND W9, [W4], [W4]
004636  200200     MOV #0x20, W0
004638  200001     MOV #0x0, W1
00463A  0702E4     RCALL ___delay32
22:                    LCD_LAT &=~LCD_DATA_PINS;
00463C  2E1FF4     MOV #0xE1FF, W4
00463E  202CC5     MOV #0x2CC, W5
004640  620A95     AND W4, [W5], [W5]
23:                    LCD_LAT |= (b&0xf)<<9;
004642  64046F     AND W8, #0xF, W8
004644  DD4049     SL W8, #9, W0
004646  B722CC     IOR LATB
24:                    pulse_e();
004648  78000A     MOV W10, W0
00464A  B722CC     IOR LATB
00464C  200200     MOV #0x20, W0
00464E  200001     MOV #0x0, W1
004650  0702D9     RCALL ___delay32
004652  202CC4     MOV #0x2CC, W4
004654  648A14     AND W9, [W4], [W4]
004656  200200     MOV #0x20, W0
004658  200001     MOV #0x0, W1
00465A  0702D4     RCALL ___delay32
25:                }//f()
00465C  78054F     MOV [--W15], W10
00465E  BE044F     MOV.D [--W15], W8
004660  060000     RETURN
26:                
27:                static void LCD_send_data(uint8_t b){
004662  BE9F88     MOV.D W8, [W15++]
004664  781F8A     MOV W10, [W15++]
28:                    LCD_LAT &= ~LCD_PINS;
004666  281FF4     MOV #0x81FF, W4
004668  202CC5     MOV #0x2CC, W5
00466A  620A95     AND W4, [W5], [W5]
29:                    LCD_LAT |= LCD_RS;
00466C  A8A2CD     BSET 0x2CD, #5
30:                    LCD_LAT |= (b&0xf0)<<5;
00466E  FB8400     ZE W0, W8
004670  780008     MOV W8, W0
004672  B20F00     AND #0xF0, W0
004674  DD0045     SL W0, #5, W0
004676  B722CC     IOR LATB
31:                    pulse_e();
004678  24000A     MOV #0x4000, W10
00467A  78000A     MOV W10, W0
00467C  B722CC     IOR LATB
00467E  200200     MOV #0x20, W0
004680  200001     MOV #0x0, W1
004682  0702C0     RCALL ___delay32
004684  2BFFF9     MOV #0xBFFF, W9
004686  202CC4     MOV #0x2CC, W4
004688  648A14     AND W9, [W4], [W4]
00468A  200200     MOV #0x20, W0
00468C  200001     MOV #0x0, W1
00468E  0702BA     RCALL ___delay32
32:                    LCD_LAT &=~LCD_DATA_PINS;
004690  2E1FF4     MOV #0xE1FF, W4
004692  202CC5     MOV #0x2CC, W5
004694  620A95     AND W4, [W5], [W5]
33:                    LCD_LAT |= (b&0xf)<<9;
004696  64046F     AND W8, #0xF, W8
004698  DD4049     SL W8, #9, W0
00469A  B722CC     IOR LATB
34:                    pulse_e();
00469C  78000A     MOV W10, W0
00469E  B722CC     IOR LATB
0046A0  200200     MOV #0x20, W0
0046A2  200001     MOV #0x0, W1
0046A4  0702AF     RCALL ___delay32
0046A6  202CC4     MOV #0x2CC, W4
0046A8  648A14     AND W9, [W4], [W4]
0046AA  200200     MOV #0x20, W0
0046AC  200001     MOV #0x0, W1
0046AE  0702AA     RCALL ___delay32
35:                }
0046B0  78054F     MOV [--W15], W10
0046B2  BE044F     MOV.D [--W15], W8
0046B4  060000     RETURN
36:                
37:                static void LCD_set_mode(glcd_mode_t mode){
38:                    if (mode==LCD_TEXT){ // text mode 4 bits bus, base commands set
0046B6  500FE0     SUB W0, #0x0, [W15]
0046B8  3A0003     BRA NZ, 0x46C0
39:                        LCD_send_cmd(BCMD_FUNC_SET);
0046BA  B3C200     MOV.B #0x20, W0
0046BC  07FFA9     RCALL _LCD_send_cmd
0046BE  370002     BRA 0x46C4
40:                    }else{//graphic mode, 4 bits data, Graphic mode, extended commands set
41:                        LCD_send_cmd(BCMD_FUNC_SET|G_BIT|RE_BIT);
0046C0  B3C260     MOV.B #0x26, W0
0046C2  07FFA6     RCALL _LCD_send_cmd
42:                    }
43:                      __delay_us(LCD_DELAY);
0046C4  202800     MOV #0x280, W0
0046C6  200001     MOV #0x0, W1
0046C8  07029D     RCALL ___delay32
44:                }//f()
0046CA  060000     RETURN
45:                
46:                // see power sequence in datasheet V4.0 (2008/08/18) page 35
47:                void LCDout_init(){
48:                    //power up delay wait +5volt to set
49:                    __delay_ms(20);
0046CC  2E2000     MOV #0xE200, W0
0046CE  200041     MOV #0x4, W1
0046D0  070299     RCALL ___delay32
50:                    //release from RESET 
51:                    LCD_LAT |= LCD_RST;
0046D2  280000     MOV #0x8000, W0
0046D4  B722CC     IOR LATB
52:                    __delay_ms(80);
0046D6  288000     MOV #0x8800, W0
0046D8  200131     MOV #0x13, W1
0046DA  070294     RCALL ___delay32
53:                    // set bus width to 4 bits, send 2 times
54:                    LCD_send_cmd(BCMD_FUNC_SET);
0046DC  B3C200     MOV.B #0x20, W0
0046DE  07FF98     RCALL _LCD_send_cmd
55:                    __delay_us(FN_DELAY);
0046E0  206400     MOV #0x640, W0
0046E2  200001     MOV #0x0, W1
0046E4  07028F     RCALL ___delay32
56:                    LCD_send_cmd(BCMD_FUNC_SET);
0046E6  B3C200     MOV.B #0x20, W0
0046E8  07FF93     RCALL _LCD_send_cmd
57:                    __delay_us(FN_DELAY);
0046EA  206400     MOV #0x640, W0
0046EC  200001     MOV #0x0, W1
0046EE  07028A     RCALL ___delay32
58:                // graphic mode, extended command
59:                    LCD_set_mode(LCD_GRAPHIC);
0046F0  200010     MOV #0x1, W0
0046F2  07FFE1     RCALL _LCD_set_mode
60:                    __delay_us(FN_DELAY);
0046F4  206400     MOV #0x640, W0
0046F6  200001     MOV #0x0, W1
0046F8  070285     RCALL ___delay32
61:                    // display refresh timer setup
62:                    LCD_PR=(FCY/MHZ)*LCD_DELAY-1;
0046FA  2027F4     MOV #0x27F, W4
0046FC  880874     MOV W4, PR3
63:                    LCD_CON=0xA000;
0046FE  2A0004     MOV #0xA000, W4
004700  880894     MOV W4, T3CON
64:                    LCD_IF=0;
004702  A90085     BCLR 0x85, #0
65:                    LCD_IE=1;
004704  A80095     BSET 0x95, #0
66:                }
004706  060000     RETURN
67:                
68:                volatile uint16_t frame_counter;
69:                volatile static  uint8_t x=0,y=0;
70:                volatile static  uint8_t state=0;
71:                
72:                void __attribute__((interrupt,no_auto_psv)) _T3Interrupt(void){
004708  F80036     PUSH RCOUNT
00470A  BE9F80     MOV.D W0, [W15++]
00470C  BE9F82     MOV.D W2, [W15++]
00470E  BE9F84     MOV.D W4, [W15++]
004710  BE9F86     MOV.D W6, [W15++]
73:                    switch (state){
004712  21C6E4     MOV #0x1C6E, W4
004714  784214     MOV.B [W4], W4
004716  524FE0     SUB.B W4, #0x0, [W15]
004718  320003     BRA Z, 0x4720
00471A  524FE1     SUB.B W4, #0x1, [W15]
00471C  3A000A     BRA NZ, 0x4732
00471E  370005     BRA 0x472A
74:                    case 0:
75:                        LCD_send_cmd(XCMD_GAC|y);
004720  BFDC6F     MOV.B y, WREG
004722  A07400     BSET.B W0, #7
004724  07FF75     RCALL _LCD_send_cmd
76:                        state++;
004726  EC7C6E     INC.B state
77:                        break;
004728  370039     BRA 0x479C
78:                    case 1:
79:                        LCD_send_cmd(XCMD_GAC);
00472A  B3C800     MOV.B #0x80, W0
00472C  07FF71     RCALL _LCD_send_cmd
80:                        state++;
00472E  EC7C6E     INC.B state
81:                        break;
004730  370035     BRA 0x479C
82:                    default :
83:                        if (x<16){
004732  21C704     MOV #0x1C70, W4
004734  784214     MOV.B [W4], W4
004736  524FEF     SUB.B W4, #0xF, [W15]
004738  3E000C     BRA GTU, 0x4752
84:                            LCD_send_data(display_buffer[y][x]);
00473A  21C6F4     MOV #0x1C6F, W4
00473C  784214     MOV.B [W4], W4
00473E  21C705     MOV #0x1C70, W5
004740  784295     MOV.B [W5], W5
004742  FB8204     ZE W4, W4
004744  DD2244     SL W4, #4, W4
004746  FB8285     ZE W5, W5
004748  420205     ADD W4, W5, W4
00474A  2186C5     MOV #0x186C, W5
00474C  7A4065     MOV.B [W5+W4], W0
00474E  07FF89     RCALL _LCD_send_data
004750  37000D     BRA 0x476C
85:                        }else{
86:                            LCD_send_data(display_buffer[y+32][x-16]);
004752  21C6F5     MOV #0x1C6F, W5
004754  784295     MOV.B [W5], W5
004756  21C704     MOV #0x1C70, W4
004758  784214     MOV.B [W4], W4
00475A  FB8285     ZE W5, W5
00475C  B00205     ADD #0x20, W5
00475E  DD2AC4     SL W5, #4, W5
004760  FB8204     ZE W4, W4
004762  520270     SUB W4, #0x10, W4
004764  428204     ADD W5, W4, W4
004766  2186C5     MOV #0x186C, W5
004768  7A4065     MOV.B [W5+W4], W0
00476A  07FF7B     RCALL _LCD_send_data
87:                        }
88:                        x++;
00476C  EC7C70     INC.B x
89:                        x &= 31;
00476E  21C704     MOV #0x1C70, W4
004770  784214     MOV.B [W4], W4
004772  62427F     AND.B W4, #0x1F, W4
004774  FD0200     EXCH W0, W4
004776  B7FC70     MOV.B WREG, x
004778  FD0200     EXCH W0, W4
90:                        if (x==0){
00477A  21C704     MOV #0x1C70, W4
00477C  784214     MOV.B [W4], W4
00477E  524FE0     SUB.B W4, #0x0, [W15]
004780  3A000D     BRA NZ, 0x479C
91:                            state=0;
004782  EF7C6E     CLR.B state
92:                            y++;
004784  EC7C6F     INC.B y
93:                            y &=31;
004786  21C6F4     MOV #0x1C6F, W4
004788  784214     MOV.B [W4], W4
00478A  62427F     AND.B W4, #0x1F, W4
00478C  FD0200     EXCH W0, W4
00478E  B7FC6F     MOV.B WREG, y
004790  FD0200     EXCH W0, W4
94:                            if (y==0) frame_counter++;
004792  21C6F4     MOV #0x1C6F, W4
004794  784214     MOV.B [W4], W4
004796  524FE0     SUB.B W4, #0x0, [W15]
004798  3A0001     BRA NZ, 0x479C
00479A  EC3C6C     INC frame_counter
95:                        }
96:                        break;
97:                    }
98:                    LCD_IF=0;
00479C  A90085     BCLR 0x85, #0
99:                }//f()
00479E  BE034F     MOV.D [--W15], W6
0047A0  BE024F     MOV.D [--W15], W4
0047A2  BE014F     MOV.D [--W15], W2
0047A4  BE004F     MOV.D [--W15], W0
0047A6  F90036     POP RCOUNT
0047A8  064000     RETFIE
100:               
---  C:/Users/Jacques/Documents/GitHub/PicVisionPortable/PICVisionPortable.X/Hardware/HardwareProfile.c  
1:                 #include <xc.h>
2:                 
3:                 #include "HardwareProfile.h"
4:                 
5:                 volatile uint32_t systick; // millisecond ticks
6:                 volatile uint16_t game_timer;
7:                 
8:                 #if SDC_SUPPORT
9:                 #include "../FAT/sd_raw.h"
10:                bool sdcard_available=false;
11:                #endif
12:                
13:                void HardwareInit(){
14:                // clock setting
15:                    CLKDIV=0;
004908  EF2744     CLR CLKDIV
16:                // systick timer configuration
17:                    SYSTICK_IPC &= ~(7<<12); //remet niveau à zéro T1IPL
00490A  270005     MOV #0x7000, W5
00490C  800524     MOV IPC0, W4
00490E  628284     AND W5, W4, W5
004910  28FFF4     MOV #0x8FFF, W4
004912  800527     MOV IPC0, W7
004914  620307     AND W4, W7, W6
004916  728286     IOR W5, W6, W5
004918  880525     MOV W5, IPC0
18:                    SYSTICK_IPC |= 1<<12;  // met niveau à 1  T1IPL
00491A  270005     MOV #0x7000, W5
00491C  800526     MOV IPC0, W6
00491E  628286     AND W5, W6, W5
004920  800527     MOV IPC0, W7
004922  620207     AND W4, W7, W4
004924  728284     IOR W5, W4, W5
004926  880525     MOV W5, IPC0
19:                    SYSTICK_IF=0;
004928  A96084     BCLR IFS0, #3
20:                    SYSTICK_IE=1;
00492A  A86094     BSET IEC0, #3
21:                    systick=0;
00492C  EF3D3A     CLR systick
00492E  EF3D3C     CLR 0x1D3C
22:                    PR1=FCY/1000;
004930  23E804     MOV #0x3E80, W4
004932  880814     MOV W4, PR1
23:                    T1CON=0xA000;
004934  2A0004     MOV #0xA000, W4
004936  880824     MOV W4, T1CON
24:                // tone init
25:                    TONE_PIN_PPS=TONE_OUT_FN; // select OCx on audio_out pin
004938  2FFE04     MOV #0xFFE0, W4
00493A  803625     MOV RPOR2, W5
00493C  620205     AND W4, W5, W4
00493E  B30134     IOR #0x13, W4
004940  883624     MOV W4, RPOR2
26:                    TONE_OCCON=(1<<13);
004942  220004     MOV #0x2000, W4
004944  880C54     MOV W4, OC2CON
27:                    TONE_TMRCON = (1<<13);
004946  880884     MOV W4, T2CON
28:                    TONE_IPC=3;
004948  230004     MOV #0x3000, W4
00494A  800536     MOV IPC1, W6
00494C  730304     IOR W6, W4, W6
00494E  780206     MOV W6, W4
004950  A1E004     BCLR W4, #14
004952  880534     MOV W4, IPC1
29:                
30:                // LCD port configuraton
31:                    LCD_LAT &= ~(LCD_PINS|LCD_RST); // 0 volt on all LCD pins
004954  201FF4     MOV #0x1FF, W4
004956  202CC7     MOV #0x2CC, W7
004958  620B97     AND W4, [W7], [W7]
32:                    LCD_ODC |= LCD_PINS|LCD_RST;  // LCD pins configured Open Drain.
00495A  2FE000     MOV #0xFE00, W0
00495C  B722CE     IOR ODCB
33:                    LCD_TRIS &= ~(LCD_PINS|LCD_RST); // LCD pins all outputs.
00495E  202C85     MOV #0x2C8, W5
004960  620A95     AND W4, [W5], [W5]
34:                
35:                // Keypad input pins
36:                    TRISA = KP_MASK;
004962  2001F4     MOV #0x1F, W4
004964  881604     MOV W4, TRISA
37:                    AD1PCFG=KP_MASK;
004966  881964     MOV W4, AD1PCFG
38:                
39:                #if SDC_SUPPORT
40:                    sdcard_available=sd_raw_init();
004968  07F718     RCALL sd_raw_init
00496A  FB8200     ZE W0, W4
00496C  EA0204     NEG W4, W4
00496E  DE224F     LSR W4, #15, W4
004970  780004     MOV W4, W0
004972  B7FD38     MOV.B WREG, sdcard_available
41:                #endif
42:                
43:                    // lock PPS configuration
44:                    asm("mov #0x46, W0\n"
004974  200460     MOV #0x46, W0
004976  883A10     MOV W0, OSCCON
004978  200570     MOV #0x57, W0
00497A  883A10     MOV W0, OSCCON
00497C  A8C742     BSET OSCCON, #6
45:                        "mov W0, OSCCON\n"
46:                        "mov #0x57, W0\n"
47:                        "mov  W0, OSCCON\n"
48:                        "bset OSCCON, #6\n");
49:                
50:                }//f()
00497E  060000     RETURN
51:                
52:                #include "../tone.h"
53:                
54:                void pause(uint16_t msec){
55:                    uint32_t t0;
56:                    t0=systick+msec;
004980  80E9D4     MOV systick, W4
004982  80E9E5     MOV 0x1D3C, W5
004984  420000     ADD W4, W0, W0
004986  4A80E0     ADDC W5, #0x0, W1
57:                    while (systick<t0);
004988  80E9D4     MOV systick, W4
00498A  80E9E5     MOV 0x1D3C, W5
00498C  500F84     SUB W0, W4, [W15]
00498E  588F85     SUBB W1, W5, [W15]
004990  3EFFFB     BRA GTU, 0x4988
58:                }//f()
004992  060000     RETURN
59:                
60:                void __attribute__((interrupt,no_auto_psv)) _T1Interrupt(void){
004994  781F80     MOV W0, [W15++]
004996  BE9F84     MOV.D W4, [W15++]
61:                    systick++;
004998  80E9D4     MOV systick, W4
00499A  80E9E5     MOV 0x1D3C, W5
00499C  420261     ADD W4, #0x1, W4
00499E  4A82E0     ADDC W5, #0x0, W5
0049A0  88E9D4     MOV W4, systick
0049A2  88E9E5     MOV W5, 0x1D3C
62:                    if (tone_timer){
0049A4  80EA74     MOV tone_timer, W4
0049A6  520FE0     SUB W4, #0x0, [W15]
0049A8  320007     BRA Z, 0x49B8
63:                        tone_timer--;
0049AA  ED3D4E     DEC tone_timer
64:                        if (!tone_timer){
0049AC  80EA74     MOV tone_timer, W4
0049AE  520FE0     SUB W4, #0x0, [W15]
0049B0  3A0003     BRA NZ, 0x49B8
65:                            tone_off();
0049B2  A9E111     BCLR 0x111, #7
0049B4  A982CC     BCLR LATB, #4
0049B6  A9E094     BCLR IEC0, #7
66:                        }
67:                    }
68:                    if (game_timer){
0049B8  80E9F4     MOV game_timer, W4
0049BA  520FE0     SUB W4, #0x0, [W15]
0049BC  320001     BRA Z, 0x49C0
69:                        game_timer--;
0049BE  ED3D3E     DEC game_timer
70:                    }
71:                    SYSTICK_IF=0;
0049C0  A96084     BCLR IFS0, #3
72:                }//f()
0049C2  BE024F     MOV.D [--W15], W4
0049C4  78004F     MOV [--W15], W0
0049C6  064000     RETFIE
---  C:/Users/Jacques/Documents/GitHub/PicVisionPortable/PICVisionPortable.X/FAT/sd_raw.c  --------------
1:                 
2:                 /*
3:                  * Copyright (c) 2006-2012 by Roland Riegel <feedback@roland-riegel.de>
4:                  *
5:                  * This file is free software; you can redistribute it and/or modify
6:                  * it under the terms of either the GNU General Public License version 2
7:                  * or the GNU Lesser General Public License version 2.1, both as
8:                  * published by the Free Software Foundation.
9:                  */
10:                
11:                #include <string.h>
12:                #include "sd_raw.h"
13:                
14:                /**
15:                 * \addtogroup sd_raw MMC/SD/SDHC card raw access
16:                 *
17:                 * This module implements read and write access to MMC, SD
18:                 * and SDHC cards. It serves as a low-level driver for the
19:                 * higher level modules such as partition and file system
20:                 * access.
21:                 *
22:                 * @{
23:                 */
24:                /**
25:                 * \file
26:                 * MMC/SD/SDHC raw access implementation (license: GPLv2 or LGPLv2.1)
27:                 *
28:                 * \author Roland Riegel
29:                 */
30:                
31:                /**
32:                 * \addtogroup sd_raw_config MMC/SD configuration
33:                 * Preprocessor defines to configure the MMC/SD support.
34:                 */
35:                
36:                /**
37:                 * @}
38:                 */
39:                
40:                /* commands available in SPI mode */
41:                
42:                /* CMD0: response R1 */
43:                #define CMD_GO_IDLE_STATE 0x00
44:                /* CMD1: response R1 */
45:                #define CMD_SEND_OP_COND 0x01
46:                /* CMD8: response R7 */
47:                #define CMD_SEND_IF_COND 0x08
48:                /* CMD9: response R1 */
49:                #define CMD_SEND_CSD 0x09
50:                /* CMD10: response R1 */
51:                #define CMD_SEND_CID 0x0a
52:                /* CMD12: response R1 */
53:                #define CMD_STOP_TRANSMISSION 0x0c
54:                /* CMD13: response R2 */
55:                #define CMD_SEND_STATUS 0x0d
56:                /* CMD16: arg0[31:0]: block length, response R1 */
57:                #define CMD_SET_BLOCKLEN 0x10
58:                /* CMD17: arg0[31:0]: data address, response R1 */
59:                #define CMD_READ_SINGLE_BLOCK 0x11
60:                /* CMD18: arg0[31:0]: data address, response R1 */
61:                #define CMD_READ_MULTIPLE_BLOCK 0x12
62:                /* CMD24: arg0[31:0]: data address, response R1 */
63:                #define CMD_WRITE_SINGLE_BLOCK 0x18
64:                /* CMD25: arg0[31:0]: data address, response R1 */
65:                #define CMD_WRITE_MULTIPLE_BLOCK 0x19
66:                /* CMD27: response R1 */
67:                #define CMD_PROGRAM_CSD 0x1b
68:                /* CMD28: arg0[31:0]: data address, response R1b */
69:                #define CMD_SET_WRITE_PROT 0x1c
70:                /* CMD29: arg0[31:0]: data address, response R1b */
71:                #define CMD_CLR_WRITE_PROT 0x1d
72:                /* CMD30: arg0[31:0]: write protect data address, response R1 */
73:                #define CMD_SEND_WRITE_PROT 0x1e
74:                /* CMD32: arg0[31:0]: data address, response R1 */
75:                #define CMD_TAG_SECTOR_START 0x20
76:                /* CMD33: arg0[31:0]: data address, response R1 */
77:                #define CMD_TAG_SECTOR_END 0x21
78:                /* CMD34: arg0[31:0]: data address, response R1 */
79:                #define CMD_UNTAG_SECTOR 0x22
80:                /* CMD35: arg0[31:0]: data address, response R1 */
81:                #define CMD_TAG_ERASE_GROUP_START 0x23
82:                /* CMD36: arg0[31:0]: data address, response R1 */
83:                #define CMD_TAG_ERASE_GROUP_END 0x24
84:                /* CMD37: arg0[31:0]: data address, response R1 */
85:                #define CMD_UNTAG_ERASE_GROUP 0x25
86:                /* CMD38: arg0[31:0]: stuff bits, response R1b */
87:                #define CMD_ERASE 0x26
88:                /* ACMD41: arg0[31:0]: OCR contents, response R1 */
89:                #define CMD_SD_SEND_OP_COND 0x29
90:                /* CMD42: arg0[31:0]: stuff bits, response R1b */
91:                #define CMD_LOCK_UNLOCK 0x2a
92:                /* CMD55: arg0[31:0]: stuff bits, response R1 */
93:                #define CMD_APP 0x37
94:                /* CMD58: arg0[31:0]: stuff bits, response R3 */
95:                #define CMD_READ_OCR 0x3a
96:                /* CMD59: arg0[31:1]: stuff bits, arg0[0:0]: crc option, response R1 */
97:                #define CMD_CRC_ON_OFF 0x3b
98:                
99:                /* command responses */
100:               /* R1: size 1 byte */
101:               #define R1_IDLE_STATE 0
102:               #define R1_ERASE_RESET 1
103:               #define R1_ILL_COMMAND 2
104:               #define R1_COM_CRC_ERR 3
105:               #define R1_ERASE_SEQ_ERR 4
106:               #define R1_ADDR_ERR 5
107:               #define R1_PARAM_ERR 6
108:               /* R1b: equals R1, additional busy bytes */
109:               /* R2: size 2 bytes */
110:               #define R2_CARD_LOCKED 0
111:               #define R2_WP_ERASE_SKIP 1
112:               #define R2_ERR 2
113:               #define R2_CARD_ERR 3
114:               #define R2_CARD_ECC_FAIL 4
115:               #define R2_WP_VIOLATION 5
116:               #define R2_INVAL_ERASE 6
117:               #define R2_OUT_OF_RANGE 7
118:               #define R2_CSD_OVERWRITE 7
119:               #define R2_IDLE_STATE (R1_IDLE_STATE + 8)
120:               #define R2_ERASE_RESET (R1_ERASE_RESET + 8)
121:               #define R2_ILL_COMMAND (R1_ILL_COMMAND + 8)
122:               #define R2_COM_CRC_ERR (R1_COM_CRC_ERR + 8)
123:               #define R2_ERASE_SEQ_ERR (R1_ERASE_SEQ_ERR + 8)
124:               #define R2_ADDR_ERR (R1_ADDR_ERR + 8)
125:               #define R2_PARAM_ERR (R1_PARAM_ERR + 8)
126:               /* R3: size 5 bytes */
127:               #define R3_OCR_MASK (0xffffffffUL)
128:               #define R3_IDLE_STATE (R1_IDLE_STATE + 32)
129:               #define R3_ERASE_RESET (R1_ERASE_RESET + 32)
130:               #define R3_ILL_COMMAND (R1_ILL_COMMAND + 32)
131:               #define R3_COM_CRC_ERR (R1_COM_CRC_ERR + 32)
132:               #define R3_ERASE_SEQ_ERR (R1_ERASE_SEQ_ERR + 32)
133:               #define R3_ADDR_ERR (R1_ADDR_ERR + 32)
134:               #define R3_PARAM_ERR (R1_PARAM_ERR + 32)
135:               /* Data Response: size 1 byte */
136:               #define DR_STATUS_MASK 0x0e
137:               #define DR_STATUS_ACCEPTED 0x05
138:               #define DR_STATUS_CRC_ERR 0x0a
139:               #define DR_STATUS_WRITE_ERR 0x0c
140:               
141:               /* status bits for card types */
142:               #define SD_RAW_SPEC_1 0
143:               #define SD_RAW_SPEC_2 1
144:               #define SD_RAW_SPEC_SDHC 2
145:               
146:               #if !SD_RAW_SAVE_RAM
147:               /* static data buffer for acceleration */
148:               static uint8_t raw_block[512];
149:               /* offset where the data within raw_block lies on the card */
150:               static offset_t raw_block_address;
151:               #if SD_RAW_WRITE_BUFFERING
152:               /* flag to remember if raw_block was written to the card */
153:               static uint8_t raw_block_written;
154:               #endif
155:               #endif
156:               
157:               
158:               
159:               /* card type state */
160:               static uint8_t sd_raw_card_type;
161:               
162:               /* private helper functions */
163:               static void sd_raw_send_byte(uint8_t b);
164:               static uint8_t sd_raw_rec_byte();
165:               static uint8_t sd_raw_send_command(uint8_t command, uint32_t arg);
166:               
167:               /**
168:                * \ingroup sd_raw
169:                * Initializes memory card communication.
170:                *
171:                * \returns 0 on failure, 1 on success.
172:                */
173:               uint8_t sd_raw_init()
174:               {
00379A  BE9F88     MOV.D W8, [W15++]
00379C  781F8A     MOV W10, [W15++]
175:                   /* enable inputs for reading card status */
176:               #ifdef __PIC24__
177:                   sdc_disable_analog_pin();
00379E  A8A32C     BSET AD1PCFG, #5
178:               #endif
179:                   configure_pin_available();
0037A0  A862C8     BSET TRISB, #3
180:               #if !defined(_CHIPCON_)
181:               	configure_pin_locked();
182:               #endif
183:                   /* enable outputs for MOSI, SCK, SS, input for MISO */
184:                   configure_pin_mosi();
0037A2  2E0FF5     MOV #0xE0FF, W5
0037A4  803634     MOV RPOR3, W4
0037A6  628304     AND W5, W4, W6
0037A8  207004     MOV #0x700, W4
0037AA  720206     IOR W4, W6, W4
0037AC  883634     MOV W4, RPOR3
185:                   configure_pin_sck();
0037AE  2FFE04     MOV #0xFFE0, W4
0037B0  803637     MOV RPOR3, W7
0037B2  620307     AND W4, W7, W6
0037B4  A03006     BSET W6, #3
0037B6  883636     MOV W6, RPOR3
0037B8  803546     MOV RPINR20, W6
0037BA  628286     AND W5, W6, W5
0037BC  206006     MOV #0x600, W6
0037BE  730305     IOR W6, W5, W6
0037C0  883546     MOV W6, RPINR20
186:                   configure_pin_ss();
0037C2  A902C9     BCLR 0x2C9, #0
187:                   configure_pin_miso();
0037C4  803547     MOV RPINR20, W7
0037C6  620207     AND W4, W7, W4
0037C8  B30054     IOR #0x5, W4
0037CA  883544     MOV W4, RPINR20
0037CC  A8A2C8     BSET TRISB, #5
188:               
189:                   unselect_card();
0037CE  A802CD     BSET 0x2CD, #0
190:               
191:                   /* initialize SPI with lowest frequency; max. 400kHz during identification mode of card */
192:               #ifdef __PIC24__
193:                   SDC_CON1=(1<<5)|(6<<2)|(1<<8)|(1<<9);
0037D0  203384     MOV #0x338, W4
0037D2  881214     MOV W4, SPI1CON1
194:                   SDC_CON2=0x0;
0037D4  EB0200     CLR W4
0037D6  881224     MOV W4, SPI1CON2
195:                   SDC_STAT=0x2000;
0037D8  220005     MOV #0x2000, W5
0037DA  881205     MOV W5, SPI1STAT
196:                   sdc_spi_enable();
0037DC  A8E241     BSET 0x241, #7
197:               
198:               #else
199:                   SPCR = (0 << SPIE) | /* SPI Interrupt Enable */
200:                          (1 << SPE)  | /* SPI Enable */
201:                          (0 << DORD) | /* Data Order: MSB first */
202:                          (1 << MSTR) | /* Master mode */
203:                          (0 << CPOL) | /* Clock Polarity: SCK low when idle */
204:                          (0 << CPHA) | /* Clock Phase: sample on rising SCK edge */
205:                          (1 << SPR1) | /* Clock Frequency: f_OSC / 128 */
206:                          (1 << SPR0);
207:                   SPSR &= ~(1 << SPI2X); /* No doubled clock frequency */
208:               #endif
209:                   /* initialization procedure */
210:                   sd_raw_card_type = 0;
0037DE  FD0200     EXCH W0, W4
0037E0  B7FD48     MOV.B WREG, sd_raw_card_type
0037E2  FD0200     EXCH W0, W4
211:                   
212:                   if(!sd_raw_available())
0037E4  07FFD5     RCALL sd_raw_available
0037E6  784200     MOV.B W0, W4
0037EA  524F80     SUB.B W4, W0, [W15]
0037EC  320041     BRA Z, 0x3870
0037EE  2000A8     MOV #0xA, W8
00381E  EB0400     CLR W8
213:                       return 0;
0037E8  EB4000     CLR.B W0
214:                   
215:                   /* card needs 74 cycles minimum to start up */
216:                   uint16_t i;
217:                   for(i = 0; i < 10; ++i)
0037F4  3AFFFD     BRA NZ, 0x37F0
218:                   {
219:                       /* wait 10 clock cycles */
220:                       sd_raw_rec_byte();
0037F0  07FF9C     RCALL _sd_raw_rec_byte
0037F2  E90408     DEC W8, W8
221:                   }
222:               
223:                   /* address card */
224:                   select_card();
0037F6  A902CD     BCLR 0x2CD, #0
225:                   /* reset card */
226:                   uint8_t response;
227:                   for(i = 0; ; ++i)
228:                   {
229:                       response = sd_raw_send_command(CMD_GO_IDLE_STATE, 0);
0037F8  B84460     MUL.UU W8, #0, W8
0037FA  EB4500     CLR.B W10
0037FC  BE0108     MOV.D W8, W2
0037FE  78400A     MOV.B W10, W0
003800  07FF9B     RCALL _sd_raw_send_command
230:                       if(response == (1 << R1_IDLE_STATE))
003802  504FE1     SUB.B W0, #0x1, [W15]
003804  3AFFFB     BRA NZ, 0x37FC
231:                           break;
232:               
233:               //        if(i == 0x1ff)
234:               //        {
235:               //            unselect_card();
236:               //            return 0;
237:               //        }
238:                   }
239:               
240:               #if SD_RAW_SDHC
241:                   /* check for version of SD card specification */
242:                   response = sd_raw_send_command(CMD_SEND_IF_COND, 0x100 /* 2.7V - 3.6V */ | 0xaa /* test pattern */);
243:                   if((response & (1 << R1_ILL_COMMAND)) == 0)
244:                   {
245:                       sd_raw_rec_byte();
246:                       sd_raw_rec_byte();
247:                       if((sd_raw_rec_byte() & 0x01) == 0)
248:                           return 0; /* card operation voltage range doesn't match */
249:                       if(sd_raw_rec_byte() != 0xaa)
250:                           return 0; /* wrong test pattern */
251:               
252:                       /* card conforms to SD 2 card specification */
253:                       sd_raw_card_type |= (1 << SD_RAW_SPEC_2);
254:                   }
255:                   else
256:               #endif
257:                   {
258:                       /* determine SD/MMC card type */
259:                       sd_raw_send_command(CMD_APP, 0);
003806  B81160     MUL.UU W2, #0, W2
003808  B3C370     MOV.B #0x37, W0
00380A  07FF96     RCALL _sd_raw_send_command
260:                       response = sd_raw_send_command(CMD_SD_SEND_OP_COND, 0);
00380C  B81160     MUL.UU W2, #0, W2
00380E  B3C290     MOV.B #0x29, W0
003810  07FF93     RCALL _sd_raw_send_command
261:                       if((response & (1 << R1_ILL_COMMAND)) == 0)
003812  600264     AND W0, #0x4, W4
003814  3A0004     BRA NZ, 0x381E
262:                       {
263:                           /* card conforms to SD 1 card specification */
264:                           sd_raw_card_type |= (1 << SD_RAW_SPEC_1);
003816  B3C014     MOV.B #0x1, W4
003818  FD0200     EXCH W0, W4
00381A  B7FD48     MOV.B WREG, sd_raw_card_type
00381C  FD0200     EXCH W0, W4
265:                       }
266:                       else
267:                       {
268:                           /* MMC card */
269:                       }
270:                   }
271:               
272:                   /* wait for card to get ready */
273:                   for(i = 0; ; ++i)
00384E  E80408     INC W8, W8
274:                   {
275:                       if(sd_raw_card_type & ((1 << SD_RAW_SPEC_1) | (1 << SD_RAW_SPEC_2)))
003824  21D484     MOV #0x1D48, W4
003826  784214     MOV.B [W4], W4
003828  620263     AND W4, #0x3, W4
00382A  320007     BRA Z, 0x383A
276:                       {
277:                           uint32_t arg = 0;
278:               #if SD_RAW_SDHC
279:                           if(sd_raw_card_type & (1 << SD_RAW_SPEC_2))
280:                               arg = 0x40000000;
281:               #endif
282:                           sd_raw_send_command(CMD_APP, 0);
003820  B3C379     MOV.B #0x37, W9
00382C  B81160     MUL.UU W2, #0, W2
00382E  784009     MOV.B W9, W0
003830  07FF83     RCALL _sd_raw_send_command
283:                           response = sd_raw_send_command(CMD_SD_SEND_OP_COND, arg);
003832  B81160     MUL.UU W2, #0, W2
003834  B3C290     MOV.B #0x29, W0
003836  07FF80     RCALL _sd_raw_send_command
003838  370003     BRA 0x3840
284:                       }
285:                       else
286:                       {
287:                           response = sd_raw_send_command(CMD_SEND_OP_COND, 0);
00383A  B81160     MUL.UU W2, #0, W2
00383C  B3C010     MOV.B #0x1, W0
00383E  07FF7C     RCALL _sd_raw_send_command
288:                       }
289:               
290:                       if((response & (1 << R1_IDLE_STATE)) == 0)
003840  600061     AND W0, #0x1, W0
003842  320007     BRA Z, 0x3852
291:                           break;
292:               
293:                       if(i == 0x7fff)
003822  27FFFA     MOV #0x7FFF, W10
003844  540F8A     SUB W8, W10, [W15]
003846  3A0003     BRA NZ, 0x384E
294:                       {
295:                           unselect_card();
003848  A802CD     BSET 0x2CD, #0
296:                           return 0;
00384A  EB4000     CLR.B W0
00384C  370011     BRA 0x3870
297:                       }
298:                   }
003850  37FFE9     BRA 0x3824
299:               
300:               #if SD_RAW_SDHC
301:                   if(sd_raw_card_type & (1 << SD_RAW_SPEC_2))
302:                   {
303:                       if(sd_raw_send_command(CMD_READ_OCR, 0))
304:                       {
305:                           unselect_card();
306:                           return 0;
307:                       }
308:               
309:                       if(sd_raw_rec_byte() & 0x40)
310:                           sd_raw_card_type |= (1 << SD_RAW_SPEC_SDHC);
311:               
312:                       sd_raw_rec_byte();
313:                       sd_raw_rec_byte();
314:                       sd_raw_rec_byte();
315:                   }
316:               #endif
317:               
318:                   /* set block size to 512 bytes */
319:                   if(sd_raw_send_command(CMD_SET_BLOCKLEN, 512))
003852  202002     MOV #0x200, W2
003854  200003     MOV #0x0, W3
003856  B3C100     MOV.B #0x10, W0
003858  07FF6F     RCALL _sd_raw_send_command
00385A  504FE0     SUB.B W0, #0x0, [W15]
00385C  320003     BRA Z, 0x3864
320:                   {
321:                       unselect_card();
00385E  A802CD     BSET 0x2CD, #0
322:                       return 0;
003860  EB4000     CLR.B W0
003862  370006     BRA 0x3870
323:                   }
324:               
325:                   /* deaddress card */
326:                   unselect_card();
003864  A802CD     BSET 0x2CD, #0
327:               
328:                   /* switch to highest SPI frequency possible */
329:               #ifdef __PIC24__
330:                   sdc_spi_disable();
003866  A9E241     BCLR 0x241, #7
331:                   SDC_CON1 |= 0x1e;
003868  2001E0     MOV #0x1E, W0
00386A  B72242     IOR SPI1CON1
332:                   sdc_spi_enable();
00386C  A8E241     BSET 0x241, #7
333:               #else
334:                   SPCR &= ~((1 << SPR1) | (1 << SPR0)); /* Clock Frequency: f_OSC / 4 */
335:                   SPSR |= (1 << SPI2X); /* Doubled Clock Frequency: f_OSC / 2 */
336:               #endif
337:               #if !SD_RAW_SAVE_RAM
338:                   /* the first block is likely to be accessed first, so precache it here */
339:                   raw_block_address = (offset_t) -1;
340:               #if SD_RAW_WRITE_BUFFERING
341:                   raw_block_written = 1;
342:               #endif
343:                   if(!sd_raw_read(0, raw_block, sizeof(raw_block)))
344:                       return 0;
345:               #endif
346:               
347:                   return 1;
00386E  B3C010     MOV.B #0x1, W0
348:               }
003870  78054F     MOV [--W15], W10
003872  BE044F     MOV.D [--W15], W8
003874  060000     RETURN
349:               
350:               /**
351:                * \ingroup sd_raw
352:                * Checks wether a memory card is located in the slot.
353:                *
354:                * \returns 1 if the card is available, 0 if it is not.
355:                */
356:               uint8_t sd_raw_available()
357:               {
358:                   return get_pin_available() == 0x00;
003790  801650     MOV PORTB, W0
003792  600068     AND W0, #0x8, W0
003794  E90000     DEC W0, W0
003796  DE004F     LSR W0, #15, W0
359:               }
003798  060000     RETURN
360:               
361:               #if SD_RAW_WRITE_SUPPORT
362:               /**
363:                * \ingroup sd_raw
364:                * Checks wether the memory card is locked for write access.
365:                *
366:                * \returns 1 if the card is locked, 0 if it is not.
367:                */
368:               uint8_t sd_raw_locked()
369:               {
370:                   return get_pin_locked() == 0x00;
371:               }
372:               #endif
373:               
374:               /**
375:                * \ingroup sd_raw
376:                * Sends a raw byte to the memory card.
377:                *
378:                * \param[in] b The byte to sent.
379:                * \see sd_raw_rec_byte
380:                */
381:               void sd_raw_send_byte(uint8_t b)
382:               {
383:               #ifdef __PIC24__
384:                   uint8_t discard;
385:                   discard=SDC_BUF; // reset SDC_RBF bit in SPIxSTAT
00371E  801244     MOV SPI1BUF, W4
386:                   SDC_BUF=b;
003720  FB8000     ZE W0, W0
003722  881240     MOV W0, SPI1BUF
387:                   while (!SDC_RBF);
003724  AB0240     BTST SPI1STAT, #0
003726  32FFFE     BRA Z, 0x3724
388:               #else
389:                   SPDR = b;
390:                   /* wait for byte to be shifted out */
391:                   while(!(SPSR & (1 << SPIF)));
392:                   SPSR &= ~(1 << SPIF);
393:               #endif
394:               }
003728  060000     RETURN
395:               
396:               /**
397:                * \ingroup sd_raw
398:                * Receives a raw byte from the memory card.
399:                *
400:                * \returns The byte which should be read.
401:                * \see sd_raw_send_byte
402:                */
403:               uint8_t sd_raw_rec_byte()
404:               {
405:                   /* send dummy data for receiving some */
406:               #ifdef __PIC24__
407:                   uint8_t discard;
408:                   discard=SDC_BUF; // reset SDC_RBF bit
00372A  801244     MOV SPI1BUF, W4
409:                   SDC_BUF=0xff;
00372C  200FF4     MOV #0xFF, W4
00372E  881244     MOV W4, SPI1BUF
410:                   while (!SDC_RBF);
003730  AB0240     BTST SPI1STAT, #0
003732  32FFFE     BRA Z, 0x3730
411:                   return SDC_BUF;
003734  801240     MOV SPI1BUF, W0
412:               #else
413:                   SPDR = 0xff;
414:                   while(!(SPSR & (1 << SPIF)));
415:                   SPSR &= ~(1 << SPIF);
416:               
417:                   return SPDR;
418:               #endif
419:               }
003736  060000     RETURN
420:               
421:               /**
422:                * \ingroup sd_raw
423:                * Send a command to the memory card which responses with a R1 response (and possibly others).
424:                *
425:                * \param[in] command The command to send.
426:                * \param[in] arg The argument for command.
427:                * \returns The command answer.
428:                */
429:               uint8_t sd_raw_send_command(uint8_t command, uint32_t arg)
430:               {
003738  BE9F88     MOV.D W8, [W15++]
00373A  781F8A     MOV W10, [W15++]
00373C  784500     MOV.B W0, W10
00373E  BE0402     MOV.D W2, W8
003770  B3C0A8     MOV.B #0xA, W8
003772  370006     BRA 0x3780
431:                   uint8_t response;
432:               
433:                   /* wait some clock cycles */
434:                   sd_raw_rec_byte();
003740  07FFF4     RCALL _sd_raw_rec_byte
435:               
436:                   /* send command via SPI */
437:                   sd_raw_send_byte(0x40 | command);
003742  78400A     MOV.B W10, W0
003744  A06400     BSET.B W0, #6
003746  07FFEB     RCALL _sd_raw_send_byte
438:                   sd_raw_send_byte((arg >> 24) & 0xff);
003748  DE4848     LSR W9, #8, W0
00374A  200001     MOV #0x0, W1
00374C  07FFE8     RCALL _sd_raw_send_byte
439:                   sd_raw_send_byte((arg >> 16) & 0xff);
00374E  DE4840     LSR W9, #0, W0
003750  200001     MOV #0x0, W1
003752  07FFE5     RCALL _sd_raw_send_byte
440:                   sd_raw_send_byte((arg >> 8) & 0xff);
003754  DD4A48     SL W9, #8, W4
003756  DE4048     LSR W8, #8, W0
003758  720000     IOR W4, W0, W0
00375A  DE48C8     LSR W9, #8, W1
00375C  07FFE0     RCALL _sd_raw_send_byte
441:                   sd_raw_send_byte((arg >> 0) & 0xff);
00375E  784008     MOV.B W8, W0
003760  07FFDE     RCALL _sd_raw_send_byte
442:                   switch(command)
003762  554FE0     SUB.B W10, #0x0, [W15]
003764  320003     BRA Z, 0x376C
003766  554FE8     SUB.B W10, #0x8, [W15]
003768  3A0008     BRA NZ, 0x377A
00376A  370004     BRA 0x3774
443:                   {
444:                       case CMD_GO_IDLE_STATE:
445:                          sd_raw_send_byte(0x95);
00376C  B3C950     MOV.B #0x95, W0
00376E  07FFD7     RCALL _sd_raw_send_byte
446:                          break;
447:                       case CMD_SEND_IF_COND:
448:                          sd_raw_send_byte(0x87);
003774  B3C870     MOV.B #0x87, W0
003776  07FFD3     RCALL _sd_raw_send_byte
449:                          break;
003778  37FFFB     BRA 0x3770
450:                       default:
451:                          sd_raw_send_byte(0xff);
00377A  EBC000     SETM.B W0
00377C  07FFD0     RCALL _sd_raw_send_byte
452:                          break;
00377E  37FFF8     BRA 0x3770
453:                   }
454:                   
455:                   /* receive response */
456:                   uint8_t i;
457:                   for(i = 0; i < 10; ++i)
003788  3AFFFB     BRA NZ, 0x3780
458:                   {
459:                       response = sd_raw_rec_byte();
003780  07FFD4     RCALL _sd_raw_rec_byte
460:                       if(response != 0xff)
003782  404FE1     ADD.B W0, #0x1, [W15]
003784  3A0002     BRA NZ, 0x378A
003786  E94408     DEC.B W8, W8
461:                           break;
462:                   }
463:               
464:                   return response;
465:               }
00378A  78054F     MOV [--W15], W10
00378C  BE044F     MOV.D [--W15], W8
00378E  060000     RETURN
466:               
467:               /**
468:                * \ingroup sd_raw
469:                * Reads raw data from the card.
470:                *
471:                * \param[in] offset The offset from which to read.
472:                * \param[out] buffer The buffer into which to write the data.
473:                * \param[in] length The number of bytes to read.
474:                * \returns 0 on failure, 1 on success.
475:                * \see sd_raw_read_interval, sd_raw_write, sd_raw_write_interval
476:                */
477:               uint8_t sd_raw_read(offset_t offset, uint8_t* buffer, uintptr_t length)
478:               {
003876  4787E6     ADD W15, #0x6, W15
003878  BE9F88     MOV.D W8, [W15++]
00387A  BE9F8A     MOV.D W10, [W15++]
00387C  BE9F8C     MOV.D W12, [W15++]
00387E  781F8E     MOV W14, [W15++]
003880  BE0400     MOV.D W0, W8
003882  780702     MOV W2, W14
003884  9FB7F3     MOV W3, [W15-18]
479:                   offset_t block_address;
480:                   uint16_t block_offset;
481:                   uint16_t read_length;
482:                   while(length > 0)
003888  780203     MOV W3, W4
00388A  520FE0     SUB W4, #0x0, [W15]
00388C  320032     BRA Z, 0x38F2
0038E8  320003     BRA Z, 0x38F0
483:                   {
484:                       /* determine byte count to read at once */
485:                       block_offset = offset & 0x01ff;
00388E  201FF5     MOV #0x1FF, W5
003890  640585     AND W8, W5, W11
486:                       block_address = offset - block_offset;
003896  54010B     SUB W8, W11, W2
003898  5C81E0     SUBB W9, #0x0, W3
487:                       read_length = 512 - block_offset; /* read up to block border */
0038AE  202004     MOV #0x200, W4
0038B0  52020B     SUB W4, W11, W4
0038B2  9FBF84     MOV W4, [W15-16]
0038B4  97B2FF     MOV [W15-18], W5
0038B6  520F85     SUB W4, W5, [W15]
0038B8  360002     BRA LEU, 0x38BE
0038BA  780005     MOV W5, W0
0038BC  9FBF80     MOV W0, [W15-16]
488:                       if(read_length > length)
489:                           read_length = length;
490:                       
491:               #if !SD_RAW_SAVE_RAM
492:                       /* check if the requested data is cached */
493:                       if(block_address != raw_block_address)
494:               #endif
495:                       {
496:               #if SD_RAW_WRITE_BUFFERING
497:                           if(!sd_raw_sync())
498:                               return 0;
499:               #endif
500:               
501:                           /* address card */
502:                           select_card();
003892  2FEFF0     MOV #0xFEFF, W0
003894  B622CC     AND LATB
503:               
504:                           /* send single block request */
505:               #if SD_RAW_SDHC
506:                           if(sd_raw_send_command(CMD_READ_SINGLE_BLOCK, (sd_raw_card_type & (1 << SD_RAW_SPEC_SDHC) ? block_address / 512 : block_address)))
507:               #else
508:                           if(sd_raw_send_command(CMD_READ_SINGLE_BLOCK, block_address))
00389A  B3C110     MOV.B #0x11, W0
00389C  07FF4D     RCALL _sd_raw_send_command
00389E  504FE0     SUB.B W0, #0x0, [W15]
0038A0  320003     BRA Z, 0x38A8
509:               #endif
510:                           {
511:                               unselect_card();
0038A2  A802CD     BSET 0x2CD, #0
512:                               return 0;
0038A4  EB4000     CLR.B W0
0038A6  370025     BRA 0x38F2
513:                           }
514:               
515:                           /* wait for data block (start byte 0xfe) */
516:                           while(sd_raw_rec_byte() != 0xfe);
0038A8  07FF40     RCALL _sd_raw_rec_byte
0038AA  404FE2     ADD.B W0, #0x2, [W15]
0038AC  3AFFFD     BRA NZ, 0x38A8
517:               
518:               #if SD_RAW_SAVE_RAM
519:                           /* read byte block */
520:                           uint16_t read_to = block_offset + read_length;
0038BE  97BA0F     MOV [W15-16], W4
0038C0  42068B     ADD W4, W11, W13
521:                           uint16_t i;
522:                           for(i = 0; i < 512; ++i)
0038C2  EB0500     CLR W10
0038C4  20200C     MOV #0x200, W12
0038D2  E8050A     INC W10, W10
0038D4  550F8C     SUB W10, W12, [W15]
0038D6  3AFFF7     BRA NZ, 0x38C6
523:                           {
524:                               uint8_t b = sd_raw_rec_byte();
0038C6  07FF31     RCALL _sd_raw_rec_byte
525:                               if(i >= block_offset && i < read_to)
0038C8  558F8A     SUB W11, W10, [W15]
0038CA  3E0003     BRA GTU, 0x38D2
0038CC  568F8A     SUB W13, W10, [W15]
0038CE  360001     BRA LEU, 0x38D2
526:                                   *buffer++ = b;
0038D0  785F00     MOV.B W0, [W14++]
527:                           }
528:               #else
529:                           /* read byte block */
530:                           uint8_t* cache = raw_block;
531:                           for(uint16_t i = 0; i < 512; ++i)
532:                               *cache++ = sd_raw_rec_byte();
533:                           raw_block_address = block_address;
534:               
535:                           memcpy(buffer, raw_block + block_offset, read_length);
536:                           buffer += read_length;
537:               #endif
538:                           
539:                           /* read crc16 */
540:                           sd_raw_rec_byte();
0038D8  07FF28     RCALL _sd_raw_rec_byte
541:                           sd_raw_rec_byte();
0038DA  07FF27     RCALL _sd_raw_rec_byte
542:                           
543:                           /* deaddress card */
544:                           unselect_card();
0038DC  A802CD     BSET 0x2CD, #0
545:               
546:                           /* let card some time to finish */
547:                           sd_raw_rec_byte();
0038DE  07FF25     RCALL _sd_raw_rec_byte
548:                       }
549:               #if !SD_RAW_SAVE_RAM
550:                       else
551:                       {
552:                           /* use cached data */
553:                           memcpy(buffer, raw_block + block_offset, read_length);
554:                           buffer += read_length;
555:                       }
556:               #endif
557:               
558:                       length -= read_length;
0038E0  97B2FF     MOV [W15-18], W5
0038E2  97B80F     MOV [W15-16], W0
0038E4  528280     SUB W5, W0, W5
0038E6  9FB7F5     MOV W5, [W15-18]
559:                       offset += read_length;
0038EA  440400     ADD W8, W0, W8
0038EC  4C84E0     ADDC W9, #0x0, W9
0038EE  37FFCF     BRA 0x388E
560:                   }
561:               
562:                   return 1;
003886  B3C010     MOV.B #0x1, W0
0038F0  B3C010     MOV.B #0x1, W0
563:               }
0038F2  78074F     MOV [--W15], W14
0038F4  BE064F     MOV.D [--W15], W12
0038F6  BE054F     MOV.D [--W15], W10
0038F8  BE044F     MOV.D [--W15], W8
0038FA  B1006F     SUB #0x6, W15
0038FC  060000     RETURN
564:               
565:               /**
566:                * \ingroup sd_raw
567:                * Continuously reads units of \c interval bytes and calls a callback function.
568:                *
569:                * This function starts reading at the specified offset. Every \c interval bytes,
570:                * it calls the callback function with the associated data buffer.
571:                *
572:                * By returning zero, the callback may stop reading.
573:                *
574:                * \note Within the callback function, you can not start another read or
575:                *       write operation.
576:                * \note This function only works if the following conditions are met:
577:                *       - (offset - (offset % 512)) % interval == 0
578:                *       - length % interval == 0
579:                *
580:                * \param[in] offset Offset from which to start reading.
581:                * \param[in] buffer Pointer to a buffer which is at least interval bytes in size.
582:                * \param[in] interval Number of bytes to read before calling the callback function.
583:                * \param[in] length Number of bytes to read altogether.
584:                * \param[in] callback The function to call every interval bytes.
585:                * \param[in] p An opaque pointer directly passed to the callback function.
586:                * \returns 0 on failure, 1 on success
587:                * \see sd_raw_write_interval, sd_raw_read, sd_raw_write
588:                */
589:               uint8_t sd_raw_read_interval(offset_t offset, uint8_t* buffer, uintptr_t interval, uintptr_t length, sd_raw_read_interval_handler_t callback, void* p)
00392A  EA028E     NEG W14, W5
00392C  9FB7D5     MOV W5, [W15-22]
00392E  9FB7EC     MOV W12, [W15-20]
003930  9FB7FD     MOV W13, [W15-18]
003932  780688     MOV W8, W13
003976  52860E     SUB W5, W14, W12
003978  56868E     SUB W13, W14, W13
00397A  202004     MOV #0x200, W4
00397C  520405     SUB W4, W5, W8
00397E  9FAFFA     MOV W10, [W15-34]
003980  9FB78B     MOV W11, [W15-32]
003982  780508     MOV W8, W10
003984  97B59F     MOV [W15-30], W11
003986  37000B     BRA 0x399E
590:               {
0038FE  4787F6     ADD W15, #0x16, W15
003900  BE9F88     MOV.D W8, [W15++]
003902  BE9F8A     MOV.D W10, [W15++]
003904  BE9F8C     MOV.D W12, [W15++]
003906  781F8E     MOV W14, [W15++]
003908  BE0600     MOV.D W0, W12
00390A  9FB792     MOV W2, [W15-30]
00390C  780703     MOV W3, W14
00390E  780404     MOV W4, W8
003910  9FB7C5     MOV W5, [W15-24]
003912  9FB7B6     MOV W6, [W15-26]
591:                   if(!buffer || interval == 0 || length < interval || !callback)
003916  780202     MOV W2, W4
003918  520FE0     SUB W4, #0x0, [W15]
00391A  320086     BRA Z, 0x3A28
00391C  570FE0     SUB W14, #0x0, [W15]
00391E  320084     BRA Z, 0x3A28
003920  570F88     SUB W14, W8, [W15]
003922  3E0082     BRA GTU, 0x3A28
003924  528FE0     SUB W5, #0x0, [W15]
003926  320080     BRA Z, 0x3A28
592:                       return 0;
003914  EB4000     CLR.B W0
593:               
594:               #if !SD_RAW_SAVE_RAM
595:                   while(length >= interval)
596:                   {
597:                       /* as reading is now buffered, we directly
598:                        * hand over the request to sd_raw_read()
599:                        */
600:                       if(!sd_raw_read(offset, buffer, interval))
601:                           return 0;
602:                       if(!callback(buffer, offset, p))
603:                           break;
604:                       offset += interval;
605:                       length -= interval;
606:                   }
607:               
608:                   return 1;
609:               #else
610:                   /* address card */
611:                   select_card();
003928  A902CD     BCLR 0x2CD, #0
612:               
613:                   uint16_t block_offset;
614:                   uint16_t read_length;
615:                   uint8_t* buffer_cur;
616:                   uint8_t finished = 0;
617:                   do
618:                   {
619:                       /* determine byte count to read at once */
620:                       block_offset = offset & 0x01ff;
003934  97B2EF     MOV [W15-20], W5
003936  201FF4     MOV #0x1FF, W4
003938  628484     AND W5, W4, W9
621:                       read_length = 512 - block_offset;
003966  202008     MOV #0x200, W8
003968  540409     SUB W8, W9, W8
00396A  9FBF88     MOV W8, [W15-16]
622:                       
623:                       /* send single block request */
624:               #if SD_RAW_SDHC
625:                       if(sd_raw_send_command(CMD_READ_SINGLE_BLOCK, (sd_raw_card_type & (1 << SD_RAW_SPEC_SDHC) ? offset / 512 : offset - block_offset)))
626:               #else
627:                       if(sd_raw_send_command(CMD_READ_SINGLE_BLOCK, offset - block_offset))
00393A  97B26F     MOV [W15-20], W4
00393C  97B2FF     MOV [W15-18], W5
00393E  520509     SUB W4, W9, W10
003940  5A85E0     SUBB W5, #0x0, W11
003942  BE010A     MOV.D W10, W2
003944  B3C110     MOV.B #0x11, W0
003946  07FEF8     RCALL _sd_raw_send_command
003948  504FE0     SUB.B W0, #0x0, [W15]
00394A  320003     BRA Z, 0x3952
628:               #endif
629:                       {
630:                           unselect_card();
00394C  A802CD     BSET 0x2CD, #0
631:                           return 0;
00394E  EB4000     CLR.B W0
003950  37006B     BRA 0x3A28
632:                       }
633:               
634:                       /* wait for data block (start byte 0xfe) */
635:                       while(sd_raw_rec_byte() != 0xfe);
003952  07FEEB     RCALL _sd_raw_rec_byte
003954  404FE2     ADD.B W0, #0x2, [W15]
003956  3AFFFD     BRA NZ, 0x3952
636:               
637:                       /* read up to the data of interest */
638:                       uint16_t i;
639:                       for(i = 0; i < block_offset; ++i)
003958  548FE0     SUB W9, #0x0, [W15]
00395A  320005     BRA Z, 0x3966
00395C  EB0400     CLR W8
003960  E80408     INC W8, W8
003962  548F88     SUB W9, W8, [W15]
003964  3EFFFC     BRA GTU, 0x395E
640:                           sd_raw_rec_byte();
00395E  07FEE5     RCALL _sd_raw_rec_byte
641:               
642:                       /* read interval bytes of data and execute the callback */
643:                       do
644:                       {
645:                           if(read_length < interval || length < interval)
00396C  780288     MOV W8, W5
00396E  570F85     SUB W14, W5, [W15]
003970  3E001D     BRA GTU, 0x39AC
003972  568F8E     SUB W13, W14, [W15]
003974  39001E     BRA NC, 0x39B2
003988  570F8C     SUB W14, W12, [W15]
00398A  3E0054     BRA GTU, 0x3A34
00398C  97B2DF     MOV [W15-22], W5
00398E  460305     ADD W12, W5, W6
003990  468205     ADD W13, W5, W4
003992  45050E     ADD W10, W14, W10
003994  42028E     ADD W4, W14, W5
003996  570F85     SUB W14, W5, [W15]
003998  3E0050     BRA GTU, 0x3A3A
00399A  780684     MOV W4, W13
00399C  780606     MOV W6, W12
00399E  46020E     ADD W12, W14, W4
0039A0  9FBF84     MOV W4, [W15-16]
0039A2  46828E     ADD W13, W14, W5
0039A4  9FB7A5     MOV W5, [W15-28]
0039A6  78048B     MOV W11, W9
0039A8  EB0400     CLR W8
0039AA  37000E     BRA 0x39C8
0039AC  9FB7AD     MOV W13, [W15-28]
0039AE  EB4480     CLR.B W9
0039B0  370006     BRA 0x39BE
0039B2  9FB7AD     MOV W13, [W15-28]
0039B4  EB4480     CLR.B W9
0039B6  370003     BRA 0x39BE
0039B8  97AD7F     MOV [W15-34], W10
0039BA  97B58F     MOV [W15-32], W11
646:                               break;
647:               
648:                           buffer_cur = buffer;
649:                           uint16_t i;
650:                           for(i = 0; i < interval; ++i)
0039CC  E80408     INC W8, W8
0039CE  570F88     SUB W14, W8, [W15]
0039D0  3EFFFB     BRA GTU, 0x39C8
651:                               *buffer_cur++ = sd_raw_rec_byte();
0039C8  07FEB0     RCALL _sd_raw_rec_byte
0039CA  785C80     MOV.B W0, [W9++]
652:               
653:                           if(!callback(buffer, offset + (512 - read_length), p))
0039D2  97B26F     MOV [W15-20], W4
0039D4  97B2FF     MOV [W15-18], W5
0039D6  42010A     ADD W4, W10, W2
0039D8  4A81E0     ADDC W5, #0x0, W3
0039DA  97B0BF     MOV [W15-26], W1
0039DC  78000B     MOV W11, W0
0039DE  97B2CF     MOV [W15-24], W5
0039E0  010005     CALL W5
0039E2  504FE0     SUB.B W0, #0x0, [W15]
0039E4  32FFE9     BRA Z, 0x39B8
654:                           {
655:                               finished = 1;
0039BC  B3C019     MOV.B #0x1, W9
656:                               break;
657:                           }
658:               
659:                           read_length -= interval;
660:                           length -= interval;
661:               
662:                       } while(read_length > 0 && length > 0);
0039E6  560FE0     SUB W12, #0x0, [W15]
0039E8  32000D     BRA Z, 0x3A04
0039EA  568FE0     SUB W13, #0x0, [W15]
0039EC  3AFFCD     BRA NZ, 0x3988
0039EE  97AD7F     MOV [W15-34], W10
0039F0  97B58F     MOV [W15-32], W11
0039F2  370025     BRA 0x3A3E
003A08  EB4480     CLR.B W9
663:                       
664:                       /* read rest of data block */
665:                       while(read_length-- > 0)
0039BE  97BA0F     MOV [W15-16], W4
0039C0  520FE0     SUB W4, #0x0, [W15]
0039C2  3A0018     BRA NZ, 0x39F4
0039C4  97B6AF     MOV [W15-28], W13
0039C6  370021     BRA 0x3A0A
0039F4  97BA0F     MOV [W15-16], W4
0039F6  E90404     DEC W4, W8
0039F8  97B6AF     MOV [W15-28], W13
0039FC  E90408     DEC W8, W8
0039FE  440FE1     ADD W8, #0x1, [W15]
003A00  3AFFFC     BRA NZ, 0x39FA
003A02  370003     BRA 0x3A0A
003A04  97AD7F     MOV [W15-34], W10
003A06  97B58F     MOV [W15-32], W11
003A3E  E9040C     DEC W12, W8
003A40  EB4480     CLR.B W9
003A42  37FFDB     BRA 0x39FA
666:                           sd_raw_rec_byte();
0039FA  07FE97     RCALL _sd_raw_rec_byte
667:                       
668:                       /* read crc16 */
669:                       sd_raw_rec_byte();
003A0A  07FE8F     RCALL _sd_raw_rec_byte
670:                       sd_raw_rec_byte();
003A0C  07FE8E     RCALL _sd_raw_rec_byte
671:               
672:                       if(length < interval)
003A0E  570F8D     SUB W14, W13, [W15]
003A10  3E0008     BRA GTU, 0x3A22
673:                           break;
674:               
675:                       offset = offset - block_offset + 512;
003A16  BE020A     MOV.D W10, W4
003A18  B02004     ADD #0x200, W4
003A1A  B08005     ADDC #0x0, W5
003A1C  9FB7E4     MOV W4, [W15-20]
003A1E  9FB7F5     MOV W5, [W15-18]
003A20  37FF89     BRA 0x3934
676:               
677:                   } while(!finished);
003A12  54CFE0     SUB.B W9, #0x0, [W15]
003A14  3A0006     BRA NZ, 0x3A22
678:                   
679:                   /* deaddress card */
680:                   unselect_card();
003A22  A802CD     BSET 0x2CD, #0
681:               
682:                   /* let card some time to finish */
683:                   sd_raw_rec_byte();
003A24  07FE82     RCALL _sd_raw_rec_byte
684:               
685:                   return 1;
003A26  B3C010     MOV.B #0x1, W0
686:               #endif
687:               }
003A28  78074F     MOV [--W15], W14
003A2A  BE064F     MOV.D [--W15], W12
003A2C  BE054F     MOV.D [--W15], W10
003A2E  BE044F     MOV.D [--W15], W8
003A30  B1016F     SUB #0x16, W15
003A32  060000     RETURN
003A34  97AD7F     MOV [W15-34], W10
003A36  97B58F     MOV [W15-32], W11
003A38  370002     BRA 0x3A3E
003A3A  97AD7F     MOV [W15-34], W10
003A3C  97B58F     MOV [W15-32], W11
688:               
689:               #if DOXYGEN || SD_RAW_WRITE_SUPPORT
690:               /**
691:                * \ingroup sd_raw
692:                * Writes raw data to the card.
693:                *
694:                * \note If write buffering is enabled, you might have to
695:                *       call sd_raw_sync() before disconnecting the card
696:                *       to ensure all remaining data has been written.
697:                *
698:                * \param[in] offset The offset where to start writing.
699:                * \param[in] buffer The buffer containing the data to be written.
700:                * \param[in] length The number of bytes to write.
701:                * \returns 0 on failure, 1 on success.
702:                * \see sd_raw_write_interval, sd_raw_read, sd_raw_read_interval
703:                */
704:               uint8_t sd_raw_write(offset_t offset, const uint8_t* buffer, uintptr_t length)
705:               {
706:                   if(sd_raw_locked())
707:                       return 0;
708:               
709:                   offset_t block_address;
710:                   uint16_t block_offset;
711:                   uint16_t write_length;
712:                   while(length > 0)
713:                   {
714:                       /* determine byte count to write at once */
715:                       block_offset = offset & 0x01ff;
716:                       block_address = offset - block_offset;
717:                       write_length = 512 - block_offset; /* write up to block border */
718:                       if(write_length > length)
719:                           write_length = length;
720:                       
721:                       /* Merge the data to write with the content of the block.
722:                        * Use the cached block if available.
723:                        */
724:                       if(block_address != raw_block_address)
725:                       {
726:               #if SD_RAW_WRITE_BUFFERING
727:                           if(!sd_raw_sync())
728:                               return 0;
729:               #endif
730:               
731:                           if(block_offset || write_length < 512)
732:                           {
733:                               if(!sd_raw_read(block_address, raw_block, sizeof(raw_block)))
734:                                   return 0;
735:                           }
736:                           raw_block_address = block_address;
737:                       }
738:               
739:                       if(buffer != raw_block)
740:                       {
741:                           memcpy(raw_block + block_offset, buffer, write_length);
742:               
743:               #if SD_RAW_WRITE_BUFFERING
744:                           raw_block_written = 0;
745:               
746:                           if(length == write_length)
747:                               return 1;
748:               #endif
749:                       }
750:               
751:                       /* address card */
752:                       select_card();
753:               
754:                       /* send single block request */
755:               #if SD_RAW_SDHC
756:                       if(sd_raw_send_command(CMD_WRITE_SINGLE_BLOCK, (sd_raw_card_type & (1 << SD_RAW_SPEC_SDHC) ? block_address / 512 : block_address)))
757:               #else
758:                       if(sd_raw_send_command(CMD_WRITE_SINGLE_BLOCK, block_address))
759:               #endif
760:                       {
761:                           unselect_card();
762:                           return 0;
763:                       }
764:               
765:                       /* send start byte */
766:                       sd_raw_send_byte(0xfe);
767:               
768:                       /* write byte block */
769:                       uint8_t* cache = raw_block;
770:                       for(uint16_t i = 0; i < 512; ++i)
771:                           sd_raw_send_byte(*cache++);
772:               
773:                       /* write dummy crc16 */
774:                       sd_raw_send_byte(0xff);
775:                       sd_raw_send_byte(0xff);
776:               
777:                       /* wait while card is busy */
778:                       while(sd_raw_rec_byte() != 0xff);
779:                       sd_raw_rec_byte();
780:               
781:                       /* deaddress card */
782:                       unselect_card();
783:               
784:                       buffer += write_length;
785:                       offset += write_length;
786:                       length -= write_length;
787:               
788:               #if SD_RAW_WRITE_BUFFERING
789:                       raw_block_written = 1;
790:               #endif
791:                   }
792:               
793:                   return 1;
794:               }
795:               #endif
796:               
797:               #if DOXYGEN || SD_RAW_WRITE_SUPPORT
798:               /**
799:                * \ingroup sd_raw
800:                * Writes a continuous data stream obtained from a callback function.
801:                *
802:                * This function starts writing at the specified offset. To obtain the
803:                * next bytes to write, it calls the callback function. The callback fills the
804:                * provided data buffer and returns the number of bytes it has put into the buffer.
805:                *
806:                * By returning zero, the callback may stop writing.
807:                *
808:                * \param[in] offset Offset where to start writing.
809:                * \param[in] buffer Pointer to a buffer which is used for the callback function.
810:                * \param[in] length Number of bytes to write in total. May be zero for endless writes.
811:                * \param[in] callback The function used to obtain the bytes to write.
812:                * \param[in] p An opaque pointer directly passed to the callback function.
813:                * \returns 0 on failure, 1 on success
814:                * \see sd_raw_read_interval, sd_raw_write, sd_raw_read
815:                */
816:               uint8_t sd_raw_write_interval(offset_t offset, uint8_t* buffer, uintptr_t length, sd_raw_write_interval_handler_t callback, void* p)
817:               {
818:               #if SD_RAW_SAVE_RAM
819:                   #error "SD_RAW_WRITE_SUPPORT is not supported together with SD_RAW_SAVE_RAM"
820:               #endif
821:               
822:                   if(!buffer || !callback)
823:                       return 0;
824:               
825:                   uint8_t endless = (length == 0);
826:                   while(endless || length > 0)
827:                   {
828:                       uint16_t bytes_to_write = callback(buffer, offset, p);
829:                       if(!bytes_to_write)
830:                           break;
831:                       if(!endless && bytes_to_write > length)
832:                           return 0;
833:               
834:                       /* as writing is always buffered, we directly
835:                        * hand over the request to sd_raw_write()
836:                        */
837:                       if(!sd_raw_write(offset, buffer, bytes_to_write))
838:                           return 0;
839:               
840:                       offset += bytes_to_write;
841:                       length -= bytes_to_write;
842:                   }
843:               
844:                   return 1;
845:               }
846:               #endif
847:               
848:               #if DOXYGEN || SD_RAW_WRITE_SUPPORT
849:               /**
850:                * \ingroup sd_raw
851:                * Writes the write buffer's content to the card.
852:                *
853:                * \note When write buffering is enabled, you should
854:                *       call this function before disconnecting the
855:                *       card to ensure all remaining data has been
856:                *       written.
857:                *
858:                * \returns 0 on failure, 1 on success.
859:                * \see sd_raw_write
860:                */
861:               uint8_t sd_raw_sync()
862:               {
863:               #if SD_RAW_WRITE_BUFFERING
864:                   if(raw_block_written)
865:                       return 1;
866:                   if(!sd_raw_write(raw_block_address, raw_block, sizeof(raw_block)))
867:                       return 0;
868:                   raw_block_written = 1;
869:               #endif
870:                   return 1;
871:               }
872:               #endif
873:               
874:               /**
875:                * \ingroup sd_raw
876:                * Reads informational data from the card.
877:                *
878:                * This function reads and returns the card's registers
879:                * containing manufacturing and status information.
880:                *
881:                * \note: The information retrieved by this function is
882:                *        not required in any way to operate on the card,
883:                *        but it might be nice to display some of the data
884:                *        to the user.
885:                *
886:                * \param[in] info A pointer to the structure into which to save the information.
887:                * \returns 0 on failure, 1 on success.
888:                */
889:               uint8_t sd_raw_get_info(struct sd_raw_info* info)
890:               {
003A44  4787E6     ADD W15, #0x6, W15
003A46  BE9F88     MOV.D W8, [W15++]
003A48  BE9F8A     MOV.D W10, [W15++]
003A4A  BE9F8C     MOV.D W12, [W15++]
003A4C  781F8E     MOV W14, [W15++]
003A4E  780580     MOV W0, W11
891:                   if(!info || !sd_raw_available())
003A52  558FE0     SUB W11, #0x0, [W15]
003A54  3200D4     BRA Z, 0x3BFE
003A56  07FE9C     RCALL sd_raw_available
003A58  784200     MOV.B W0, W4
003A5C  524F80     SUB.B W4, W0, [W15]
003A5E  3200CF     BRA Z, 0x3BFE
892:                       return 0;
003A50  EB4000     CLR.B W0
003A5A  EB4000     CLR.B W0
893:               
894:                   memset(info, 0, sizeof(*info));
003A60  09000C     REPEAT #0xC
003A62  EB1D80     CLR [W11++]
003A64  B101AB     SUB #0x1A, W11
895:               
896:                   select_card();
003A66  A902CD     BCLR 0x2CD, #0
897:               
898:                   /* read cid register */
899:                   if(sd_raw_send_command(CMD_SEND_CID, 0))
003A68  B81160     MUL.UU W2, #0, W2
003A6A  B3C0A0     MOV.B #0xA, W0
003A6C  07FE65     RCALL _sd_raw_send_command
003A6E  504FE0     SUB.B W0, #0x0, [W15]
003A70  320003     BRA Z, 0x3A78
900:                   {
901:                       unselect_card();
003A72  A802CD     BSET 0x2CD, #0
902:                       return 0;
003A74  EB4000     CLR.B W0
003A76  3700C3     BRA 0x3BFE
903:                   }
904:                   while(sd_raw_rec_byte() != 0xfe);
003A78  07FE58     RCALL _sd_raw_rec_byte
003A7A  404FE2     ADD.B W0, #0x2, [W15]
003A7C  3AFFFD     BRA NZ, 0x3A78
003A7E  B3C018     MOV.B #0x1, W8
003A88  E84408     INC.B W8, W8
003A8A  E94488     DEC.B W8, W9
905:                   uint8_t i;
906:                   for(i = 0; i < 18; ++i)
003B06  544FF1     SUB.B W8, #0x11, [W15]
003B08  36FFBF     BRA LEU, 0x3A88
907:                   {
908:                       uint8_t b = sd_raw_rec_byte();
003A8C  07FE4E     RCALL _sd_raw_rec_byte
909:               
910:                       switch(i)
003A80  2000EC     MOV #0xE, W12
003A82  20000D     MOV #0x0, W13
003A8E  FB8209     ZE W9, W4
003A90  200005     MOV #0x0, W5
003A92  520F8C     SUB W4, W12, [W15]
003A94  5A8F8D     SUBB W5, W13, [W15]
003A96  3E0037     BRA GTU, 0x3B06
003A98  016004     BRA W4
003A9A  37000E     BRA 0x3AB8
003A9C  37000F     BRA 0x3ABC
003A9E  37000E     BRA 0x3ABC
003AA0  370010     BRA 0x3AC2
003AA2  37000F     BRA 0x3AC2
003AA4  37000E     BRA 0x3AC2
003AA6  37000D     BRA 0x3AC2
003AA8  37000C     BRA 0x3AC2
003AAA  37000F     BRA 0x3ACA
003AAC  370010     BRA 0x3ACE
003AAE  37000F     BRA 0x3ACE
003AB0  37000E     BRA 0x3ACE
003AB2  37000D     BRA 0x3ACE
003AB4  37001D     BRA 0x3AF0
003AB6  37001F     BRA 0x3AF6
911:                       {
912:                           case 0:
913:                               info->manufacturer = b;
003AB8  784D80     MOV.B W0, [W11]
914:                               break;
003ABA  37FFE6     BRA 0x3A88
915:                           case 1:
916:                           case 2:
917:                               info->oem[i - 1] = b;
003ABC  FB8489     ZE W9, W9
003ABE  7CF580     MOV.B W0, [W11+W9]
918:                               break;
003AC0  370022     BRA 0x3B06
919:                           case 3:
920:                           case 4:
921:                           case 5:
922:                           case 6:
923:                           case 7:
924:                               info->product[i - 3] = b;
003AC2  FB8489     ZE W9, W9
003AC4  458489     ADD W11, W9, W9
003AC6  984490     MOV.B W0, [W9+1]
925:                               break;
003AC8  37001E     BRA 0x3B06
926:                           case 8:
927:                               info->revision = b;
003ACA  984DA0     MOV.B W0, [W11+10]
928:                               break;
003ACC  37FFDD     BRA 0x3A88
929:                           case 9:
930:                           case 10:
931:                           case 11:
932:                           case 12:
933:                               info->serial |= (uint32_t) b << ((12 - i) * 8);
003ACE  FB8000     ZE W0, W0
003AD0  200001     MOV #0x0, W1
003AD2  FB8489     ZE W9, W9
003AD4  1484EC     SUBR W9, #0xC, W9
003AD6  DD4CC3     SL W9, #3, W9
003AD8  E90489     DEC W9, W9
003ADA  330003     BRA N, 0x3AE2
003ADC  400000     ADD W0, W0, W0
003ADE  488081     ADDC W1, W1, W1
003AE0  37FFFB     BRA 0x3AD8
003AE2  90026B     MOV [W11+12], W4
003AE4  9002FB     MOV [W11+14], W5
003AE6  720000     IOR W4, W0, W0
003AE8  728081     IOR W5, W1, W1
003AEA  9805E0     MOV W0, [W11+12]
003AEC  9805F1     MOV W1, [W11+14]
934:                               break;
003AEE  37000B     BRA 0x3B06
935:                           case 13:
936:                               info->manufacturing_year = b << 4;
003A84  20004A     MOV #0x4, W10
003A86  370001     BRA 0x3A8A
003AF0  DD000A     SL W0, W10, W0
003AF2  985580     MOV.B W0, [W11+16]
937:                               break;
003AF4  37FFC9     BRA 0x3A88
938:                           case 14:
939:                               info->manufacturing_year |= b >> 4;
003AF6  FB8200     ZE W0, W4
003AF8  DE2244     LSR W4, #4, W4
003AFA  90528B     MOV.B [W11+16], W5
003AFC  72C204     IOR.B W5, W4, W4
003AFE  985584     MOV.B W4, [W11+16]
940:                               info->manufacturing_month = b & 0x0f;
003B00  60406F     AND.B W0, #0xF, W0
003B02  985590     MOV.B W0, [W11+17]
003B04  37FFC1     BRA 0x3A88
941:                               break;
942:                       }
943:                   }
944:               
945:                   /* read csd register */
946:                   uint8_t csd_read_bl_len = 0;
947:                   uint8_t csd_c_size_mult = 0;
948:               #if SD_RAW_SDHC
949:                   uint16_t csd_c_size = 0;
950:               #else
951:                   uint32_t csd_c_size = 0;
952:               #endif
953:                   uint8_t csd_structure = 0;
954:                   if(sd_raw_send_command(CMD_SEND_CSD, 0))
003B0A  B81160     MUL.UU W2, #0, W2
003B0C  B3C090     MOV.B #0x9, W0
003B0E  07FE14     RCALL _sd_raw_send_command
003B10  504FE0     SUB.B W0, #0x0, [W15]
003B12  320003     BRA Z, 0x3B1A
955:                   {
956:                       unselect_card();
003B14  A802CD     BSET 0x2CD, #0
957:                       return 0;
003B16  EB4000     CLR.B W0
003B18  370072     BRA 0x3BFE
958:                   }
959:                   while(sd_raw_rec_byte() != 0xfe);
003B1A  07FE07     RCALL _sd_raw_rec_byte
003B1C  404FE2     ADD.B W0, #0x2, [W15]
003B1E  3AFFFD     BRA NZ, 0x3B1A
003B20  B3C019     MOV.B #0x1, W9
003B22  EB0500     CLR W10
003B24  B82260     MUL.UU W4, #0, W4
003B26  9FB7F4     MOV W4, [W15-18]
003B28  9FBF85     MOV W5, [W15-16]
003B2A  78460A     MOV.B W10, W12
003B2C  78468A     MOV.B W10, W13
003B32  E8050A     INC W10, W10
003B34  E84489     INC.B W9, W9
960:                   for(i = 0; i < 18; ++i)
003BF6  54CFF1     SUB.B W9, #0x11, [W15]
003BF8  36FF9C     BRA LEU, 0x3B32
961:                   {
962:                       uint8_t b = sd_raw_rec_byte();
003B36  07FDF9     RCALL _sd_raw_rec_byte
963:               
964:                       if(i == 0)
003B38  554FE0     SUB.B W10, #0x0, [W15]
003B3A  32FFFB     BRA Z, 0x3B32
965:                       {
966:                           csd_structure = b >> 6;
967:                       }
968:                       else if(i == 14)
003B3C  554FEE     SUB.B W10, #0xE, [W15]
003B3E  3A0013     BRA NZ, 0x3B66
969:                       {
970:                           if(b & 0x40)
003B40  FB8000     ZE W0, W0
003B42  780200     MOV W0, W4
003B44  B20404     AND #0x40, W4
003B46  320002     BRA Z, 0x3B4C
971:                               info->flag_copy = 1;
003B48  B3C014     MOV.B #0x1, W4
003B4A  9855E4     MOV.B W4, [W11+22]
972:                           if(b & 0x20)
003B4C  780200     MOV W0, W4
003B4E  B20204     AND #0x20, W4
003B50  320002     BRA Z, 0x3B56
973:                               info->flag_write_protect = 1;
003B52  B3C014     MOV.B #0x1, W4
003B54  9855F4     MOV.B W4, [W11+23]
974:                           if(b & 0x10)
003B56  600270     AND W0, #0x10, W4
003B58  320002     BRA Z, 0x3B5E
975:                               info->flag_write_protect_temp = 1;
003B5A  B3C014     MOV.B #0x1, W4
003B5C  985D84     MOV.B W4, [W11+24]
976:                           info->format = (b & 0x0c) >> 2;
003B5E  60006C     AND W0, #0xC, W0
003B60  DE8042     ASR W0, #2, W0
003B62  985D90     MOV.B W0, [W11+25]
003B64  370048     BRA 0x3BF6
977:                       }
978:                       else
979:                       {
980:               #if SD_RAW_SDHC
981:                           if(csd_structure == 0x01)
982:                           {
983:                               switch(i)
984:                               {
985:                                   case 7:
986:                                       b &= 0x3f;
987:                                   case 8:
988:                                   case 9:
989:                                       csd_c_size <<= 8;
990:                                       csd_c_size |= b;
991:                                       break;
992:                               }
993:                               if(i == 9)
994:                               {
995:                                   ++csd_c_size;
996:                                   info->capacity = (offset_t) csd_c_size * 512 * 1024;
997:                               }
998:                           }
999:                           else if(csd_structure == 0x00)
1000:              #endif
1001:                          {
1002:                              switch(i)
003B66  FB820A     ZE W10, W4
003B68  200005     MOV #0x0, W5
003B6A  520265     SUB W4, #0x5, W4
003B6C  5A82E0     SUBB W5, #0x0, W5
003B6E  520FE5     SUB W4, #0x5, [W15]
003B70  5A8FE0     SUBB W5, #0x0, [W15]
003B72  3E0041     BRA GTU, 0x3BF6
003B74  016004     BRA W4
003B76  370005     BRA 0x3B82
003B78  370006     BRA 0x3B86
003B7A  37000E     BRA 0x3B98
003B7C  37001A     BRA 0x3BB2
003B7E  370026     BRA 0x3BCC
003B80  370028     BRA 0x3BD2
1003:                              {
1004:                                  case 5:
1005:                                      csd_read_bl_len = b & 0x0f;
003B82  6046EF     AND.B W0, #0xF, W13
1006:                                      break;
003B84  37FFD6     BRA 0x3B32
1007:                                  case 6:
1008:                                      csd_c_size = b & 0x03;
003B2E  20003E     MOV #0x3, W14
003B30  370002     BRA 0x3B36
003B86  670000     AND W14, W0, W0
003B88  200001     MOV #0x0, W1
1009:                                      csd_c_size <<= 8;
003B8A  DD0B48     SL W1, #8, W6
003B8C  DE03C8     LSR W0, #8, W7
003B8E  730387     IOR W6, W7, W7
003B90  DD0348     SL W0, #8, W6
003B92  9FB7F6     MOV W6, [W15-18]
003B94  9FBF87     MOV W7, [W15-16]
1010:                                      break;
003B96  37FFCD     BRA 0x3B32
1011:                                  case 7:
1012:                                      csd_c_size |= b;
003B98  FB8000     ZE W0, W0
003B9A  200001     MOV #0x0, W1
003B9C  97B27F     MOV [W15-18], W4
003B9E  97BA8F     MOV [W15-16], W5
003BA0  700004     IOR W0, W4, W0
003BA2  708085     IOR W1, W5, W1
1013:                                      csd_c_size <<= 2;
003BA4  DD0B42     SL W1, #2, W6
003BA6  DE03CE     LSR W0, #14, W7
003BA8  730387     IOR W6, W7, W7
003BAA  DD0342     SL W0, #2, W6
003BAC  9FB7F6     MOV W6, [W15-18]
003BAE  9FBF87     MOV W7, [W15-16]
1014:                                      break;
003BB0  37FFC0     BRA 0x3B32
1015:                                  case 8:
1016:                                      csd_c_size |= b >> 6;
003BB2  FB8200     ZE W0, W4
003BB4  DE2246     LSR W4, #6, W4
003BB6  FB8204     ZE W4, W4
003BB8  200005     MOV #0x0, W5
003BBA  97B37F     MOV [W15-18], W6
003BBC  97BB8F     MOV [W15-16], W7
003BBE  720206     IOR W4, W6, W4
003BC0  728287     IOR W5, W7, W5
1017:                                      ++csd_c_size;
003BC2  420361     ADD W4, #0x1, W6
003BC4  4A83E0     ADDC W5, #0x0, W7
003BC6  9FB7F6     MOV W6, [W15-18]
003BC8  9FBF87     MOV W7, [W15-16]
1018:                                      break;
003BCA  37FFB3     BRA 0x3B32
1019:                                  case 9:
1020:                                      csd_c_size_mult = b & 0x03;
003BCC  604663     AND.B W0, #0x3, W12
1021:                                      csd_c_size_mult <<= 1;
003BCE  46460C     ADD.B W12, W12, W12
1022:                                      break;
003BD0  37FFB0     BRA 0x3B32
1023:                                  case 10:
1024:                                      csd_c_size_mult |= b >> 7;
003BD2  FB8000     ZE W0, W0
003BD4  DE0047     LSR W0, #7, W0
003BD6  764600     IOR.B W12, W0, W12
1025:              
1026:                                      info->capacity = (uint32_t) csd_c_size << (csd_c_size_mult + csd_read_bl_len + 2);
003BD8  FB828D     ZE W13, W5
003BDA  E88285     INC2 W5, W5
003BDC  FB820C     ZE W12, W4
003BDE  428204     ADD W5, W4, W4
003BE0  97B37F     MOV [W15-18], W6
003BE2  97BB8F     MOV [W15-16], W7
003BE4  780004     MOV W4, W0
003BE6  E90000     DEC W0, W0
003BE8  330003     BRA N, 0x3BF0
003BEA  430306     ADD W6, W6, W6
003BEC  4B8387     ADDC W7, W7, W7
003BEE  37FFFB     BRA 0x3BE6
003BF0  980D96     MOV W6, [W11+18]
003BF2  980DA7     MOV W7, [W11+20]
003BF4  37FF9E     BRA 0x3B32
1027:                                      break;
1028:                              }
1029:                          }
1030:                      }
1031:                  }
1032:              
1033:                  unselect_card();
003BFA  A802CD     BSET 0x2CD, #0
1034:              
1035:                  return 1;
003BFC  B3C010     MOV.B #0x1, W0
1036:              }
003BFE  78074F     MOV [--W15], W14
003C00  BE064F     MOV.D [--W15], W12
003C02  BE054F     MOV.D [--W15], W10
003C04  BE044F     MOV.D [--W15], W8
003C06  B1006F     SUB #0x6, W15
003C08  060000     RETURN
1037:              
---  C:/Users/Jacques/Documents/GitHub/PicVisionPortable/PICVisionPortable.X/FAT/partition.c  -----------
1:                 
2:                 /*
3:                  * Copyright (c) 2006-2012 by Roland Riegel <feedback@roland-riegel.de>
4:                  *
5:                  * This file is free software; you can redistribute it and/or modify
6:                  * it under the terms of either the GNU General Public License version 2
7:                  * or the GNU Lesser General Public License version 2.1, both as
8:                  * published by the Free Software Foundation.
9:                  */
10:                
11:                #include "byteordering.h"
12:                #include "partition.h"
13:                #include "partition_config.h"
14:                #include "sd-reader_config.h"
15:                
16:                #include <string.h>
17:                
18:                #if USE_DYNAMIC_MEMORY
19:                    #include <stdlib.h>
20:                #endif
21:                
22:                /**
23:                 * \addtogroup partition Partition table support
24:                 *
25:                 * Support for reading partition tables and access to partitions.
26:                 *
27:                 * @{
28:                 */
29:                /**
30:                 * \file
31:                 * Partition table implementation (license: GPLv2 or LGPLv2.1)
32:                 *
33:                 * \author Roland Riegel
34:                 */
35:                
36:                /**
37:                 * \addtogroup partition_config Configuration of partition table support
38:                 * Preprocessor defines to configure the partition support.
39:                 */
40:                
41:                #if !USE_DYNAMIC_MEMORY
42:                static struct partition_struct partition_handles[PARTITION_COUNT];
43:                #endif
44:                
45:                /**
46:                 * Opens a partition.
47:                 *
48:                 * Opens a partition by its index number and returns a partition
49:                 * handle which describes the opened partition.
50:                 *
51:                 * \note This function does not support extended partitions.
52:                 *
53:                 * \param[in] device_read A function pointer which is used to read from the disk.
54:                 * \param[in] device_read_interval A function pointer which is used to read in constant intervals from the disk.
55:                 * \param[in] device_write A function pointer which is used to write to the disk.
56:                 * \param[in] device_write_interval A function pointer which is used to write a data stream to disk.
57:                 * \param[in] index The index of the partition which should be opened, range 0 to 3.
58:                 *                  A negative value is allowed as well. In this case, the partition opened is
59:                 *                  not checked for existance, begins at offset zero, has a length of zero
60:                 *                  and is of an unknown type. Use this in case you want to open the whole device
61:                 *                  as a single partition (e.g. for "super floppy" use).
62:                 * \returns 0 on failure, a partition descriptor on success.
63:                 * \see partition_close
64:                 */
65:                struct partition_struct* partition_open(device_read_t device_read, device_read_interval_t device_read_interval, device_write_t device_write, device_write_interval_t device_write_interval, int8_t index)
66:                {
0049C8  FA0010     LNK #0x10
0049CA  BE9F88     MOV.D W8, [W15++]
0049CC  BE9F8A     MOV.D W10, [W15++]
0049CE  781F8C     MOV W12, [W15++]
0049D0  780400     MOV W0, W8
0049D2  780581     MOV W1, W11
0049D4  780602     MOV W2, W12
0049D6  780503     MOV W3, W10
0049D8  784484     MOV.B W4, W9
67:                    struct partition_struct* new_partition = 0;
68:                    uint8_t buffer[0x10];
69:                
70:                    if(!device_read || !device_read_interval || index >= 4)
0049DC  540F80     SUB W8, W0, [W15]
0049DE  320030     BRA Z, 0x4A40
0049E0  558F80     SUB W11, W0, [W15]
0049E2  32002E     BRA Z, 0x4A40
0049E4  54CFE3     SUB.B W9, #0x3, [W15]
0049E6  3C002C     BRA GT, 0x4A40
71:                        return 0;
0049DA  EB0000     CLR W0
72:                
73:                    if(index >= 0)
0049E8  54CFE0     SUB.B W9, #0x0, [W15]
0049EA  35000E     BRA LT, 0x4A08
74:                    {
75:                        /* read specified partition table index */
76:                        if(!device_read(0x01be + index * 0x10, buffer, sizeof(buffer)))
0049EC  FB0009     SE W9, W0
0049EE  DD0044     SL W0, #4, W0
0049F0  B01BE0     ADD #0x1BE, W0
0049F2  DE80CF     ASR W0, #15, W1
0049F4  200103     MOV #0x10, W3
0049F6  57817A     SUB W15, #0x1A, W2
0049F8  010008     CALL W8
0049FA  784200     MOV.B W0, W4
0049FE  524FE0     SUB.B W4, #0x0, [W15]
004A00  32001F     BRA Z, 0x4A40
77:                            return 0;
0049FC  EB0000     CLR W0
78:                
79:                        /* abort on empty partition entry */
80:                        if(buffer[4] == 0x00)
004A02  97EA2F     MOV.B [W15-22], W4
004A04  524FE0     SUB.B W4, #0x0, [W15]
004A06  32001C     BRA Z, 0x4A40
81:                            return 0;
82:                    }
83:                
84:                    /* allocate partition descriptor */
85:                #if USE_DYNAMIC_MEMORY
86:                    new_partition = malloc(sizeof(*new_partition));
87:                    if(!new_partition)
88:                        return 0;
89:                #else
90:                    new_partition = partition_handles;
004A38  21D260     MOV #0x1D26, W0
004A3A  370002     BRA 0x4A40
004A3E  21D260     MOV #0x1D26, W0
91:                    uint8_t i;
92:                    for(i = 0; i < PARTITION_COUNT; ++i)
93:                    {
94:                        if(new_partition->type == PARTITION_TYPE_FREE)
004A0A  21D2E4     MOV #0x1D2E, W4
004A0C  784214     MOV.B [W4], W4
004A0E  524FE0     SUB.B W4, #0x0, [W15]
004A10  3A0017     BRA NZ, 0x4A40
95:                            break;
96:                
97:                        ++new_partition;
98:                    }
99:                    if(i >= PARTITION_COUNT)
100:                       return 0;
004A08  EB0000     CLR W0
101:               #endif
102:               
103:                   memset(new_partition, 0, sizeof(*new_partition));
004A12  21D260     MOV #0x1D26, W0
004A14  090008     REPEAT #0x8
004A16  EB1800     CLR [W0++]
104:               
105:                   /* fill partition descriptor */
106:                   new_partition->device_read = device_read;
004A18  88E938     MOV W8, partition_handles
107:                   new_partition->device_read_interval = device_read_interval;
004A1A  88E94B     MOV W11, 0x1D28
108:                   new_partition->device_write = device_write;
004A1C  88E95C     MOV W12, 0x1D2A
109:                   new_partition->device_write_interval = device_write_interval;
004A1E  88E96A     MOV W10, 0x1D2C
110:               
111:                   if(index >= 0)
004A20  54CFE0     SUB.B W9, #0x0, [W15]
004A22  35000C     BRA LT, 0x4A3C
112:                   {
113:                       new_partition->type = buffer[4];
004A24  97E82F     MOV.B [W15-22], W0
004A26  B7FD2E     MOV.B WREG, 0x1D2E
114:                       new_partition->offset = read32(&buffer[8]);
004A28  578072     SUB W15, #0x12, W0
004A2A  0700A0     RCALL read32
004A2C  88E980     MOV W0, 0x1D30
004A2E  88E991     MOV W1, 0x1D32
115:                       new_partition->length = read32(&buffer[12]);
004A30  57806E     SUB W15, #0xE, W0
004A32  07009C     RCALL read32
004A34  88E9A0     MOV W0, 0x1D34
004A36  88E9B1     MOV W1, 0x1D36
116:                   }
117:                   else
118:                   {
119:                       new_partition->type = 0xff;
004A3C  EFFD2E     SETM.B 0x1D2E
120:                   }
121:               
122:                   return new_partition;
123:               }
004A40  78064F     MOV [--W15], W12
004A42  BE054F     MOV.D [--W15], W10
004A44  BE044F     MOV.D [--W15], W8
004A46  FA8000     ULNK
004A48  060000     RETURN
124:               
125:               /**
126:                * Closes a partition.
127:                *
128:                * This function destroys a partition descriptor which was
129:                * previously obtained from a call to partition_open().
130:                * When this function returns, the given descriptor will be
131:                * invalid.
132:                *
133:                * \param[in] partition The partition descriptor to destroy.
134:                * \returns 0 on failure, 1 on success.
135:                * \see partition_open
136:                */
137:               uint8_t partition_close(struct partition_struct* partition)
138:               {
139:                   if(!partition)
004A4C  500FE0     SUB W0, #0x0, [W15]
004A4E  320002     BRA Z, 0x4A54
140:                       return 0;
004A4A  EB4200     CLR.B W4
141:               
142:                   /* destroy partition descriptor */
143:               #if USE_DYNAMIC_MEMORY
144:                   free(partition);
145:               #else
146:                   partition->type = PARTITION_TYPE_FREE;
004A50  984804     MOV.B W4, [W0+8]
147:               #endif
148:               
149:                   return 1;
004A52  B3C014     MOV.B #0x1, W4
150:               }
004A54  784004     MOV.B W4, W0
004A56  060000     RETURN
151:               
152:               /**
153:                * @}
154:                */
155:               
---  C:/Users/Jacques/Documents/GitHub/PicVisionPortable/PICVisionPortable.X/FAT/fat.c  -----------------
1:                 
2:                 /* 
3:                  * Copyright (c) 2006-2012 by Roland Riegel <feedback@roland-riegel.de>
4:                  *
5:                  * This file is free software; you can redistribute it and/or modify
6:                  * it under the terms of either the GNU General Public License version 2
7:                  * or the GNU Lesser General Public License version 2.1, both as
8:                  * published by the Free Software Foundation.
9:                  */
10:                
11:                #include "byteordering.h"
12:                #include "partition.h"
13:                #include "fat.h"
14:                #include "fat_config.h"
15:                #include "sd-reader_config.h"
16:                
17:                #include <string.h>
18:                
19:                #if USE_DYNAMIC_MEMORY
20:                    #include <stdlib.h>
21:                #endif
22:                
23:                /**
24:                 * \addtogroup fat FAT support
25:                 *
26:                 * This module implements FAT16/FAT32 read and write access.
27:                 * 
28:                 * The following features are supported:
29:                 * - File names up to 31 characters long.
30:                 * - Unlimited depth of subdirectories.
31:                 * - Short 8.3 and long filenames.
32:                 * - Creating and deleting files.
33:                 * - Reading and writing from and to files.
34:                 * - File resizing.
35:                 * - File sizes of up to 4 gigabytes.
36:                 * 
37:                 * @{
38:                 */
39:                /**
40:                 * \file
41:                 * FAT implementation (license: GPLv2 or LGPLv2.1)
42:                 *
43:                 * \author Roland Riegel
44:                 */
45:                
46:                /**
47:                 * \addtogroup fat_config FAT configuration
48:                 * Preprocessor defines to configure the FAT implementation.
49:                 */
50:                
51:                /**
52:                 * \addtogroup fat_fs FAT access
53:                 * Basic functions for handling a FAT filesystem.
54:                 */
55:                
56:                /**
57:                 * \addtogroup fat_file FAT file functions
58:                 * Functions for managing files.
59:                 */
60:                
61:                /**
62:                 * \addtogroup fat_dir FAT directory functions
63:                 * Functions for managing directories.
64:                 */
65:                
66:                /**
67:                 * @}
68:                 */
69:                
70:                #define FAT16_CLUSTER_FREE 0x0000
71:                #define FAT16_CLUSTER_RESERVED_MIN 0xfff0
72:                #define FAT16_CLUSTER_RESERVED_MAX 0xfff6
73:                #define FAT16_CLUSTER_BAD 0xfff7
74:                #define FAT16_CLUSTER_LAST_MIN 0xfff8
75:                #define FAT16_CLUSTER_LAST_MAX 0xffff
76:                
77:                #define FAT32_CLUSTER_FREE 0x00000000
78:                #define FAT32_CLUSTER_RESERVED_MIN 0x0ffffff0
79:                #define FAT32_CLUSTER_RESERVED_MAX 0x0ffffff6
80:                #define FAT32_CLUSTER_BAD 0x0ffffff7
81:                #define FAT32_CLUSTER_LAST_MIN 0x0ffffff8
82:                #define FAT32_CLUSTER_LAST_MAX 0x0fffffff
83:                
84:                #define FAT_DIRENTRY_DELETED 0xe5
85:                #define FAT_DIRENTRY_LFNLAST (1 << 6)
86:                #define FAT_DIRENTRY_LFNSEQMASK ((1 << 6) - 1)
87:                
88:                /* Each entry within the directory table has a size of 32 bytes
89:                 * and either contains a 8.3 DOS-style file name or a part of a
90:                 * long file name, which may consist of several directory table
91:                 * entries at once.
92:                 *
93:                 * multi-byte integer values are stored little-endian!
94:                 *
95:                 * 8.3 file name entry:
96:                 * ====================
97:                 * offset  length  description
98:                 *      0       8  name (space padded)
99:                 *      8       3  extension (space padded)
100:                *     11       1  attributes (FAT_ATTRIB_*)
101:                *
102:                * long file name (lfn) entry ordering for a single file name:
103:                * ===========================================================
104:                * LFN entry n
105:                *     ...
106:                * LFN entry 2
107:                * LFN entry 1
108:                * 8.3 entry (see above)
109:                * 
110:                * lfn entry:
111:                * ==========
112:                * offset  length  description
113:                *      0       1  ordinal field
114:                *      1       2  unicode character 1
115:                *      3       3  unicode character 2
116:                *      5       3  unicode character 3
117:                *      7       3  unicode character 4
118:                *      9       3  unicode character 5
119:                *     11       1  attribute (always 0x0f)
120:                *     12       1  type (reserved, always 0)
121:                *     13       1  checksum
122:                *     14       2  unicode character 6
123:                *     16       2  unicode character 7
124:                *     18       2  unicode character 8
125:                *     20       2  unicode character 9
126:                *     22       2  unicode character 10
127:                *     24       2  unicode character 11
128:                *     26       2  cluster (unused, always 0)
129:                *     28       2  unicode character 12
130:                *     30       2  unicode character 13
131:                * 
132:                * The ordinal field contains a descending number, from n to 1.
133:                * For the n'th lfn entry the ordinal field is or'ed with 0x40.
134:                * For deleted lfn entries, the ordinal field is set to 0xe5.
135:                */
136:               
137:               struct fat_header_struct
138:               {
139:                   offset_t size;
140:               
141:                   offset_t fat_offset;
142:                   uint32_t fat_size;
143:               
144:                   uint16_t sector_size;
145:                   uint16_t cluster_size;
146:               
147:                   offset_t cluster_zero_offset;
148:               
149:                   offset_t root_dir_offset;
150:               #if FAT_FAT32_SUPPORT
151:                   cluster_t root_dir_cluster;
152:               #endif
153:               };
154:               
155:               struct fat_fs_struct
156:               {
157:                   struct partition_struct* partition;
158:                   struct fat_header_struct header;
159:                   cluster_t cluster_free;
160:               };
161:               
162:               struct fat_file_struct
163:               {
164:                   struct fat_fs_struct* fs;
165:                   struct fat_dir_entry_struct dir_entry;
166:                   offset_t pos;
167:                   cluster_t pos_cluster;
168:               };
169:               
170:               struct fat_dir_struct
171:               {
172:                   struct fat_fs_struct* fs;
173:                   struct fat_dir_entry_struct dir_entry;
174:                   cluster_t entry_cluster;
175:                   uint16_t entry_offset;
176:               };
177:               
178:               struct fat_read_dir_callback_arg
179:               {
180:                   struct fat_dir_entry_struct* dir_entry;
181:                   uintptr_t bytes_read;
182:               #if FAT_LFN_SUPPORT
183:                   uint8_t checksum;
184:               #endif
185:                   uint8_t finished;
186:               };
187:               
188:               struct fat_usage_count_callback_arg
189:               {
190:                   cluster_t cluster_count;
191:                   uintptr_t buffer_size;
192:               };
193:               
194:               #if !USE_DYNAMIC_MEMORY
195:               static struct fat_fs_struct fat_fs_handles[FAT_FS_COUNT];
196:               static struct fat_file_struct fat_file_handles[FAT_FILE_COUNT];
197:               static struct fat_dir_struct fat_dir_handles[FAT_DIR_COUNT];
198:               #endif
199:               
200:               static uint8_t fat_read_header(struct fat_fs_struct* fs);
201:               static cluster_t fat_get_next_cluster(const struct fat_fs_struct* fs, cluster_t cluster_num);
202:               static offset_t fat_cluster_offset(const struct fat_fs_struct* fs, cluster_t cluster_num);
203:               static uint8_t fat_dir_entry_read_callback(uint8_t* buffer, offset_t offset, void* p);
204:               #if FAT_LFN_SUPPORT
205:               static uint8_t fat_calc_83_checksum(const uint8_t* file_name_83);
206:               #endif
207:               
208:               static uint8_t fat_get_fs_free_16_callback(uint8_t* buffer, offset_t offset, void* p);
209:               #if FAT_FAT32_SUPPORT
210:               static uint8_t fat_get_fs_free_32_callback(uint8_t* buffer, offset_t offset, void* p);
211:               #endif
212:               
213:               #if FAT_WRITE_SUPPORT
214:               static cluster_t fat_append_clusters(struct fat_fs_struct* fs, cluster_t cluster_num, cluster_t count);
215:               static uint8_t fat_free_clusters(struct fat_fs_struct* fs, cluster_t cluster_num);
216:               static uint8_t fat_terminate_clusters(struct fat_fs_struct* fs, cluster_t cluster_num);
217:               static uint8_t fat_clear_cluster(const struct fat_fs_struct* fs, cluster_t cluster_num);
218:               static uintptr_t fat_clear_cluster_callback(uint8_t* buffer, offset_t offset, void* p);
219:               static offset_t fat_find_offset_for_dir_entry(struct fat_fs_struct* fs, const struct fat_dir_struct* parent, const struct fat_dir_entry_struct* dir_entry);
220:               static uint8_t fat_write_dir_entry(const struct fat_fs_struct* fs, struct fat_dir_entry_struct* dir_entry);
221:               #if FAT_DATETIME_SUPPORT
222:               static void fat_set_file_modification_date(struct fat_dir_entry_struct* dir_entry, uint16_t year, uint8_t month, uint8_t day);
223:               static void fat_set_file_modification_time(struct fat_dir_entry_struct* dir_entry, uint8_t hour, uint8_t min, uint8_t sec);
224:               #endif
225:               #endif
226:               
227:               /**
228:                * \ingroup fat_fs
229:                * Opens a FAT filesystem.
230:                *
231:                * \param[in] partition Discriptor of partition on which the filesystem resides.
232:                * \returns 0 on error, a FAT filesystem descriptor on success.
233:                * \see fat_close
234:                */
235:               struct fat_fs_struct* fat_open(struct partition_struct* partition)
236:               {
002CA0  780200     MOV W0, W4
237:                   if(!partition ||
002CA4  520F80     SUB W4, W0, [W15]
002CA6  32000F     BRA Z, 0x2CC6
238:               #if FAT_WRITE_SUPPORT
239:                      !partition->device_write ||
240:                      !partition->device_write_interval
241:               #else
242:                      0
243:               #endif
244:                     )
245:                       return 0;
002CA2  EB0000     CLR W0
246:               
247:               #if USE_DYNAMIC_MEMORY
248:                   struct fat_fs_struct* fs = malloc(sizeof(*fs));
249:                   if(!fs)
250:                       return 0;
251:               #else
252:                   struct fat_fs_struct* fs = fat_fs_handles;
253:                   uint8_t i;
254:                   for(i = 0; i < FAT_FS_COUNT; ++i)
255:                   {
256:                       if(!fs->partition)
002CA8  80E855     MOV fat_fs_handles, W5
002CAA  528F80     SUB W5, W0, [W15]
002CAC  3A000C     BRA NZ, 0x2CC6
257:                           break;
258:               
259:                       ++fs;
260:                   }
261:                   if(i >= FAT_FS_COUNT)
262:                       return 0;
263:               #endif
264:               
265:                   memset(fs, 0, sizeof(*fs));
002CAE  21D0A5     MOV #0x1D0A, W5
002CB0  09000D     REPEAT #0xD
002CB2  EB1A80     CLR [W5++]
266:               
267:                   fs->partition = partition;
002CB4  88E854     MOV W4, fat_fs_handles
268:                   if(!fat_read_header(fs))
002CB6  21D0A0     MOV #0x1D0A, W0
002CB8  07FF45     RCALL _fat_read_header
002CBA  784200     MOV.B W0, W4
002CBC  21D0A0     MOV #0x1D0A, W0
002CBE  524FE0     SUB.B W4, #0x0, [W15]
002CC0  3A0002     BRA NZ, 0x2CC6
269:                   {
270:               #if USE_DYNAMIC_MEMORY
271:                       free(fs);
272:               #else
273:                       fs->partition = 0;
002CC2  EB0000     CLR W0
002CC4  88E850     MOV W0, fat_fs_handles
274:               #endif
275:                       return 0;
276:                   }
277:                   
278:                   return fs;
279:               }
002CC6  060000     RETURN
280:               
281:               /**
282:                * \ingroup fat_fs
283:                * Closes a FAT filesystem.
284:                *
285:                * When this function returns, the given filesystem descriptor
286:                * will be invalid.
287:                *
288:                * \param[in] fs The filesystem to close.
289:                * \see fat_open
290:                */
291:               void fat_close(struct fat_fs_struct* fs)
292:               {
293:                   if(!fs)
002CC8  500FE0     SUB W0, #0x0, [W15]
002CCA  320001     BRA Z, 0x2CCE
294:                       return;
295:               
296:               #if USE_DYNAMIC_MEMORY
297:                   free(fs);
298:               #else
299:                   fs->partition = 0;
002CCC  EB0800     CLR [W0]
300:               #endif
301:               }
002CCE  060000     RETURN
302:               
303:               /**
304:                * \ingroup fat_fs
305:                * Reads and parses the header of a FAT filesystem.
306:                *
307:                * \param[in,out] fs The filesystem for which to parse the header.
308:                * \returns 0 on failure, 1 on success.
309:                */
310:               uint8_t fat_read_header(struct fat_fs_struct* fs)
311:               {
002B44  B002CF     ADD #0x2C, W15
002B46  BE9F88     MOV.D W8, [W15++]
002B48  BE9F8A     MOV.D W10, [W15++]
002B4A  BE9F8C     MOV.D W12, [W15++]
002B4C  781F8E     MOV W14, [W15++]
002B4E  780580     MOV W0, W11
312:                   if(!fs)
002B52  558FE0     SUB W11, #0x0, [W15]
002B54  32009E     BRA Z, 0x2C92
313:                       return 0;
002B50  EB4200     CLR.B W4
314:               
315:                   struct partition_struct* partition = fs->partition;
002B56  78051B     MOV [W11], W10
316:                   if(!partition)
002B58  550FE0     SUB W10, #0x0, [W15]
002B5A  32009B     BRA Z, 0x2C92
317:                       return 0;
318:               
319:                   /* read fat parameters */
320:               #if FAT_FAT32_SUPPORT
321:                   uint8_t buffer[37];
322:               #else
323:                   uint8_t buffer[25];
324:               #endif
325:                   offset_t partition_offset = (offset_t) partition->offset * 512;
002B5C  90025A     MOV [W10+10], W4
002B5E  9002EA     MOV [W10+12], W5
002B60  DD2E49     SL W5, #9, W12
002B62  DE26C7     LSR W4, #7, W13
002B64  76068D     IOR W12, W13, W13
002B66  DD2649     SL W4, #9, W12
326:                   if(!partition->device_read(partition_offset + 0x0b, buffer, sizeof(buffer)))
002B68  46006B     ADD W12, #0xB, W0
002B6A  4E80E0     ADDC W13, #0x0, W1
002B6C  78021A     MOV [W10], W4
002B6E  200193     MOV #0x19, W3
002B70  2FFC82     MOV #0xFFC8, W2
002B72  41010F     ADD W2, W15, W2
002B74  010004     CALL W4
002B78  504F84     SUB.B W0, W4, [W15]
002B7A  32008B     BRA Z, 0x2C92
327:                       return 0;
002B76  EB4200     CLR.B W4
328:               
329:                   uint16_t bytes_per_sector = read16(&buffer[0x00]);
002B7C  2FFC80     MOV #0xFFC8, W0
002B7E  40000F     ADD W0, W15, W0
002B80  070FEF     RCALL read16
002B82  9FB7E0     MOV W0, [W15-20]
330:                   uint16_t reserved_sectors = read16(&buffer[0x03]);
002B84  2FFCB0     MOV #0xFFCB, W0
002B86  40000F     ADD W0, W15, W0
002B88  070FEB     RCALL read16
002B8A  9FB7A0     MOV W0, [W15-28]
331:                   uint8_t sectors_per_cluster = buffer[0x02];
002B8C  97CF2F     MOV.B [W15-54], W14
332:                   uint8_t fat_copies = buffer[0x05];
002B8E  97C85F     MOV.B [W15-51], W0
002B90  9FE7A0     MOV.B W0, [W15-30]
333:                   uint16_t max_root_entries = read16(&buffer[0x06]);
002B92  2FFCE0     MOV #0xFFCE, W0
002B94  40000F     ADD W0, W15, W0
002B96  070FE4     RCALL read16
002B98  9FB7B0     MOV W0, [W15-26]
334:                   uint16_t sector_count_16 = read16(&buffer[0x08]);
002B9A  2FFD00     MOV #0xFFD0, W0
002B9C  40000F     ADD W0, W15, W0
002B9E  070FE0     RCALL read16
002BA0  9FB7C0     MOV W0, [W15-24]
335:                   uint16_t sectors_per_fat = read16(&buffer[0x0b]);
002BA2  2FFD30     MOV #0xFFD3, W0
002BA4  40000F     ADD W0, W15, W0
002BA6  070FDC     RCALL read16
002BA8  9FB7F0     MOV W0, [W15-18]
336:                   uint32_t sector_count = read32(&buffer[0x15]);
002BAA  2FFDD0     MOV #0xFFDD, W0
002BAC  40000F     ADD W0, W15, W0
002BAE  070FDE     RCALL read32
002BB0  BE0400     MOV.D W0, W8
337:               #if FAT_FAT32_SUPPORT
338:                   uint32_t sectors_per_fat32 = read32(&buffer[0x19]);
339:                   uint32_t cluster_root_dir = read32(&buffer[0x21]);
340:               #endif
341:               
342:                   if(sector_count == 0)
002BB2  500FE0     SUB W0, #0x0, [W15]
002BB4  588FE0     SUBB W1, #0x0, [W15]
002BB6  3A0005     BRA NZ, 0x2BC2
343:                   {
344:                       if(sector_count_16 == 0)
002BBA  97B0CF     MOV [W15-24], W1
002BBC  508FE0     SUB W1, #0x0, [W15]
002BBE  320069     BRA Z, 0x2C92
345:                           /* illegal volume size */
346:                           return 0;
002BB8  EB4200     CLR.B W4
347:                       else
348:                           sector_count = sector_count_16;
002BC0  B80C61     MUL.UU W1, #1, W8
349:                   }
350:               #if FAT_FAT32_SUPPORT
351:                   if(sectors_per_fat != 0)
352:                       sectors_per_fat32 = sectors_per_fat;
353:                   else if(sectors_per_fat32 == 0)
354:                       /* this is neither FAT16 nor FAT32 */
355:                       return 0;
356:               #else
357:                   if(sectors_per_fat == 0)
002BC4  97B2FF     MOV [W15-18], W5
002BC6  528FE0     SUB W5, #0x0, [W15]
002BC8  320064     BRA Z, 0x2C92
358:                       /* this is not a FAT16 */
359:                       return 0;
002BC2  EB4200     CLR.B W4
360:               #endif
361:               
362:                   /* determine the type of FAT we have here */
363:                   uint32_t data_sector_count = sector_count
002BFC  510004     SUB W2, W4, W0
002BFE  5980E0     SUBB W3, #0x0, W1
364:                                                - reserved_sectors
002BCA  97B3AF     MOV [W15-28], W7
002BCC  B83B61     MUL.UU W7, #1, W6
002BCE  9FB7C6     MOV W6, [W15-24]
002BD0  9FB7D7     MOV W7, [W15-22]
002BE0  97B24F     MOV [W15-24], W4
002BE2  97B2DF     MOV [W15-22], W5
002BE4  540004     SUB W8, W4, W0
002BE6  5C8085     SUBB W9, W5, W1
365:               #if FAT_FAT32_SUPPORT
366:                                                - sectors_per_fat32 * fat_copies
367:               #else
368:                                                - (uint32_t) sectors_per_fat * fat_copies
002BD2  97E02F     MOV.B [W15-30], W0
002BD4  FB8200     ZE W0, W4
002BD6  200005     MOV #0x0, W5
002BD8  97B3FF     MOV [W15-18], W7
002BDA  B83B04     MUL.UU W7, W4, W6
002BDC  9FB7F6     MOV W6, [W15-18]
002BDE  9FBF87     MOV W7, [W15-16]
002BE8  500106     SUB W0, W6, W2
002BEA  588187     SUBB W1, W7, W3
369:               #endif
370:                                                - ((max_root_entries * 32 + bytes_per_sector - 1) / bytes_per_sector);
002BEC  97B36F     MOV [W15-20], W6
002BEE  E90286     DEC W6, W5
002BF0  97B3BF     MOV [W15-26], W7
002BF2  DD3A45     SL W7, #5, W4
002BF4  428204     ADD W5, W4, W4
002BF6  090011     REPEAT #0x11
002BF8  D88206     DIV.UW W4, W6
002BFA  780200     MOV W0, W4
371:                   uint32_t data_cluster_count = data_sector_count / sectors_per_cluster;
002C00  FB810E     ZE W14, W2
002C02  200003     MOV #0x0, W3
002C04  07EB54     RCALL ___udivsi3
372:                   if(data_cluster_count < 4085)
002C08  20FF45     MOV #0xFF4, W5
002C0A  500F85     SUB W0, W5, [W15]
002C0C  588FE0     SUBB W1, #0x0, [W15]
002C0E  360041     BRA LEU, 0x2C92
373:                       /* this is a FAT12, not supported */
374:                       return 0;
002C06  EB4200     CLR.B W4
375:                   else if(data_cluster_count < 65525)
002C10  400FEC     ADD W0, #0xC, [W15]
002C12  588FE0     SUBB W1, #0x0, [W15]
002C14  3E0003     BRA GTU, 0x2C1C
376:                       /* this is a FAT16 */
377:                       partition->type = PARTITION_TYPE_FAT16;
002C16  B3C064     MOV.B #0x6, W4
002C18  984D04     MOV.B W4, [W10+8]
002C1A  370002     BRA 0x2C20
378:                   else
379:                       /* this is a FAT32 */
380:                       partition->type = PARTITION_TYPE_FAT32;
002C1C  B3C0B4     MOV.B #0xB, W4
002C1E  984D04     MOV.B W4, [W10+8]
381:               
382:                   /* fill header information */
383:                   struct fat_header_struct* header = &fs->header;
384:                   memset(header, 0, sizeof(*header));
002C20  458362     ADD W11, #0x2, W6
002C22  09000B     REPEAT #0xB
002C24  EB1B00     CLR [W6++]
385:                   
386:                   header->size = (offset_t) sector_count * bytes_per_sector;
002C26  97B3EF     MOV [W15-20], W7
002C28  B83A61     MUL.UU W7, #1, W4
002C2A  B9C904     MUL.SS W9, W4, W2
002C2C  B84404     MUL.UU W8, W4, W8
002C2E  410489     ADD W2, W9, W9
002C30  980598     MOV W8, [W11+2]
002C32  9805A9     MOV W9, [W11+4]
387:               
388:                   header->fat_offset = /* jump to partition */
002C3C  9805BC     MOV W12, [W11+6]
002C3E  9805CD     MOV W13, [W11+8]
389:                                        partition_offset +
002C38  460606     ADD W12, W6, W12
002C3A  4E8687     ADDC W13, W7, W13
390:                                        /* jump to fat */
391:                                        (offset_t) reserved_sectors * bytes_per_sector;
002C34  97B3CF     MOV [W15-24], W7
002C36  B82307     MUL.UU W4, W7, W6
392:                   header->fat_size = (data_cluster_count + 2) * (partition->type == PARTITION_TYPE_FAT16 ? 2 : 4);
002C40  400062     ADD W0, #0x2, W0
002C42  4880E0     ADDC W1, #0x0, W1
002C44  90490A     MOV.B [W10+8], W2
002C46  200046     MOV #0x4, W6
002C48  200007     MOV #0x0, W7
002C4A  514FE6     SUB.B W2, #0x6, [W15]
002C4C  3A0002     BRA NZ, 0x2C52
002C4E  200026     MOV #0x2, W6
002C50  200007     MOV #0x0, W7
002C52  B9BC00     MUL.SS W7, W0, W8
002C54  B98906     MUL.SS W1, W6, W2
002C56  410108     ADD W2, W8, W2
002C58  B83000     MUL.UU W6, W0, W0
002C5A  410081     ADD W2, W1, W1
002C5C  9805D0     MOV W0, [W11+10]
002C5E  9805E1     MOV W1, [W11+12]
393:               
394:                   header->sector_size = bytes_per_sector;
002C60  97B06F     MOV [W15-20], W0
002C62  9805F0     MOV W0, [W11+14]
395:                   header->cluster_size = (uint16_t) bytes_per_sector * sectors_per_cluster;
002C64  FB830E     ZE W14, W6
002C66  B98306     MUL.SS W0, W6, W6
002C68  980D86     MOV W6, [W11+16]
396:               
397:               #if FAT_FAT32_SUPPORT
398:                   if(partition->type == PARTITION_TYPE_FAT16)
399:               #endif
400:                   {
401:                       header->root_dir_offset = /* jump to fats */
002C78  980DBC     MOV W12, [W11+22]
002C7A  980DCD     MOV W13, [W11+24]
402:                                                 header->fat_offset +
002C74  460604     ADD W12, W4, W12
002C76  4E8685     ADDC W13, W5, W13
403:                                                 /* jump to root directory entries */
404:                                                 (offset_t) fat_copies * sectors_per_fat * bytes_per_sector;
002C6A  97B88F     MOV [W15-16], W1
002C6C  B98B04     MUL.SS W1, W4, W6
002C6E  97B07F     MOV [W15-18], W0
002C70  B80204     MUL.UU W0, W4, W4
002C72  430285     ADD W6, W5, W5
405:               
406:                       header->cluster_zero_offset = /* jump to root directory entries */
002C8C  980D9C     MOV W12, [W11+18]
002C8E  980DAD     MOV W13, [W11+20]
407:                                                     header->root_dir_offset +
002C88  42060C     ADD W4, W12, W12
002C8A  4A868D     ADDC W5, W13, W13
408:                                                     /* skip root directory entries */
409:                                                     (offset_t) max_root_entries * 32;
002C7C  97B0BF     MOV [W15-26], W1
002C7E  B80B61     MUL.UU W1, #1, W6
002C80  DD3A45     SL W7, #5, W4
002C82  DE32CB     LSR W6, #11, W5
002C84  720285     IOR W4, W5, W5
002C86  DD3245     SL W6, #5, W4
410:                   }
411:               #if FAT_FAT32_SUPPORT
412:                   else
413:                   {
414:                       header->cluster_zero_offset = /* jump to fats */
415:                                                     header->fat_offset +
416:                                                     /* skip fats */
417:                                                     (offset_t) fat_copies * sectors_per_fat32 * bytes_per_sector;
418:               
419:                       header->root_dir_cluster = cluster_root_dir;
420:                   }
421:               #endif
422:               
423:                   return 1;
002C90  B3C014     MOV.B #0x1, W4
424:               }
002C92  784004     MOV.B W4, W0
002C94  78074F     MOV [--W15], W14
002C96  BE064F     MOV.D [--W15], W12
002C98  BE054F     MOV.D [--W15], W10
002C9A  BE044F     MOV.D [--W15], W8
002C9C  B102CF     SUB #0x2C, W15
002C9E  060000     RETURN
425:               
426:               /**
427:                * \ingroup fat_fs
428:                * Retrieves the next following cluster of a given cluster.
429:                *
430:                * Using the filesystem file allocation table, this function returns
431:                * the number of the cluster containing the data directly following
432:                * the data within the cluster with the given number.
433:                *
434:                * \param[in] fs The filesystem for which to determine the next cluster.
435:                * \param[in] cluster_num The number of the cluster for which to determine its successor.
436:                * \returns The wanted cluster number, or 0 on error.
437:                */
438:               cluster_t fat_get_next_cluster(const struct fat_fs_struct* fs, cluster_t cluster_num)
439:               {
002926  FA0002     LNK #0x2
002928  780200     MOV W0, W4
00292A  780001     MOV W1, W0
440:                   if(!fs || cluster_num < 2)
00292E  520F85     SUB W4, W5, [W15]
002930  320020     BRA Z, 0x2972
002932  500FE1     SUB W0, #0x1, [W15]
002934  36001E     BRA LEU, 0x2972
441:                       return 0;
00292C  EB0280     CLR W5
442:               
443:               #if FAT_FAT32_SUPPORT
444:                   if(fs->partition->type == PARTITION_TYPE_FAT32)
445:                   {
446:                       /* read appropriate fat entry */
447:                       uint32_t fat_entry;
448:                       if(!fs->partition->device_read(fs->header.fat_offset + (offset_t) cluster_num * sizeof(fat_entry), (uint8_t*) &fat_entry, sizeof(fat_entry)))
449:                           return 0;
450:               
451:                       /* determine next cluster from fat */
452:                       cluster_num = ltoh32(fat_entry);
453:                       
454:                       if(cluster_num == FAT32_CLUSTER_FREE ||
455:                          cluster_num == FAT32_CLUSTER_BAD ||
456:                          (cluster_num >= FAT32_CLUSTER_RESERVED_MIN && cluster_num <= FAT32_CLUSTER_RESERVED_MAX) ||
457:                          (cluster_num >= FAT32_CLUSTER_LAST_MIN && cluster_num <= FAT32_CLUSTER_LAST_MAX))
458:                           return 0;
459:                   }
460:                   else
461:               #endif
462:                   {
463:                       /* read appropriate fat entry */
464:                       uint16_t fat_entry;
465:                       if(!fs->partition->device_read(fs->header.fat_offset + (offset_t) cluster_num * sizeof(fat_entry), (uint8_t*) &fat_entry, sizeof(fat_entry)))
002936  780294     MOV [W4], W5
002938  200001     MOV #0x0, W1
00293A  400000     ADD W0, W0, W0
00293C  488081     ADDC W1, W1, W1
00293E  900334     MOV [W4+6], W6
002940  9003C4     MOV [W4+8], W7
002942  430000     ADD W6, W0, W0
002944  4B8081     ADDC W7, W1, W1
002946  780215     MOV [W5], W4
002948  200023     MOV #0x2, W3
00294A  E9810F     DEC2 W15, W2
00294C  010004     CALL W4
002950  504FE0     SUB.B W0, #0x0, [W15]
002952  32000F     BRA Z, 0x2972
466:                           return 0;
00294E  EB0280     CLR W5
467:               
468:                       /* determine next cluster from fat */
469:                       cluster_num = ltoh16(fat_entry);
002954  97BAFF     MOV [W15-2], W5
470:                       
471:                       if(cluster_num == FAT16_CLUSTER_FREE ||
002956  528FE0     SUB W5, #0x0, [W15]
002958  32000C     BRA Z, 0x2972
00295A  428FE9     ADD W5, #0x9, [W15]
00295C  320007     BRA Z, 0x296C
472:                          cluster_num == FAT16_CLUSTER_BAD ||
002960  520FE6     SUB W4, #0x6, [W15]
002962  360006     BRA LEU, 0x2970
473:                          (cluster_num >= FAT16_CLUSTER_RESERVED_MIN && cluster_num <= FAT16_CLUSTER_RESERVED_MAX) ||
00295E  428270     ADD W5, #0x10, W4
002964  428FE9     ADD W5, #0x9, [W15]
002966  360005     BRA LEU, 0x2972
474:                          (cluster_num >= FAT16_CLUSTER_LAST_MIN && cluster_num <= FAT16_CLUSTER_LAST_MAX))
475:                           return 0;
002968  EB0280     CLR W5
00296A  370003     BRA 0x2972
00296C  EB0280     CLR W5
00296E  370001     BRA 0x2972
002970  EB0280     CLR W5
476:                   }
477:               
478:                   return cluster_num;
479:               }
002972  780005     MOV W5, W0
002974  FA8000     ULNK
002976  060000     RETURN
480:               
481:               #if DOXYGEN || FAT_WRITE_SUPPORT
482:               /**
483:                * \ingroup fat_fs
484:                * Appends a new cluster chain to an existing one.
485:                *
486:                * Set cluster_num to zero to create a completely new one.
487:                *
488:                * \param[in] fs The file system on which to operate.
489:                * \param[in] cluster_num The cluster to which to append the new chain.
490:                * \param[in] count The number of clusters to allocate.
491:                * \returns 0 on failure, the number of the first new cluster on success.
492:                */
493:               cluster_t fat_append_clusters(struct fat_fs_struct* fs, cluster_t cluster_num, cluster_t count)
494:               {
495:                   if(!fs)
496:                       return 0;
497:               
498:                   device_read_t device_read = fs->partition->device_read;
499:                   device_write_t device_write = fs->partition->device_write;
500:                   offset_t fat_offset = fs->header.fat_offset;
501:                   cluster_t count_left = count;
502:                   cluster_t cluster_current = fs->cluster_free;
503:                   cluster_t cluster_next = 0;
504:                   cluster_t cluster_count;
505:                   uint16_t fat_entry16;
506:               #if FAT_FAT32_SUPPORT
507:                   uint32_t fat_entry32;
508:                   uint8_t is_fat32 = (fs->partition->type == PARTITION_TYPE_FAT32);
509:               
510:                   if(is_fat32)
511:                       cluster_count = fs->header.fat_size / sizeof(fat_entry32);
512:                   else
513:               #endif
514:                       cluster_count = fs->header.fat_size / sizeof(fat_entry16);
515:               
516:                   fs->cluster_free = 0;
517:                   for(cluster_t cluster_left = cluster_count; cluster_left > 0; --cluster_left, ++cluster_current)
518:                   {
519:                       if(cluster_current < 2 || cluster_current >= cluster_count)
520:                           cluster_current = 2;
521:               
522:               #if FAT_FAT32_SUPPORT
523:                       if(is_fat32)
524:                       {
525:                           if(!device_read(fat_offset + (offset_t) cluster_current * sizeof(fat_entry32), (uint8_t*) &fat_entry32, sizeof(fat_entry32)))
526:                               return 0;
527:                       }
528:                       else
529:               #endif
530:                       {
531:                           if(!device_read(fat_offset + (offset_t) cluster_current * sizeof(fat_entry16), (uint8_t*) &fat_entry16, sizeof(fat_entry16)))
532:                               return 0;
533:                       }
534:               
535:               #if FAT_FAT32_SUPPORT
536:                       if(is_fat32)
537:                       {
538:                           /* check if this is a free cluster */
539:                           if(fat_entry32 != HTOL32(FAT32_CLUSTER_FREE))
540:                               continue;
541:               
542:                           /* If we don't need this free cluster for the
543:                            * current allocation, we keep it in mind for
544:                            * the next time.
545:                            */
546:                           if(count_left == 0)
547:                           {
548:                               fs->cluster_free = cluster_current;
549:                               break;
550:                           }
551:               
552:                           /* allocate cluster */
553:                           if(cluster_next == 0)
554:                               fat_entry32 = HTOL32(FAT32_CLUSTER_LAST_MAX);
555:                           else
556:                               fat_entry32 = htol32(cluster_next);
557:               
558:                           if(!device_write(fat_offset + (offset_t) cluster_current * sizeof(fat_entry32), (uint8_t*) &fat_entry32, sizeof(fat_entry32)))
559:                               break;
560:                       }
561:                       else
562:               #endif
563:                       {
564:                           /* check if this is a free cluster */
565:                           if(fat_entry16 != HTOL16(FAT16_CLUSTER_FREE))
566:                               continue;
567:               
568:                           /* If we don't need this free cluster for the
569:                            * current allocation, we keep it in mind for
570:                            * the next time.
571:                            */
572:                           if(count_left == 0)
573:                           {
574:                               fs->cluster_free = cluster_current;
575:                               break;
576:                           }
577:               
578:                           /* allocate cluster */
579:                           if(cluster_next == 0)
580:                               fat_entry16 = HTOL16(FAT16_CLUSTER_LAST_MAX);
581:                           else
582:                               fat_entry16 = htol16((uint16_t) cluster_next);
583:               
584:                           if(!device_write(fat_offset + (offset_t) cluster_current * sizeof(fat_entry16), (uint8_t*) &fat_entry16, sizeof(fat_entry16)))
585:                               break;
586:                       }
587:               
588:                       cluster_next = cluster_current;
589:                       --count_left;
590:                   }
591:               
592:                   do
593:                   {
594:                       if(count_left > 0)
595:                           break;
596:               
597:                       /* We allocated a new cluster chain. Now join
598:                        * it with the existing one (if any).
599:                        */
600:                       if(cluster_num >= 2)
601:                       {
602:               #if FAT_FAT32_SUPPORT
603:                           if(is_fat32)
604:                           {
605:                               fat_entry32 = htol32(cluster_next);
606:               
607:                               if(!device_write(fat_offset + (offset_t) cluster_num * sizeof(fat_entry32), (uint8_t*) &fat_entry32, sizeof(fat_entry32)))
608:                                   break;
609:                           }
610:                           else
611:               #endif
612:                           {
613:                               fat_entry16 = htol16((uint16_t) cluster_next);
614:               
615:                               if(!device_write(fat_offset + (offset_t) cluster_num * sizeof(fat_entry16), (uint8_t*) &fat_entry16, sizeof(fat_entry16)))
616:                                   break;
617:                           }
618:                       }
619:               
620:                       return cluster_next;
621:               
622:                   } while(0);
623:               
624:                   /* No space left on device or writing error.
625:                    * Free up all clusters already allocated.
626:                    */
627:                   fat_free_clusters(fs, cluster_next);
628:               
629:                   return 0;
630:               }
631:               #endif
632:               
633:               #if DOXYGEN || FAT_WRITE_SUPPORT
634:               /**
635:                * \ingroup fat_fs
636:                * Frees a cluster chain, or a part thereof.
637:                *
638:                * Marks the specified cluster and all clusters which are sequentially
639:                * referenced by it as free. They may then be used again for future
640:                * file allocations.
641:                *
642:                * \note If this function is used for freeing just a part of a cluster
643:                *       chain, the new end of the chain is not correctly terminated
644:                *       within the FAT. Use fat_terminate_clusters() instead.
645:                *
646:                * \param[in] fs The filesystem on which to operate.
647:                * \param[in] cluster_num The starting cluster of the chain which to free.
648:                * \returns 0 on failure, 1 on success.
649:                * \see fat_terminate_clusters
650:                */
651:               uint8_t fat_free_clusters(struct fat_fs_struct* fs, cluster_t cluster_num)
652:               {
653:                   if(!fs || cluster_num < 2)
654:                       return 0;
655:               
656:                   offset_t fat_offset = fs->header.fat_offset;
657:               #if FAT_FAT32_SUPPORT
658:                   if(fs->partition->type == PARTITION_TYPE_FAT32)
659:                   {
660:                       uint32_t fat_entry;
661:                       while(cluster_num)
662:                       {
663:                           if(!fs->partition->device_read(fat_offset + (offset_t) cluster_num * sizeof(fat_entry), (uint8_t*) &fat_entry, sizeof(fat_entry)))
664:                               return 0;
665:               
666:                           /* get next cluster of current cluster before freeing current cluster */
667:                           uint32_t cluster_num_next = ltoh32(fat_entry);
668:               
669:                           if(cluster_num_next == FAT32_CLUSTER_FREE)
670:                               return 1;
671:                           if(cluster_num_next == FAT32_CLUSTER_BAD ||
672:                              (cluster_num_next >= FAT32_CLUSTER_RESERVED_MIN &&
673:                               cluster_num_next <= FAT32_CLUSTER_RESERVED_MAX
674:                              )
675:                             )
676:                               return 0;
677:                           if(cluster_num_next >= FAT32_CLUSTER_LAST_MIN && cluster_num_next <= FAT32_CLUSTER_LAST_MAX)
678:                               cluster_num_next = 0;
679:               
680:                           /* We know we will free the cluster, so remember it as
681:                            * free for the next allocation.
682:                            */
683:                           if(!fs->cluster_free)
684:                               fs->cluster_free = cluster_num;
685:               
686:                           /* free cluster */
687:                           fat_entry = HTOL32(FAT32_CLUSTER_FREE);
688:                           fs->partition->device_write(fat_offset + (offset_t) cluster_num * sizeof(fat_entry), (uint8_t*) &fat_entry, sizeof(fat_entry));
689:               
690:                           /* We continue in any case here, even if freeing the cluster failed.
691:                            * The cluster is lost, but maybe we can still free up some later ones.
692:                            */
693:               
694:                           cluster_num = cluster_num_next;
695:                       }
696:                   }
697:                   else
698:               #endif
699:                   {
700:                       uint16_t fat_entry;
701:                       while(cluster_num)
702:                       {
703:                           if(!fs->partition->device_read(fat_offset + (offset_t) cluster_num * sizeof(fat_entry), (uint8_t*) &fat_entry, sizeof(fat_entry)))
704:                               return 0;
705:               
706:                           /* get next cluster of current cluster before freeing current cluster */
707:                           uint16_t cluster_num_next = ltoh16(fat_entry);
708:               
709:                           if(cluster_num_next == FAT16_CLUSTER_FREE)
710:                               return 1;
711:                           if(cluster_num_next == FAT16_CLUSTER_BAD ||
712:                              (cluster_num_next >= FAT16_CLUSTER_RESERVED_MIN &&
713:                               cluster_num_next <= FAT16_CLUSTER_RESERVED_MAX
714:                              )
715:                             )
716:                               return 0;
717:                           if(cluster_num_next >= FAT16_CLUSTER_LAST_MIN && cluster_num_next <= FAT16_CLUSTER_LAST_MAX)
718:                               cluster_num_next = 0;
719:               
720:                           /* free cluster */
721:                           fat_entry = HTOL16(FAT16_CLUSTER_FREE);
722:                           fs->partition->device_write(fat_offset + (offset_t) cluster_num * sizeof(fat_entry), (uint8_t*) &fat_entry, sizeof(fat_entry));
723:               
724:                           /* We continue in any case here, even if freeing the cluster failed.
725:                            * The cluster is lost, but maybe we can still free up some later ones.
726:                            */
727:               
728:                           cluster_num = cluster_num_next;
729:                       }
730:                   }
731:               
732:                   return 1;
733:               }
734:               #endif
735:               
736:               #if DOXYGEN || FAT_WRITE_SUPPORT
737:               /**
738:                * \ingroup fat_fs
739:                * Frees a part of a cluster chain and correctly terminates the rest.
740:                *
741:                * Marks the specified cluster as the new end of a cluster chain and
742:                * frees all following clusters.
743:                *
744:                * \param[in] fs The filesystem on which to operate.
745:                * \param[in] cluster_num The new end of the cluster chain.
746:                * \returns 0 on failure, 1 on success.
747:                * \see fat_free_clusters
748:                */
749:               uint8_t fat_terminate_clusters(struct fat_fs_struct* fs, cluster_t cluster_num)
750:               {
751:                   if(!fs || cluster_num < 2)
752:                       return 0;
753:               
754:                   /* fetch next cluster before overwriting the cluster entry */
755:                   cluster_t cluster_num_next = fat_get_next_cluster(fs, cluster_num);
756:               
757:                   /* mark cluster as the last one */
758:               #if FAT_FAT32_SUPPORT
759:                   if(fs->partition->type == PARTITION_TYPE_FAT32)
760:                   {
761:                       uint32_t fat_entry = HTOL32(FAT32_CLUSTER_LAST_MAX);
762:                       if(!fs->partition->device_write(fs->header.fat_offset + (offset_t) cluster_num * sizeof(fat_entry), (uint8_t*) &fat_entry, sizeof(fat_entry)))
763:                           return 0;
764:                   }
765:                   else
766:               #endif
767:                   {
768:                       uint16_t fat_entry = HTOL16(FAT16_CLUSTER_LAST_MAX);
769:                       if(!fs->partition->device_write(fs->header.fat_offset + (offset_t) cluster_num * sizeof(fat_entry), (uint8_t*) &fat_entry, sizeof(fat_entry)))
770:                           return 0;
771:                   }
772:               
773:                   /* free remaining clusters */
774:                   if(cluster_num_next)
775:                       return fat_free_clusters(fs, cluster_num_next);
776:                   else
777:                       return 1;
778:               }
779:               #endif
780:               
781:               #if DOXYGEN || FAT_WRITE_SUPPORT
782:               /**
783:                * \ingroup fat_fs
784:                * Clears a single cluster.
785:                *
786:                * The complete cluster is filled with zeros.
787:                *
788:                * \param[in] fs The filesystem on which to operate.
789:                * \param[in] cluster_num The cluster to clear.
790:                * \returns 0 on failure, 1 on success.
791:                */
792:               uint8_t fat_clear_cluster(const struct fat_fs_struct* fs, cluster_t cluster_num)
793:               {
794:                   if(cluster_num < 2)
795:                       return 0;
796:               
797:                   offset_t cluster_offset = fat_cluster_offset(fs, cluster_num);
798:               
799:                   uint8_t zero[16];
800:                   memset(zero, 0, sizeof(zero));
801:                   return fs->partition->device_write_interval(cluster_offset,
802:                                                               zero,
803:                                                               fs->header.cluster_size,
804:                                                               fat_clear_cluster_callback,
805:                                                               0
806:                                                              );
807:               }
808:               #endif
809:               
810:               #if DOXYGEN || FAT_WRITE_SUPPORT
811:               /**
812:                * \ingroup fat_fs
813:                * Callback function for clearing a cluster.
814:                */
815:               uintptr_t fat_clear_cluster_callback(uint8_t* buffer, offset_t offset, void* p)
816:               {
817:                   return 16;
818:               }
819:               #endif
820:               
821:               /**
822:                * \ingroup fat_fs
823:                * Calculates the offset of the specified cluster.
824:                *
825:                * \param[in] fs The filesystem on which to operate.
826:                * \param[in] cluster_num The cluster whose offset to calculate.
827:                * \returns The cluster offset.
828:                */
829:               offset_t fat_cluster_offset(const struct fat_fs_struct* fs, cluster_t cluster_num)
830:               {
002978  BE0200     MOV.D W0, W4
831:                   if(!fs || cluster_num < 2)
00297C  520FE0     SUB W4, #0x0, [W15]
00297E  320009     BRA Z, 0x2992
002980  528FE1     SUB W5, #0x1, [W15]
002982  360007     BRA LEU, 0x2992
832:                       return 0;
00297A  B80060     MUL.UU W0, #0, W0
833:               
834:                   return fs->header.cluster_zero_offset + (offset_t) (cluster_num - 2) * fs->header.cluster_size;
002984  E98005     DEC2 W5, W0
002986  900B04     MOV [W4+16], W6
002988  B80006     MUL.UU W0, W6, W0
00298A  900AA4     MOV [W4+20], W5
00298C  900A14     MOV [W4+18], W4
00298E  420000     ADD W4, W0, W0
002990  4A8081     ADDC W5, W1, W1
835:               }
002992  060000     RETURN
836:               
837:               /**
838:                * \ingroup fat_file
839:                * Retrieves the directory entry of a path.
840:                *
841:                * The given path may both describe a file or a directory.
842:                *
843:                * \param[in] fs The FAT filesystem on which to search.
844:                * \param[in] path The path of which to read the directory entry.
845:                * \param[out] dir_entry The directory entry to fill.
846:                * \returns 0 on failure, 1 on success.
847:                * \see fat_read_dir
848:                */
849:               uint8_t fat_get_dir_entry_of_path(struct fat_fs_struct* fs, const char* path, struct fat_dir_entry_struct* dir_entry)
850:               {
002F92  4787E4     ADD W15, #0x4, W15
002F94  BE9F88     MOV.D W8, [W15++]
002F96  BE9F8A     MOV.D W10, [W15++]
002F98  BE9F8C     MOV.D W12, [W15++]
002F9A  781F8E     MOV W14, [W15++]
002F9C  9FBF80     MOV W0, [W15-16]
002F9E  780681     MOV W1, W13
002FA0  780402     MOV W2, W8
851:                   if(!fs || !path || path[0] == '\0' || !dir_entry)
002FA4  97BA0F     MOV [W15-16], W4
002FA6  520FE0     SUB W4, #0x0, [W15]
002FA8  320050     BRA Z, 0x304A
002FAA  568FE0     SUB W13, #0x0, [W15]
002FAC  32004E     BRA Z, 0x304A
002FAE  78421D     MOV.B [W13], W4
002FB0  524F80     SUB.B W4, W0, [W15]
002FB2  32004B     BRA Z, 0x304A
002FB4  540FE0     SUB W8, #0x0, [W15]
002FB6  320049     BRA Z, 0x304A
852:                       return 0;
002FA2  EB4000     CLR.B W0
853:               
854:                   if(path[0] == '/')
002FB8  B3C2F5     MOV.B #0x2F, W5
002FBA  524F85     SUB.B W4, W5, [W15]
002FBC  3A0001     BRA NZ, 0x2FC0
855:                       ++path;
002FBE  E8068D     INC W13, W13
856:               
857:                   /* begin with the root directory */
858:                   memset(dir_entry, 0, sizeof(*dir_entry));
002FC0  090015     REPEAT #0x15
002FC2  EB1C00     CLR [W8++]
002FC4  B102C8     SUB #0x2C, W8
859:                   dir_entry->attributes = FAT_ATTRIB_DIR;
002FC6  B3C104     MOV.B #0x10, W4
002FC8  986404     MOV.B W4, [W8+32]
860:               
861:                   while(1)
862:                   {
863:                       if(path[0] == '\0')
002FCC  EB4200     CLR.B W4
002FCE  124F9D     SUBR.B W4, [W13], [W15]
002FD0  32003C     BRA Z, 0x304A
00303A  EB4200     CLR.B W4
00303C  124F9D     SUBR.B W4, [W13], [W15]
00303E  3AFFC9     BRA NZ, 0x2FD2
864:                           return 1;
002FCA  B3C010     MOV.B #0x1, W0
003040  B3C010     MOV.B #0x1, W0
003042  370003     BRA 0x304A
865:               
866:                       struct fat_dir_struct* dd = fat_open_dir(fs, dir_entry);
002FD2  780088     MOV W8, W1
002FD4  97B80F     MOV [W15-16], W0
002FD6  07FF50     RCALL fat_open_dir
002FD8  780500     MOV W0, W10
867:                       if(!dd)
002FDA  550FE0     SUB W10, #0x0, [W15]
002FDC  320033     BRA Z, 0x3044
868:                           break;
869:               
870:                       /* extract the next hierarchy we will search for */
871:                       const char* sub_path = strchr(path, '/');
002FDE  2002F1     MOV #0x2F, W1
002FE0  78000D     MOV W13, W0
002FE2  07E9AF     RCALL _strchr
872:                       uint8_t length_to_sep;
873:                       if(sub_path)
002FE4  500FE0     SUB W0, #0x0, [W15]
002FE6  320003     BRA Z, 0x2FEE
874:                       {
875:                           length_to_sep = sub_path - path;
002FE8  50460D     SUB.B W0, W13, W12
876:                           ++sub_path;
002FEA  E80700     INC W0, W14
002FEC  37001B     BRA 0x3024
877:                       }
878:                       else
879:                       {
880:                           length_to_sep = strlen(path);
002FEE  78000D     MOV W13, W0
002FF0  07E9BF     RCALL _strlen
002FF2  784600     MOV.B W0, W12
881:                           sub_path = path + length_to_sep;
002FF4  FB870C     ZE W12, W14
002FF6  46870E     ADD W13, W14, W14
002FF8  370015     BRA 0x3024
882:                       }
883:                       
884:                       /* read directory entries */
885:                       while(fat_read_dir(dd, dir_entry))
003026  780088     MOV W8, W1
003028  78000A     MOV W10, W0
00302A  07FF52     RCALL fat_read_dir
00302C  504FE0     SUB.B W0, #0x0, [W15]
00302E  3AFFE5     BRA NZ, 0x2FFA
003030  370002     BRA 0x3036
886:                       {
887:                           /* check if we have found the next hierarchy */
888:                           if((strlen(dir_entry->long_name) != length_to_sep ||
002FFA  780008     MOV W8, W0
002FFC  07E9B9     RCALL _strlen
002FFE  780480     MOV W0, W9
003000  548F8C     SUB W9, W12, [W15]
003002  3A0011     BRA NZ, 0x3026
00300C  500FE0     SUB W0, #0x0, [W15]
00300E  3A000B     BRA NZ, 0x3026
003024  FB860C     ZE W12, W12
889:                               strncmp(path, dir_entry->long_name, length_to_sep) != 0))
003004  780109     MOV W9, W2
003006  780088     MOV W8, W1
003008  78000D     MOV W13, W0
00300A  07E9B9     RCALL _strncmp
890:                               continue;
891:               
892:                           fat_close_dir(dd);
003010  78000A     MOV W10, W0
003012  07FF50     RCALL fat_close_dir
893:                           dd = 0;
003034  EB0500     CLR W10
894:               
895:                           if(path[length_to_sep] == '\0')
003014  7CC26D     MOV.B [W13+W9], W4
003016  524FE0     SUB.B W4, #0x0, [W15]
003018  320017     BRA Z, 0x3048
896:                               /* we iterated through the whole path and have found the file */
897:                               return 1;
003048  B3C010     MOV.B #0x1, W0
898:               
899:                           if(dir_entry->attributes & FAT_ATTRIB_DIR)
00301A  906208     MOV.B [W8+32], W4
00301C  620270     AND W4, #0x10, W4
00301E  3A0009     BRA NZ, 0x3032
900:                           {
901:                               /* we found a parent directory of the file we are searching for */
902:                               path = sub_path;
003032  78068E     MOV W14, W13
903:                               break;
904:                           }
905:               
906:                           /* a parent of the file exists, but not the file itself */
907:                           return 0;
003020  EB4000     CLR.B W0
003022  370013     BRA 0x304A
908:                       }
909:               
910:                       fat_close_dir(dd);
003036  78000A     MOV W10, W0
003038  07FF3D     RCALL fat_close_dir
911:                   }
912:                   
913:                   return 0;
003044  EB4000     CLR.B W0
003046  370001     BRA 0x304A
914:               }
00304A  78074F     MOV [--W15], W14
00304C  BE064F     MOV.D [--W15], W12
00304E  BE054F     MOV.D [--W15], W10
003050  BE044F     MOV.D [--W15], W8
003052  B1004F     SUB #0x4, W15
003054  060000     RETURN
915:               
916:               /**
917:                * \ingroup fat_file
918:                * Opens a file on a FAT filesystem.
919:                *
920:                * \param[in] fs The filesystem on which the file to open lies.
921:                * \param[in] dir_entry The directory entry of the file to open.
922:                * \returns The file handle, or 0 on failure.
923:                * \see fat_close_file
924:                */
925:               struct fat_file_struct* fat_open_file(struct fat_fs_struct* fs, const struct fat_dir_entry_struct* dir_entry)
926:               {
927:                   if(!fs || !dir_entry || (dir_entry->attributes & FAT_ATTRIB_DIR))
002CD2  500F84     SUB W0, W4, [W15]
002CD4  320013     BRA Z, 0x2CFC
002CD6  508F84     SUB W1, W4, [W15]
002CD8  320011     BRA Z, 0x2CFC
002CDA  906281     MOV.B [W1+32], W5
002CDC  6282F0     AND W5, #0x10, W5
002CDE  528F84     SUB W5, W4, [W15]
002CE0  3A000D     BRA NZ, 0x2CFC
928:                       return 0;
002CD0  EB0200     CLR W4
929:               
930:               #if USE_DYNAMIC_MEMORY
931:                   struct fat_file_struct* fd = malloc(sizeof(*fd));
932:                   if(!fd)
933:                       return 0;
934:               #else
935:                   struct fat_file_struct* fd = fat_file_handles;
936:                   uint8_t i;
937:                   for(i = 0; i < FAT_FILE_COUNT; ++i)
938:                   {
939:                       if(!fd->fs)
002CE2  80E6B5     MOV fat_file_handles, W5
002CE4  528F84     SUB W5, W4, [W15]
002CE6  3A000A     BRA NZ, 0x2CFC
940:                           break;
941:               
942:                       ++fd;
943:                   }
944:                   if(i >= FAT_FILE_COUNT)
945:                       return 0;
946:               #endif
947:                   
948:                   memcpy(&fd->dir_entry, dir_entry, sizeof(*dir_entry));
002CE8  21CD84     MOV #0x1CD8, W4
002CEA  090015     REPEAT #0x15
002CEC  781A31     MOV [W1++], [W4++]
002CEE  B102C1     SUB #0x2C, W1
949:                   fd->fs = fs;
002CF0  88E6B0     MOV W0, fat_file_handles
950:                   fd->pos = 0;
002CF2  EF3D04     CLR 0x1D04
002CF4  EF3D06     CLR 0x1D06
951:                   fd->pos_cluster = dir_entry->cluster;
002CF6  901091     MOV [W1+34], W1
002CF8  88E841     MOV W1, 0x1D08
952:               
953:                   return fd;
002CFA  21CD64     MOV #0x1CD6, W4
954:               }
002CFC  780004     MOV W4, W0
002CFE  060000     RETURN
955:               
956:               /**
957:                * \ingroup fat_file
958:                * Closes a file.
959:                *
960:                * \param[in] fd The file handle of the file to close.
961:                * \see fat_open_file
962:                */
963:               void fat_close_file(struct fat_file_struct* fd)
964:               {
965:                   if(fd)
002D00  500FE0     SUB W0, #0x0, [W15]
002D02  320001     BRA Z, 0x2D06
966:                   {
967:               #if FAT_DELAY_DIRENTRY_UPDATE
968:                       /* write directory entry */
969:                       fat_write_dir_entry(fd->fs, &fd->dir_entry);
970:               #endif
971:               
972:               #if USE_DYNAMIC_MEMORY
973:                       free(fd);
974:               #else
975:                       fd->fs = 0;
002D04  EB0800     CLR [W0]
976:               #endif
977:                   }
978:               }
002D06  060000     RETURN
979:               
980:               /**
981:                * \ingroup fat_file
982:                * Reads data from a file.
983:                * 
984:                * The data requested is read from the current file location.
985:                *
986:                * \param[in] fd The file handle of the file from which to read.
987:                * \param[out] buffer The buffer into which to write.
988:                * \param[in] buffer_len The amount of data to read.
989:                * \returns The number of bytes read, 0 on end of file, or -1 on failure.
990:                * \see fat_write_file
991:                */
992:               intptr_t fat_read_file(struct fat_file_struct* fd, uint8_t* buffer, uintptr_t buffer_len)
993:               {
002D08  4787F0     ADD W15, #0x10, W15
002D0A  BE9F88     MOV.D W8, [W15++]
002D0C  BE9F8A     MOV.D W10, [W15++]
002D0E  BE9F8C     MOV.D W12, [W15++]
002D10  781F8E     MOV W14, [W15++]
002D12  BE0400     MOV.D W0, W8
002D14  780502     MOV W2, W10
994:                   /* check arguments */
995:                   if(!fd || !buffer || buffer_len < 1)
002D18  540FE0     SUB W8, #0x0, [W15]
002D1A  320081     BRA Z, 0x2E1E
002D1C  548FE0     SUB W9, #0x0, [W15]
002D1E  32007F     BRA Z, 0x2E1E
002D20  550FE0     SUB W10, #0x0, [W15]
002D22  32007D     BRA Z, 0x2E1E
996:                       return -1;
002D16  EB8000     SETM W0
997:               
998:                   /* determine number of bytes to read */
999:                   if(fd->pos + buffer_len > fd->dir_entry.file_size)
002D24  901078     MOV [W8+46], W0
002D26  901888     MOV [W8+48], W1
002D28  9FB7F0     MOV W0, [W15-18]
002D2A  9FBF81     MOV W1, [W15-16]
002D2C  901238     MOV [W8+38], W4
002D2E  9012C8     MOV [W8+40], W5
002D30  40030A     ADD W0, W10, W6
002D32  4883E0     ADDC W1, #0x0, W7
002D34  530F84     SUB W6, W4, [W15]
002D36  5B8F85     SUBB W7, W5, [W15]
002D38  360004     BRA LEU, 0x2D42
1000:                      buffer_len = fd->dir_entry.file_size - fd->pos;
002D3A  520500     SUB W4, W0, W10
1001:                  if(buffer_len == 0)
002D3E  550F80     SUB W10, W0, [W15]
002D40  32006E     BRA Z, 0x2E1E
1002:                      return 0;
002D3C  EB0000     CLR W0
1003:                  
1004:                  uint16_t cluster_size = fd->fs->header.cluster_size;
002D42  780218     MOV [W8], W4
002D44  900A04     MOV [W4+16], W4
002D46  9FB7E4     MOV W4, [W15-20]
1005:                  cluster_t cluster_num = fd->pos_cluster;
002D48  901E98     MOV [W8+50], W13
1006:                  uintptr_t buffer_left = buffer_len;
1007:                  uint16_t first_cluster_offset = (uint16_t) (fd->pos & (cluster_size - 1));
002DAC  97B2EF     MOV [W15-20], W5
002DAE  E90705     DEC W5, W14
002DB0  97B37F     MOV [W15-18], W6
002DB2  670706     AND W14, W6, W14
002DB4  78060A     MOV W10, W12
1008:              
1009:                  /* find cluster in which to start reading */
1010:                  if(!cluster_num)
002D4A  568FE0     SUB W13, #0x0, [W15]
002D4C  3A002F     BRA NZ, 0x2DAC
1011:                  {
1012:                      cluster_num = fd->dir_entry.cluster;
002D4E  9016A8     MOV [W8+36], W13
1013:                      
1014:                      if(!cluster_num)
002D50  568FE0     SUB W13, #0x0, [W15]
002D52  3A0008     BRA NZ, 0x2D64
1015:                      {
1016:                          if(!fd->pos)
1017:                              return 0;
002D54  97B80F     MOV [W15-16], W0
002D56  97B0FF     MOV [W15-18], W1
002D58  700001     IOR W0, W1, W0
002D5A  A7F000     BTSC W0, #15
002D5C  EA0000     NEG W0, W0
002D5E  EA0000     NEG W0, W0
002D60  DE804F     ASR W0, #15, W0
002D62  37005D     BRA 0x2E1E
1018:                          else
1019:                              return -1;
1020:                      }
1021:              
1022:                      if(fd->pos)
002D64  97B27F     MOV [W15-18], W4
002D66  97BA8F     MOV [W15-16], W5
002D68  520FE0     SUB W4, #0x0, [W15]
002D6A  5A8FE0     SUBB W5, #0x0, [W15]
002D6C  3A0010     BRA NZ, 0x2D8E
002D6E  37001E     BRA 0x2DAC
002D8E  97B27F     MOV [W15-18], W4
002D90  97BA8F     MOV [W15-16], W5
002D92  9FB7C4     MOV W4, [W15-24]
002D94  9FB7D5     MOV W5, [W15-22]
1023:                      {
1024:                          uint32_t pos = fd->pos;
1025:                          while(pos >= cluster_size)
002D96  97B3EF     MOV [W15-20], W7
002D98  B83B61     MUL.UU W7, #1, W6
002D9A  9FB7A6     MOV W6, [W15-28]
002D9C  9FB7B7     MOV W7, [W15-26]
002D9E  97B04F     MOV [W15-24], W0
002DA0  97B0DF     MOV [W15-22], W1
002DA2  97B22F     MOV [W15-28], W4
002DA4  97B2BF     MOV [W15-26], W5
002DA6  500F84     SUB W0, W4, [W15]
002DA8  588F85     SUBB W1, W5, [W15]
002DAA  31FFE2     BRA C, 0x2D70
1026:                          {
1027:                              pos -= cluster_size;
1028:                              cluster_num = fat_get_next_cluster(fd->fs, cluster_num);
002D70  78008D     MOV W13, W1
002D72  780018     MOV [W8], W0
002D74  07FDD8     RCALL _fat_get_next_cluster
002D76  780680     MOV W0, W13
1029:                              if(!cluster_num)
002D78  568FE0     SUB W13, #0x0, [W15]
002D7A  320050     BRA Z, 0x2E1C
002D7C  97B34F     MOV [W15-24], W6
002D7E  97B3DF     MOV [W15-22], W7
002D80  97B02F     MOV [W15-28], W0
002D82  97B0BF     MOV [W15-26], W1
002D84  530300     SUB W6, W0, W6
002D86  5B8381     SUBB W7, W1, W7
002D88  9FB7C6     MOV W6, [W15-24]
002D8A  9FB7D7     MOV W7, [W15-22]
002D8C  370008     BRA 0x2D9E
1030:                                  return -1;
002E1C  EB8000     SETM W0
1031:                          }
1032:                      }
1033:                  }
1034:                  
1035:                  /* read data */
1036:                  do
1037:                  {
1038:                      /* calculate data size to copy from cluster */
1039:                      offset_t cluster_offset = fat_cluster_offset(fd->fs, cluster_num) + first_cluster_offset;
002DB6  780398     MOV [W8], W7
002DB8  9FB7F7     MOV W7, [W15-18]
002DBA  78008D     MOV W13, W1
002DBC  780007     MOV W7, W0
002DBE  07FDDC     RCALL _fat_cluster_offset
002DCE  40000E     ADD W0, W14, W0
002DD0  4880E0     ADDC W1, #0x0, W1
1040:                      uint16_t copy_length = cluster_size - first_cluster_offset;
002DC0  97B26F     MOV [W15-20], W4
002DC2  52058E     SUB W4, W14, W11
002DC4  558F8C     SUB W11, W12, [W15]
002DC6  360001     BRA LEU, 0x2DCA
002DC8  78058C     MOV W12, W11
1041:                      if(copy_length > buffer_left)
1042:                          copy_length = buffer_left;
1043:              
1044:                      /* read data */
1045:                      if(!fd->fs->partition->device_read(cluster_offset, buffer, copy_length))
002DCA  97B2FF     MOV [W15-18], W5
002DCC  780215     MOV [W5], W4
002DD2  780214     MOV [W4], W4
002DD4  78018B     MOV W11, W3
002DD6  780109     MOV W9, W2
002DD8  010004     CALL W4
002DDA  504FE0     SUB.B W0, #0x0, [W15]
002DDC  3A0002     BRA NZ, 0x2DE2
1046:                          return buffer_len - buffer_left;
002DDE  55000C     SUB W10, W12, W0
002DE0  37001E     BRA 0x2E1E
1047:              
1048:                      /* calculate new file position */
1049:                      buffer += copy_length;
002E14  44848B     ADD W9, W11, W9
002E16  37FFCF     BRA 0x2DB6
1050:                      buffer_left -= copy_length;
002DE2  56060B     SUB W12, W11, W12
1051:                      fd->pos += copy_length;
002DE4  901278     MOV [W8+46], W4
002DE6  901A88     MOV [W8+48], W5
002DE8  42020B     ADD W4, W11, W4
002DEA  4A82E0     ADDC W5, #0x0, W5
002DEC  981474     MOV W4, [W8+46]
002DEE  981C05     MOV W5, [W8+48]
1052:              
1053:                      if(first_cluster_offset + copy_length >= cluster_size)
002DF0  45820E     ADD W11, W14, W4
002DF2  97B36F     MOV [W15-20], W6
002DF4  530F84     SUB W6, W4, [W15]
002DF6  3E000B     BRA GTU, 0x2E0E
1054:                      {
1055:                          /* we are on a cluster boundary, so get the next cluster */
1056:                          if((cluster_num = fat_get_next_cluster(fd->fs, cluster_num)))
002DF8  78008D     MOV W13, W1
002DFA  780018     MOV [W8], W0
002DFC  07FD94     RCALL _fat_get_next_cluster
002DFE  780680     MOV W0, W13
002E00  568FE0     SUB W13, #0x0, [W15]
002E02  3A0004     BRA NZ, 0x2E0C
1057:                          {
1058:                              first_cluster_offset = 0;
002E0C  EB0700     CLR W14
1059:                          }
1060:                          else
1061:                          {
1062:                              fd->pos_cluster = 0;
002E04  EB0200     CLR W4
002E06  981C14     MOV W4, [W8+50]
1063:                              return buffer_len - buffer_left;
002E08  55000C     SUB W10, W12, W0
002E0A  370009     BRA 0x2E1E
1064:                          }
1065:                      }
1066:              
1067:                      fd->pos_cluster = cluster_num;
002E0E  981C1D     MOV W13, [W8+50]
1068:              
1069:                  } while(buffer_left > 0); /* check if we are done */
002E10  560FE0     SUB W12, #0x0, [W15]
002E12  320002     BRA Z, 0x2E18
1070:              
1071:                  return buffer_len;
002E18  78000A     MOV W10, W0
002E1A  370001     BRA 0x2E1E
1072:              }
002E1E  78074F     MOV [--W15], W14
002E20  BE064F     MOV.D [--W15], W12
002E22  BE054F     MOV.D [--W15], W10
002E24  BE044F     MOV.D [--W15], W8
002E26  B1010F     SUB #0x10, W15
002E28  060000     RETURN
1073:              
1074:              #if DOXYGEN || FAT_WRITE_SUPPORT
1075:              /**
1076:               * \ingroup fat_file
1077:               * Writes data to a file.
1078:               * 
1079:               * The data is written to the current file location.
1080:               *
1081:               * \param[in] fd The file handle of the file to which to write.
1082:               * \param[in] buffer The buffer from which to read the data to be written.
1083:               * \param[in] buffer_len The amount of data to write.
1084:               * \returns The number of bytes written (0 or something less than \c buffer_len on disk full) or -1 on failure.
1085:               * \see fat_read_file
1086:               */
1087:              intptr_t fat_write_file(struct fat_file_struct* fd, const uint8_t* buffer, uintptr_t buffer_len)
1088:              {
1089:                  /* check arguments */
1090:                  if(!fd || !buffer || buffer_len < 1)
1091:                      return -1;
1092:                  if(fd->pos > fd->dir_entry.file_size)
1093:                      return -1;
1094:              
1095:                  uint16_t cluster_size = fd->fs->header.cluster_size;
1096:                  cluster_t cluster_num = fd->pos_cluster;
1097:                  uintptr_t buffer_left = buffer_len;
1098:                  uint16_t first_cluster_offset = (uint16_t) (fd->pos & (cluster_size - 1));
1099:              
1100:                  /* find cluster in which to start writing */
1101:                  if(!cluster_num)
1102:                  {
1103:                      cluster_num = fd->dir_entry.cluster;
1104:                      
1105:                      if(!cluster_num)
1106:                      {
1107:                          if(!fd->pos)
1108:                          {
1109:                              /* empty file */
1110:                              fd->dir_entry.cluster = cluster_num = fat_append_clusters(fd->fs, 0, 1);
1111:                              if(!cluster_num)
1112:                                  return 0;
1113:                          }
1114:                          else
1115:                          {
1116:                              return -1;
1117:                          }
1118:                      }
1119:              
1120:                      if(fd->pos)
1121:                      {
1122:                          uint32_t pos = fd->pos;
1123:                          cluster_t cluster_num_next;
1124:                          while(pos >= cluster_size)
1125:                          {
1126:                              pos -= cluster_size;
1127:                              cluster_num_next = fat_get_next_cluster(fd->fs, cluster_num);
1128:                              if(!cluster_num_next)
1129:                              {
1130:                                  if(pos != 0)
1131:                                      return -1; /* current file position points beyond end of file */
1132:              
1133:                                  /* the file exactly ends on a cluster boundary, and we append to it */
1134:                                  cluster_num_next = fat_append_clusters(fd->fs, cluster_num, 1);
1135:                                  if(!cluster_num_next)
1136:                                      return 0;
1137:                              }
1138:              
1139:                              cluster_num = cluster_num_next;
1140:                          }
1141:                      }
1142:                  }
1143:                  
1144:                  /* write data */
1145:                  do
1146:                  {
1147:                      /* calculate data size to write to cluster */
1148:                      offset_t cluster_offset = fat_cluster_offset(fd->fs, cluster_num) + first_cluster_offset;
1149:                      uint16_t write_length = cluster_size - first_cluster_offset;
1150:                      if(write_length > buffer_left)
1151:                          write_length = buffer_left;
1152:              
1153:                      /* write data which fits into the current cluster */
1154:                      if(!fd->fs->partition->device_write(cluster_offset, buffer, write_length))
1155:                          break;
1156:              
1157:                      /* calculate new file position */
1158:                      buffer += write_length;
1159:                      buffer_left -= write_length;
1160:                      fd->pos += write_length;
1161:              
1162:                      if(first_cluster_offset + write_length >= cluster_size)
1163:                      {
1164:                          /* we are on a cluster boundary, so get the next cluster */
1165:                          cluster_t cluster_num_next = fat_get_next_cluster(fd->fs, cluster_num);
1166:                          if(!cluster_num_next && buffer_left > 0)
1167:                              /* we reached the last cluster, append a new one */
1168:                              cluster_num_next = fat_append_clusters(fd->fs, cluster_num, 1);
1169:                          if(!cluster_num_next)
1170:                          {
1171:                              fd->pos_cluster = 0;
1172:                              break;
1173:                          }
1174:              
1175:                          cluster_num = cluster_num_next;
1176:                          first_cluster_offset = 0;
1177:                      }
1178:              
1179:                      fd->pos_cluster = cluster_num;
1180:              
1181:                  } while(buffer_left > 0); /* check if we are done */
1182:              
1183:                  /* update directory entry */
1184:                  if(fd->pos > fd->dir_entry.file_size)
1185:                  {
1186:              #if !FAT_DELAY_DIRENTRY_UPDATE
1187:                      uint32_t size_old = fd->dir_entry.file_size;
1188:              #endif
1189:              
1190:                      /* update file size */
1191:                      fd->dir_entry.file_size = fd->pos;
1192:              
1193:              #if !FAT_DELAY_DIRENTRY_UPDATE
1194:                      /* write directory entry */
1195:                      if(!fat_write_dir_entry(fd->fs, &fd->dir_entry))
1196:                      {
1197:                          /* We do not return an error here since we actually wrote
1198:                           * some data to disk. So we calculate the amount of data
1199:                           * we wrote to disk and which lies within the old file size.
1200:                           */
1201:                          buffer_left = fd->pos - size_old;
1202:                          fd->pos = size_old;
1203:                      }
1204:              #endif
1205:                  }
1206:              
1207:                  return buffer_len - buffer_left;
1208:              }
1209:              #endif
1210:              
1211:              /**
1212:               * \ingroup fat_file
1213:               * Repositions the read/write file offset.
1214:               *
1215:               * Changes the file offset where the next call to fat_read_file()
1216:               * or fat_write_file() starts reading/writing.
1217:               *
1218:               * If the new offset is beyond the end of the file, fat_resize_file()
1219:               * is implicitly called, i.e. the file is expanded.
1220:               *
1221:               * The new offset can be given in different ways determined by
1222:               * the \c whence parameter:
1223:               * - \b FAT_SEEK_SET: \c *offset is relative to the beginning of the file.
1224:               * - \b FAT_SEEK_CUR: \c *offset is relative to the current file position.
1225:               * - \b FAT_SEEK_END: \c *offset is relative to the end of the file.
1226:               *
1227:               * The resulting absolute offset is written to the location the \c offset
1228:               * parameter points to.
1229:               *
1230:               * Calling this function can also be used to retrieve the current file position:
1231:                 \code
1232:                 int32_t file_pos = 0;
1233:                 if(!fat_seek_file(fd, &file_pos, FAT_SEEK_CUR))
1234:                 {
1235:                     // error
1236:                 }
1237:                 // file_pos now contains the absolute file position
1238:                 \endcode
1239:               * 
1240:               * \param[in] fd The file decriptor of the file on which to seek.
1241:               * \param[in,out] offset A pointer to the new offset, as affected by the \c whence
1242:               *                   parameter. The function writes the new absolute offset
1243:               *                   to this location before it returns.
1244:               * \param[in] whence Affects the way \c offset is interpreted, see above.
1245:               * \returns 0 on failure, 1 on success.
1246:               */
1247:              uint8_t fat_seek_file(struct fat_file_struct* fd, int32_t* offset, uint8_t whence)
1248:              {
1249:                  if(!fd || !offset)
002E2C  500FE0     SUB W0, #0x0, [W15]
002E2E  320022     BRA Z, 0x2E74
002E30  508FE0     SUB W1, #0x0, [W15]
002E32  320020     BRA Z, 0x2E74
1250:                      return 0;
002E2A  EB4200     CLR.B W4
1251:              
1252:                  uint32_t new_pos = fd->pos;
002E34  901370     MOV [W0+46], W6
002E36  901B80     MOV [W0+48], W7
1253:                  switch(whence)
002E38  514FE1     SUB.B W2, #0x1, [W15]
002E3A  320007     BRA Z, 0x2E4A
002E3C  390004     BRA NC, 0x2E46
002E40  514FE2     SUB.B W2, #0x2, [W15]
002E42  3A0018     BRA NZ, 0x2E74
002E44  370006     BRA 0x2E52
1254:                  {
1255:                      case FAT_SEEK_SET:
1256:                          new_pos = *offset;
002E46  BE0311     MOV.D [W1], W6
1257:                          break;
002E48  370009     BRA 0x2E5C
1258:                      case FAT_SEEK_CUR:
1259:                          new_pos += *offset;
002E4A  430231     ADD W6, [W1++], W4
002E4C  4B82A1     ADDC W7, [W1--], W5
002E4E  BE0304     MOV.D W4, W6
1260:                          break;
002E50  370005     BRA 0x2E5C
1261:                      case FAT_SEEK_END:
1262:                          new_pos = fd->dir_entry.file_size + *offset;
002E52  901330     MOV [W0+38], W6
002E54  9013C0     MOV [W0+40], W7
002E56  430231     ADD W6, [W1++], W4
002E58  4B82A1     ADDC W7, [W1--], W5
002E5A  BE0304     MOV.D W4, W6
1263:                          break;
1264:                      default:
1265:                          return 0;
002E3E  EB4200     CLR.B W4
1266:                  }
1267:              
1268:                  if(new_pos > fd->dir_entry.file_size
002E5C  901130     MOV [W0+38], W2
002E5E  9011C0     MOV [W0+40], W3
002E62  530F82     SUB W6, W2, [W15]
002E64  5B8F83     SUBB W7, W3, [W15]
002E66  3E0006     BRA GTU, 0x2E74
1269:              #if FAT_WRITE_SUPPORT
1270:                     && !fat_resize_file(fd, new_pos)
1271:              #endif
1272:                     )
1273:                      return 0;
002E60  EB4200     CLR.B W4
1274:              
1275:                  fd->pos = new_pos;
002E68  981076     MOV W6, [W0+46]
002E6A  981807     MOV W7, [W0+48]
1276:                  fd->pos_cluster = 0;
002E6C  EB0200     CLR W4
002E6E  981814     MOV W4, [W0+50]
1277:              
1278:                  *offset = (int32_t) new_pos;
002E70  BE8886     MOV.D W6, [W1]
1279:                  return 1;
002E72  B3C014     MOV.B #0x1, W4
1280:              }
002E74  784004     MOV.B W4, W0
002E76  060000     RETURN
1281:              
1282:              #if DOXYGEN || FAT_WRITE_SUPPORT
1283:              /**
1284:               * \ingroup fat_file
1285:               * Resizes a file to have a specific size.
1286:               *
1287:               * Enlarges or shrinks the file pointed to by the file descriptor to have
1288:               * exactly the specified size.
1289:               *
1290:               * If the file is truncated, all bytes having an equal or larger offset
1291:               * than the given size are lost. If the file is expanded, the additional
1292:               * bytes are allocated.
1293:               *
1294:               * \note Please be aware that this function just allocates or deallocates disk
1295:               * space, it does not explicitely clear it. To avoid data leakage, this
1296:               * must be done manually.
1297:               *
1298:               * \param[in] fd The file decriptor of the file which to resize.
1299:               * \param[in] size The new size of the file.
1300:               * \returns 0 on failure, 1 on success.
1301:               */
1302:              uint8_t fat_resize_file(struct fat_file_struct* fd, uint32_t size)
1303:              {
1304:                  if(!fd)
1305:                      return 0;
1306:              
1307:                  cluster_t cluster_num = fd->dir_entry.cluster;
1308:                  uint16_t cluster_size = fd->fs->header.cluster_size;
1309:                  uint32_t size_new = size;
1310:              
1311:                  do
1312:                  {
1313:                      if(cluster_num == 0 && size_new == 0)
1314:                          /* the file stays empty */
1315:                          break;
1316:              
1317:                      /* seek to the next cluster as long as we need the space */
1318:                      while(size_new > cluster_size)
1319:                      {
1320:                          /* get next cluster of file */
1321:                          cluster_t cluster_num_next = fat_get_next_cluster(fd->fs, cluster_num);
1322:                          if(cluster_num_next)
1323:                          {
1324:                              cluster_num = cluster_num_next;
1325:                              size_new -= cluster_size;
1326:                          }
1327:                          else
1328:                          {
1329:                              break;
1330:                          }
1331:                      }
1332:              
1333:                      if(size_new > cluster_size || cluster_num == 0)
1334:                      {
1335:                          /* Allocate new cluster chain and append
1336:                           * it to the existing one, if available.
1337:                           */
1338:                          cluster_t cluster_count = (size_new + cluster_size - 1) / cluster_size;
1339:                          cluster_t cluster_new_chain = fat_append_clusters(fd->fs, cluster_num, cluster_count);
1340:                          if(!cluster_new_chain)
1341:                              return 0;
1342:              
1343:                          if(!cluster_num)
1344:                          {
1345:                              cluster_num = cluster_new_chain;
1346:                              fd->dir_entry.cluster = cluster_num;
1347:                          }
1348:                      }
1349:              
1350:                      /* write new directory entry */
1351:                      fd->dir_entry.file_size = size;
1352:                      if(size == 0)
1353:                          fd->dir_entry.cluster = 0;
1354:                      if(!fat_write_dir_entry(fd->fs, &fd->dir_entry))
1355:                          return 0;
1356:              
1357:                      if(size == 0)
1358:                      {
1359:                          /* free all clusters of file */
1360:                          fat_free_clusters(fd->fs, cluster_num);
1361:                      }
1362:                      else if(size_new <= cluster_size)
1363:                      {
1364:                          /* free all clusters no longer needed */
1365:                          fat_terminate_clusters(fd->fs, cluster_num);
1366:                      }
1367:              
1368:                  } while(0);
1369:              
1370:                  /* correct file position */
1371:                  if(size < fd->pos)
1372:                  {
1373:                      fd->pos = size;
1374:                      fd->pos_cluster = 0;
1375:                  }
1376:              
1377:                  return 1;
1378:              }
1379:              #endif
1380:              
1381:              /**
1382:               * \ingroup fat_dir
1383:               * Opens a directory.
1384:               *
1385:               * \param[in] fs The filesystem on which the directory to open resides.
1386:               * \param[in] dir_entry The directory entry which stands for the directory to open.
1387:               * \returns An opaque directory descriptor on success, 0 on failure.
1388:               * \see fat_close_dir
1389:               */
1390:              struct fat_dir_struct* fat_open_dir(struct fat_fs_struct* fs, const struct fat_dir_entry_struct* dir_entry)
1391:              {
1392:                  if(!fs || !dir_entry || !(dir_entry->attributes & FAT_ATTRIB_DIR))
002E7A  500F84     SUB W0, W4, [W15]
002E7C  320019     BRA Z, 0x2EB0
002E7E  508F84     SUB W1, W4, [W15]
002E80  320017     BRA Z, 0x2EB0
002E82  906281     MOV.B [W1+32], W5
002E84  6282F0     AND W5, #0x10, W5
002E86  528F84     SUB W5, W4, [W15]
002E88  320013     BRA Z, 0x2EB0
1393:                      return 0;
002E78  EB0200     CLR W4
1394:              
1395:              #if USE_DYNAMIC_MEMORY
1396:                  struct fat_dir_struct* dd = malloc(sizeof(*dd));
1397:                  if(!dd)
1398:                      return 0;
1399:              #else
1400:                  struct fat_dir_struct* dd = fat_dir_handles;
1401:                  uint8_t i;
1402:                  for(i = 0; i < FAT_DIR_COUNT; ++i)
1403:                  {
1404:                      if(!dd->fs)
002E8A  80E394     MOV fat_dir_handles, W4
002E8C  520FE0     SUB W4, #0x0, [W15]
002E8E  320006     BRA Z, 0x2E9C
002E92  80E525     MOV 0x1CA4, W5
002E94  528F84     SUB W5, W4, [W15]
002E96  3A000C     BRA NZ, 0x2EB0
002E98  21CA44     MOV #0x1CA4, W4
002E9A  370001     BRA 0x2E9E
002E9C  21C724     MOV #0x1C72, W4
1405:                          break;
1406:              
1407:                      ++dd;
1408:                  }
1409:                  if(i >= FAT_DIR_COUNT)
1410:                      return 0;
002E90  EB0200     CLR W4
1411:              #endif
1412:                  
1413:                  memcpy(&dd->dir_entry, dir_entry, sizeof(*dir_entry));
002E9E  4202E2     ADD W4, #0x2, W5
002EA0  090015     REPEAT #0x15
002EA2  781AB1     MOV [W1++], [W5++]
002EA4  B102C1     SUB #0x2C, W1
1414:                  dd->fs = fs;
002EA6  780A00     MOV W0, [W4]
1415:                  dd->entry_cluster = dir_entry->cluster;
002EA8  901091     MOV [W1+34], W1
002EAA  981271     MOV W1, [W4+46]
1416:                  dd->entry_offset = 0;
002EAC  EB0280     CLR W5
002EAE  981A05     MOV W5, [W4+48]
1417:              
1418:                  return dd;
1419:              }
002EB0  780004     MOV W4, W0
002EB2  060000     RETURN
1420:              
1421:              /**
1422:               * \ingroup fat_dir
1423:               * Closes a directory descriptor.
1424:               *
1425:               * This function destroys a directory descriptor which was
1426:               * previously obtained by calling fat_open_dir(). When this
1427:               * function returns, the given descriptor will be invalid.
1428:               *
1429:               * \param[in] dd The directory descriptor to close.
1430:               * \see fat_open_dir
1431:               */
1432:              void fat_close_dir(struct fat_dir_struct* dd)
1433:              {
1434:                  if(dd)
002EB4  500FE0     SUB W0, #0x0, [W15]
002EB6  320001     BRA Z, 0x2EBA
1435:              #if USE_DYNAMIC_MEMORY
1436:                      free(dd);
1437:              #else
1438:                      dd->fs = 0;
002EB8  EB0800     CLR [W0]
1439:              #endif
1440:              }
002EBA  060000     RETURN
1441:              
1442:              /**
1443:               * \ingroup fat_dir
1444:               * Reads the next directory entry contained within a parent directory.
1445:               *
1446:               * \param[in] dd The descriptor of the parent directory from which to read the entry.
1447:               * \param[out] dir_entry Pointer to a buffer into which to write the directory entry information.
1448:               * \returns 0 on failure, 1 on success.
1449:               * \see fat_reset_dir
1450:               */
1451:              uint8_t fat_read_dir(struct fat_dir_struct* dd, struct fat_dir_entry_struct* dir_entry)
1452:              {
002ED0  B002AF     ADD #0x2A, W15
002ED2  BE9F88     MOV.D W8, [W15++]
002ED4  BE9F8A     MOV.D W10, [W15++]
002ED6  BE9F8C     MOV.D W12, [W15++]
002ED8  781F8E     MOV W14, [W15++]
002EDA  9FBF80     MOV W0, [W15-16]
1453:                  if(!dd || !dir_entry)
002EDE  97BA0F     MOV [W15-16], W4
002EE0  520FE0     SUB W4, #0x0, [W15]
002EE2  320051     BRA Z, 0x2F86
002EE4  508FE0     SUB W1, #0x0, [W15]
002EE6  32004F     BRA Z, 0x2F86
1454:                      return 0;
002EDC  EB4000     CLR.B W0
1455:              
1456:                  /* get current position of directory handle */
1457:                  struct fat_fs_struct* fs = dd->fs;
002EE8  780494     MOV [W4], W9
1458:                  const struct fat_header_struct* header = &fs->header;
1459:                  uint16_t cluster_size = header->cluster_size;
002EEA  900D89     MOV [W9+16], W11
1460:                  cluster_t cluster_num = dd->entry_cluster;
002EEC  901774     MOV [W4+46], W14
1461:                  uint16_t cluster_offset = dd->entry_offset;
002EEE  901C04     MOV [W4+48], W8
1462:                  struct fat_read_dir_callback_arg arg;
1463:              
1464:                  if(cluster_offset >= cluster_size)
002EF0  558F88     SUB W11, W8, [W15]
002EF2  3E0004     BRA GTU, 0x2EFC
1465:                  {
1466:                      /* The latest call hit the border of the last cluster in
1467:                       * the chain, but it still returned a directory entry.
1468:                       * So we now reset the handle and signal the caller the
1469:                       * end of the listing.
1470:                       */
1471:                      fat_reset_dir(dd);
002EF4  780004     MOV W4, W0
002EF6  07FFE2     RCALL fat_reset_dir
1472:                      return 0;
002EF8  EB4000     CLR.B W0
002EFA  370045     BRA 0x2F86
1473:                  }
1474:              
1475:                  /* reset callback arguments */
1476:                  memset(&arg, 0, sizeof(arg));
002EFC  78020F     MOV W15, W4
002EFE  B10364     SUB #0x36, W4
002F00  090002     REPEAT #0x2
002F02  EB1A00     CLR [W4++]
1477:                  memset(dir_entry, 0, sizeof(*dir_entry));
002F04  090015     REPEAT #0x15
002F06  EB1880     CLR [W1++]
002F08  B102C1     SUB #0x2C, W1
1478:                  arg.dir_entry = dir_entry;
002F0A  9FA7D1     MOV W1, [W15-54]
1479:              
1480:                  /* check if we read from the root directory */
1481:                  if(cluster_num == 0)
002F0C  570FE0     SUB W14, #0x0, [W15]
002F0E  3A0032     BRA NZ, 0x2F74
1482:                  {
1483:              #if FAT_FAT32_SUPPORT
1484:                      if(fs->partition->type == PARTITION_TYPE_FAT32)
1485:                          cluster_num = header->root_dir_cluster;
1486:                      else
1487:              #endif
1488:                          cluster_size = header->cluster_zero_offset - header->root_dir_offset;
002F10  900D99     MOV [W9+18], W11
002F12  900A39     MOV [W9+22], W4
002F14  558584     SUB W11, W4, W11
002F16  37002E     BRA 0x2F74
1489:                  }
1490:              
1491:                  /* read entries */
1492:                  uint8_t buffer[32];
1493:                  while(!arg.finished)
002F74  97CA7F     MOV.B [W15-49], W4
002F76  524FE0     SUB.B W4, #0x0, [W15]
002F78  32FFCF     BRA Z, 0x2F18
1494:                  {
1495:                      /* read directory entries up to the cluster border */
1496:                      uint16_t cluster_left = cluster_size - cluster_offset;
002F18  558508     SUB W11, W8, W10
1497:                      offset_t pos = cluster_offset;
002F1A  B84661     MUL.UU W8, #1, W12
1498:                      if(cluster_num == 0)
002F1C  570FE0     SUB W14, #0x0, [W15]
002F1E  3A0005     BRA NZ, 0x2F2A
1499:                          pos += header->root_dir_offset;
002F20  900839     MOV [W9+22], W0
002F22  9008C9     MOV [W9+24], W1
002F24  40000C     ADD W0, W12, W0
002F26  48808D     ADDC W1, W13, W1
002F28  370005     BRA 0x2F34
1500:                      else
1501:                          pos += fat_cluster_offset(fs, cluster_num);
002F2A  78008E     MOV W14, W1
002F2C  780009     MOV W9, W0
002F2E  07FD24     RCALL _fat_cluster_offset
002F30  460000     ADD W12, W0, W0
002F32  4E8081     ADDC W13, W1, W1
1502:              
1503:                      arg.bytes_read = 0;
002F34  EB0200     CLR W4
002F36  9FA7E4     MOV W4, [W15-52]
1504:                      if(!fs->partition->device_read_interval(pos,
002F38  780219     MOV [W9], W4
002F3A  900394     MOV [W4+2], W7
002F3C  2FFCA6     MOV #0xFFCA, W6
002F3E  43030F     ADD W6, W15, W6
002F40  229D65     MOV #0x29D6, W5
002F42  78020A     MOV W10, W4
002F44  200203     MOV #0x20, W3
002F46  2FFD02     MOV #0xFFD0, W2
002F48  41010F     ADD W2, W15, W2
002F4A  010007     CALL W7
002F4C  504FE0     SUB.B W0, #0x0, [W15]
002F4E  32001A     BRA Z, 0x2F84
1505:                                                              buffer,
1506:                                                              sizeof(buffer),
1507:                                                              cluster_left,
1508:                                                              fat_dir_entry_read_callback,
1509:                                                              &arg)
1510:                        )
1511:                          return 0;
002F84  EB4000     CLR.B W0
1512:              
1513:                      cluster_offset += arg.bytes_read;
002F50  97A26F     MOV [W15-52], W4
002F52  440404     ADD W8, W4, W8
1514:              
1515:                      if(cluster_offset >= cluster_size)
002F54  540F8B     SUB W8, W11, [W15]
002F56  39000E     BRA NC, 0x2F74
1516:                      {
1517:                          /* we reached the cluster border and switch to the next cluster */
1518:              
1519:                          /* get number of next cluster */
1520:                          if((cluster_num = fat_get_next_cluster(fs, cluster_num)) != 0)
002F58  78008E     MOV W14, W1
002F5A  780009     MOV W9, W0
002F5C  07FCE4     RCALL _fat_get_next_cluster
002F5E  780700     MOV W0, W14
002F60  570FE0     SUB W14, #0x0, [W15]
002F62  3A0007     BRA NZ, 0x2F72
1521:                          {
1522:                              cluster_offset = 0;
002F72  EB0400     CLR W8
1523:                              continue;
1524:                          }
1525:              
1526:                          /* we are at the end of the cluster chain */
1527:                          if(!arg.finished)
002F64  97CA7F     MOV.B [W15-49], W4
002F66  524FE0     SUB.B W4, #0x0, [W15]
002F68  3A0008     BRA NZ, 0x2F7A
1528:                          {
1529:                              /* directory entry not found, reset directory handle */
1530:                              fat_reset_dir(dd);
002F6A  97B80F     MOV [W15-16], W0
002F6C  07FFA7     RCALL fat_reset_dir
1531:                              return 0;
002F6E  EB4000     CLR.B W0
002F70  37000A     BRA 0x2F86
1532:                          }
1533:                          else
1534:                          {
1535:                              /* The current execution of the function has been successful,
1536:                               * so we can not signal an end of the directory listing to
1537:                               * the caller, but must wait for the next call. So we keep an
1538:                               * invalid cluster offset to mark this directory handle's
1539:                               * traversal as finished.
1540:                               */
1541:                          }
1542:              
1543:                          break;
1544:                      }
1545:                  }
1546:              
1547:                  dd->entry_cluster = cluster_num;
002F7A  97BA0F     MOV [W15-16], W4
002F7C  98127E     MOV W14, [W4+46]
1548:                  dd->entry_offset = cluster_offset;
002F7E  981A08     MOV W8, [W4+48]
1549:              
1550:                  return arg.finished;
002F80  97C87F     MOV.B [W15-49], W0
002F82  370001     BRA 0x2F86
1551:              }
002F86  78074F     MOV [--W15], W14
002F88  BE064F     MOV.D [--W15], W12
002F8A  BE054F     MOV.D [--W15], W10
002F8C  BE044F     MOV.D [--W15], W8
002F8E  B102AF     SUB #0x2A, W15
002F90  060000     RETURN
1552:              
1553:              /**
1554:               * \ingroup fat_dir
1555:               * Resets a directory handle.
1556:               *
1557:               * Resets the directory handle such that reading restarts
1558:               * with the first directory entry.
1559:               *
1560:               * \param[in] dd The directory handle to reset.
1561:               * \returns 0 on failure, 1 on success.
1562:               * \see fat_read_dir
1563:               */
1564:              uint8_t fat_reset_dir(struct fat_dir_struct* dd)
1565:              {
1566:                  if(!dd)
002EBE  500FE0     SUB W0, #0x0, [W15]
002EC0  320005     BRA Z, 0x2ECC
1567:                      return 0;
002EBC  EB4200     CLR.B W4
1568:              
1569:                  dd->entry_cluster = dd->dir_entry.cluster;
002EC2  901220     MOV [W0+36], W4
002EC4  981074     MOV W4, [W0+46]
1570:                  dd->entry_offset = 0;
002EC6  EB0200     CLR W4
002EC8  981804     MOV W4, [W0+48]
1571:                  return 1;
002ECA  B3C014     MOV.B #0x1, W4
1572:              }
002ECC  784004     MOV.B W4, W0
002ECE  060000     RETURN
1573:              
1574:              /**
1575:               * \ingroup fat_fs
1576:               * Callback function for reading a directory entry.
1577:               *
1578:               * Interprets a raw directory entry and puts the contained
1579:               * information into a fat_dir_entry_struct structure.
1580:               * 
1581:               * For a single file there may exist multiple directory
1582:               * entries. All except the last one are lfn entries, which
1583:               * contain parts of the long filename. The last directory
1584:               * entry is a traditional 8.3 style one. It contains all
1585:               * other information like size, cluster, date and time.
1586:               * 
1587:               * \param[in] buffer A pointer to 32 bytes of raw data.
1588:               * \param[in] offset The absolute offset of the raw data.
1589:               * \param[in,out] p An argument structure controlling operation.
1590:               * \returns 0 on failure or completion, 1 if reading has
1591:               *          to be continued
1592:               */
1593:              uint8_t fat_dir_entry_read_callback(uint8_t* buffer, offset_t offset, void* p)
002A76  E8028A     INC W10, W5
002ACE  450069     ADD W10, #0x9, W0
002AD0  424264     ADD.B W4, #0x4, W4
002ADA  780380     MOV W0, W7
002B3E  460605     ADD W12, W5, W12
002B40  578370     SUB W15, #0x10, W6
002B42  37FF83     BRA 0x2A4A
1594:              {
0029D6  4787F0     ADD W15, #0x10, W15
0029D8  BE9F88     MOV.D W8, [W15++]
0029DA  BE9F8A     MOV.D W10, [W15++]
0029DC  BE9F8C     MOV.D W12, [W15++]
0029DE  781F8E     MOV W14, [W15++]
0029E0  780500     MOV W0, W10
0029E2  BE0402     MOV.D W2, W8
0029E4  780581     MOV W1, W11
1595:                  struct fat_read_dir_callback_arg* arg = p;
1596:                  struct fat_dir_entry_struct* dir_entry = arg->dir_entry;
0029E6  78061B     MOV [W11], W12
1597:              
1598:                  arg->bytes_read += 32;
0029E8  90021B     MOV [W11+2], W4
0029EA  B00204     ADD #0x20, W4
0029EC  980594     MOV W4, [W11+2]
1599:              
1600:                  /* skip deleted or empty entries */
1601:                  if(buffer[0] == FAT_DIRENTRY_DELETED || !buffer[0])
0029EE  78421A     MOV.B [W10], W4
0029F0  424FFB     ADD.B W4, #0x1B, [W15]
0029F2  320002     BRA Z, 0x29F8
0029F4  524FE0     SUB.B W4, #0x0, [W15]
0029F6  3A0004     BRA NZ, 0x2A00
1602:                  {
1603:              #if FAT_LFN_SUPPORT
1604:                      arg->checksum = 0;
0029F8  EB4200     CLR.B W4
0029FA  9845C4     MOV.B W4, [W11+4]
1605:              #endif
1606:                      return 1;
0029FC  B3C010     MOV.B #0x1, W0
0029FE  370093     BRA 0x2B26
1607:                  }
1608:              
1609:              #if !FAT_LFN_SUPPORT
1610:                  /* skip lfn entries */
1611:                  if(buffer[11] == 0x0f)
1612:                      return 1;
1613:              #endif
1614:              
1615:                  char* long_name = dir_entry->long_name;
1616:              #if FAT_LFN_SUPPORT
1617:                  if(buffer[11] == 0x0f)
002A00  4506EB     ADD W10, #0xB, W13
002A02  B3C0F4     MOV.B #0xF, W4
002A04  124F9D     SUBR.B W4, [W13], [W15]
002A06  3A0025     BRA NZ, 0x2A52
1618:                  {
1619:                      /* checksum validation */
1620:                      if(arg->checksum == 0 || arg->checksum != buffer[13])
002A08  90424B     MOV.B [W11+4], W4
002A0A  524FE0     SUB.B W4, #0x0, [W15]
002A0C  320003     BRA Z, 0x2A14
002A0E  904ADA     MOV.B [W10+13], W5
002A10  524F85     SUB.B W4, W5, [W15]
002A12  320007     BRA Z, 0x2A22
1621:                      {
1622:                          /* reset directory entry */
1623:                          memset(dir_entry, 0, sizeof(*dir_entry));
002A14  090015     REPEAT #0x15
002A16  EB1E00     CLR [W12++]
002A18  B102CC     SUB #0x2C, W12
1624:              
1625:                          arg->checksum = buffer[13];
002A1A  904ADA     MOV.B [W10+13], W5
002A1C  9845C5     MOV.B W5, [W11+4]
1626:                          dir_entry->entry_offset = offset;
002A1E  981648     MOV W8, [W12+40]
002A20  981659     MOV W9, [W12+42]
1627:                      }
1628:              
1629:                      /* lfn supports unicode, but we do not, for now.
1630:                       * So we assume pure ascii and read only every
1631:                       * second byte.
1632:                       */
1633:                      uint16_t char_offset = ((buffer[0] & 0x3f) - 1) * 13;
002A22  78431A     MOV.B [W10], W6
002A24  FB8206     ZE W6, W4
002A26  B203F4     AND #0x3F, W4
002A28  E90204     DEC W4, W4
002A2A  B9226D     MUL.SU W4, #13, W4
002A2C  780284     MOV W4, W5
1634:                      const uint8_t char_mapping[] = { 1, 3, 5, 7, 9, 14, 16, 18, 20, 22, 24, 28, 30 };
002A2E  5783FC     SUB W15, #0x1C, W7
002A30  2A9184     MOV #0xA918, W4
002A32  09000C     REPEAT #0xC
002A34  785BB4     MOV.B [W4++], [W7++]
1635:                      uint8_t i;
1636:                      for(i = 0; i <= 12 && char_offset + i < sizeof(dir_entry->long_name) - 1; ++i)
002A38  528FFE     SUB W5, #0x1E, [W15]
002A3A  36007B     BRA LEU, 0x2B32
002A3C  370074     BRA 0x2B26
002A46  570F86     SUB W14, W6, [W15]
002A48  32006D     BRA Z, 0x2B24
002A4A  520FFE     SUB W4, #0x1E, [W15]
002A4C  36FFF8     BRA LEU, 0x2A3E
1637:                          long_name[char_offset + i] = buffer[char_mapping[i]];
002A3E  7843DE     MOV.B [++W14], W7
002A40  FB8287     ZE W7, W5
002A42  7AEE6A     MOV.B [W10+W5], [++W12]
002A44  E80204     INC W4, W4
002B32  97E34F     MOV.B [W15-28], W6
002B34  FB8206     ZE W6, W4
002B36  7A426A     MOV.B [W10+W4], W4
002B38  7AF604     MOV.B W4, [W12+W5]
002B3A  E80205     INC W5, W4
002B3C  57877C     SUB W15, #0x1C, W14
1638:              
1639:                      return 1;
002A36  B3C010     MOV.B #0x1, W0
002A4E  B3C010     MOV.B #0x1, W0
002A50  37006A     BRA 0x2B26
002B24  B3C010     MOV.B #0x1, W0
1640:                  }
1641:                  else
1642:              #endif
1643:                  {
1644:              #if FAT_LFN_SUPPORT
1645:                      /* if we do not have a long name or the previous lfn does not match, take the 8.3 name */
1646:                      if(long_name[0] == '\0' || arg->checksum != fat_calc_83_checksum(buffer))
002A52  EB4200     CLR.B W4
002A54  124F9C     SUBR.B W4, [W12], [W15]
002A56  320005     BRA Z, 0x2A62
002A58  78000A     MOV W10, W0
002A5A  07FF9C     RCALL _fat_calc_83_checksum
002A5C  90424B     MOV.B [W11+4], W4
002A5E  524F80     SUB.B W4, W0, [W15]
002A60  320054     BRA Z, 0x2B0A
1647:              #endif
1648:                      {
1649:                          /* reset directory entry */
1650:                          memset(dir_entry, 0, sizeof(*dir_entry));
002A62  090015     REPEAT #0x15
002A64  EB1E00     CLR [W12++]
002A66  B102CC     SUB #0x2C, W12
1651:                          dir_entry->entry_offset = offset;
002A68  981648     MOV W8, [W12+40]
002A6A  981659     MOV W9, [W12+42]
1652:              
1653:                          uint8_t i;
1654:                          for(i = 0; i < 8; ++i)
002A6E  EB4200     CLR.B W4
002A7C  784207     MOV.B W7, W4
002AA6  E84204     INC.B W4, W4
002AA8  524FE8     SUB.B W4, #0x8, [W15]
002AAA  3AFFED     BRA NZ, 0x2A86
1655:                          {
1656:                              if(buffer[i] == ' ')
002A6C  78431A     MOV.B [W10], W6
002A70  B3C205     MOV.B #0x20, W5
002A72  534F85     SUB.B W6, W5, [W15]
002A74  32001B     BRA Z, 0x2AAC
002A78  78008A     MOV W10, W1
002A7A  EB0380     CLR W7
002A82  B3C202     MOV.B #0x20, W2
002A84  370005     BRA 0x2A90
002A86  52838A     SUB W5, W10, W7
002A88  780085     MOV W5, W1
002A8A  784335     MOV.B [W5++], W6
002A8C  534F82     SUB.B W6, W2, [W15]
002A8E  32000E     BRA Z, 0x2AAC
1657:                                  break;
1658:                              long_name[i] = buffer[i];
002A90  7BF606     MOV.B W6, [W12+W7]
1659:              
1660:                              /* Windows NT and later versions do not store lfn entries
1661:                               * for 8.3 names which have a lowercase basename, extension
1662:                               * or both when everything else is uppercase. They use two
1663:                               * extra bits to signal a lowercase basename or extension.
1664:                               */
1665:                              if((buffer[12] & 0x08) && buffer[i] >= 'A' && buffer[i] <= 'Z')
002A7E  B3C403     MOV.B #0x40, W3
002A80  B3C5A8     MOV.B #0x5A, W8
002A92  90484A     MOV.B [W10+12], W0
002A94  600068     AND W0, #0x8, W0
002A96  320007     BRA Z, 0x2AA6
002A98  784011     MOV.B [W1], W0
002A9A  504F83     SUB.B W0, W3, [W15]
002A9C  360004     BRA LEU, 0x2AA6
002A9E  504F88     SUB.B W0, W8, [W15]
002AA0  3E0002     BRA GTU, 0x2AA6
1666:                                  long_name[i] += 'a' - 'A';
002AA2  B04206     ADD.B #0x20, W6
002AA4  7BF606     MOV.B W6, [W12+W7]
1667:                          }
1668:                          if(long_name[0] == 0x05)
002AAC  B3C055     MOV.B #0x5, W5
002AAE  12CF9C     SUBR.B W5, [W12], [W15]
002AB0  3A0002     BRA NZ, 0x2AB6
1669:                              long_name[0] = (char) FAT_DIRENTRY_DELETED;
002AB2  B3CE55     MOV.B #0xE5, W5
002AB4  784E05     MOV.B W5, [W12]
1670:              
1671:                          if(buffer[8] != ' ')
002AB6  4503E8     ADD W10, #0x8, W7
002AB8  B3C205     MOV.B #0x20, W5
002ABA  12CF97     SUBR.B W5, [W7], [W15]
002ABC  320022     BRA Z, 0x2B02
002B02  784284     MOV.B W4, W5
1672:                          {
1673:                              long_name[i++] = '.';
002ABE  FB8284     ZE W4, W5
002AC0  B3C2E6     MOV.B #0x2E, W6
002AC2  7AF606     MOV.B W6, [W12+W5]
002AC4  E84284     INC.B W4, W5
1674:              
1675:                              uint8_t j = 8;
1676:                              for(; j < 11; ++j)
002AFC  52CF84     SUB.B W5, W4, [W15]
002AFE  3AFFED     BRA NZ, 0x2ADA
002B00  370001     BRA 0x2B04
1677:                              {
1678:                                  if(buffer[j] == ' ')
002AC6  784317     MOV.B [W7], W6
002AC8  B3C200     MOV.B #0x20, W0
002ACA  534F80     SUB.B W6, W0, [W15]
002ACC  32001B     BRA Z, 0x2B04
002AD6  B3C203     MOV.B #0x20, W3
002AD8  370004     BRA 0x2AE2
002ADC  784330     MOV.B [W0++], W6
002ADE  534F83     SUB.B W6, W3, [W15]
002AE0  320011     BRA Z, 0x2B04
1679:                                      break;
1680:                                  long_name[i] = buffer[j];
002AE2  FB8085     ZE W5, W1
002AE4  78F606     MOV.B W6, [W12+W1]
1681:              
1682:                                  /* See above for the lowercase 8.3 name handling of
1683:                                   * Windows NT and later.
1684:                                   */
1685:                                  if((buffer[12] & 0x10) && buffer[j] >= 'A' && buffer[j] <= 'Z')
002AD2  B3C408     MOV.B #0x40, W8
002AD4  B3C5AE     MOV.B #0x5A, W14
002AE6  90494A     MOV.B [W10+12], W2
002AE8  610170     AND W2, #0x10, W2
002AEA  320007     BRA Z, 0x2AFA
002AEC  784397     MOV.B [W7], W7
002AEE  53CF88     SUB.B W7, W8, [W15]
002AF0  360004     BRA LEU, 0x2AFA
002AF2  53CF8E     SUB.B W7, W14, [W15]
002AF4  3E0002     BRA GTU, 0x2AFA
1686:                                      long_name[i] += 'a' - 'A';
002AF6  B04206     ADD.B #0x20, W6
002AF8  78F606     MOV.B W6, [W12+W1]
1687:              
1688:                                  ++i;
002AFA  E84285     INC.B W5, W5
1689:                              }
1690:                          } 
1691:              
1692:                          long_name[i] = '\0';
002B04  FB8285     ZE W5, W5
002B06  EB4200     CLR.B W4
002B08  7AF604     MOV.B W4, [W12+W5]
1693:                      }
1694:                      
1695:                      /* extract properties of file and store them within the structure */
1696:                      dir_entry->attributes = buffer[11];
002B0A  78469D     MOV.B [W13], W13
002B0C  98660D     MOV.B W13, [W12+32]
1697:                      dir_entry->cluster = read16(&buffer[26]);
002B0E  45007A     ADD W10, #0x1A, W0
002B10  071027     RCALL read16
002B12  981610     MOV W0, [W12+34]
1698:              #if FAT_FAT32_SUPPORT
1699:                      dir_entry->cluster |= ((cluster_t) read16(&buffer[20])) << 16;
1700:              #endif
1701:                      dir_entry->file_size = read32(&buffer[28]);
002B14  45007C     ADD W10, #0x1C, W0
002B16  07102A     RCALL read32
002B18  981620     MOV W0, [W12+36]
002B1A  981631     MOV W1, [W12+38]
1702:              
1703:              #if FAT_DATETIME_SUPPORT
1704:                      dir_entry->modification_time = read16(&buffer[22]);
1705:                      dir_entry->modification_date = read16(&buffer[24]);
1706:              #endif
1707:              
1708:                      arg->finished = 1;
002B1C  B3C014     MOV.B #0x1, W4
002B1E  9845D4     MOV.B W4, [W11+5]
1709:                      return 0;
002B20  EB4000     CLR.B W0
002B22  370001     BRA 0x2B26
1710:                  }
1711:              }
002B26  78074F     MOV [--W15], W14
002B28  BE064F     MOV.D [--W15], W12
002B2A  BE054F     MOV.D [--W15], W10
002B2C  BE044F     MOV.D [--W15], W8
002B2E  B1010F     SUB #0x10, W15
002B30  060000     RETURN
1712:              
1713:              #if DOXYGEN || FAT_LFN_SUPPORT
1714:              /**
1715:               * \ingroup fat_fs
1716:               * Calculates the checksum for 8.3 names used within the
1717:               * corresponding lfn directory entries.
1718:               *
1719:               * \param[in] file_name_83 The 11-byte file name buffer.
1720:               * \returns The checksum of the given file name.
1721:               */
1722:              uint8_t fat_calc_83_checksum(const uint8_t* file_name_83)
002998  42036A     ADD W4, #0xA, W6
1723:              {
002994  780200     MOV W0, W4
1724:                  uint8_t checksum = file_name_83[0];
002996  784014     MOV.B [W4], W0
1725:                  uint8_t i;
1726:                  for(i = 1; i < 11; ++i)
0029A4  520F86     SUB W4, W6, [W15]
0029A6  3AFFF9     BRA NZ, 0x299A
1727:                      checksum = ((checksum >> 1) | (checksum << 7)) + file_name_83[i];
00299A  FB8000     ZE W0, W0
00299C  DD02C7     SL W0, #7, W5
00299E  D10000     LSR W0, W0
0029A0  72C000     IOR.B W5, W0, W0
0029A2  404054     ADD.B W0, [++W4], W0
1728:              
1729:                  return checksum;
1730:              }
0029A8  060000     RETURN
1731:              #endif
1732:              
1733:              #if DOXYGEN || FAT_WRITE_SUPPORT
1734:              /**
1735:               * \ingroup fat_fs
1736:               * Searches for space where to store a directory entry.
1737:               *
1738:               * \param[in] fs The filesystem on which to operate.
1739:               * \param[in] parent The directory in which to search.
1740:               * \param[in] dir_entry The directory entry for which to search space.
1741:               * \returns 0 on failure, a device offset on success.
1742:               */
1743:              offset_t fat_find_offset_for_dir_entry(struct fat_fs_struct* fs, const struct fat_dir_struct* parent, const struct fat_dir_entry_struct* dir_entry)
1744:              {
1745:                  if(!fs || !dir_entry)
1746:                      return 0;
1747:              
1748:                  /* search for a place where to write the directory entry to disk */
1749:              #if FAT_LFN_SUPPORT
1750:                  uint8_t free_dir_entries_needed = (strlen(dir_entry->long_name) + 12) / 13 + 1;
1751:                  uint8_t free_dir_entries_found = 0;
1752:              #endif
1753:                  cluster_t cluster_num = parent->dir_entry.cluster;
1754:                  offset_t dir_entry_offset = 0;
1755:                  offset_t offset = 0;
1756:                  offset_t offset_to = 0;
1757:              #if FAT_FAT32_SUPPORT
1758:                  uint8_t is_fat32 = (fs->partition->type == PARTITION_TYPE_FAT32);
1759:              #endif
1760:              
1761:                  if(cluster_num == 0)
1762:                  {
1763:              #if FAT_FAT32_SUPPORT
1764:                      if(is_fat32)
1765:                      {
1766:                          cluster_num = fs->header.root_dir_cluster;
1767:                      }
1768:                      else
1769:              #endif
1770:                      {
1771:                          /* we read/write from the root directory entry */
1772:                          offset = fs->header.root_dir_offset;
1773:                          offset_to = fs->header.cluster_zero_offset;
1774:                          dir_entry_offset = offset;
1775:                      }
1776:                  }
1777:                  
1778:                  while(1)
1779:                  {
1780:                      if(offset == offset_to)
1781:                      {
1782:                          if(cluster_num == 0)
1783:                              /* We iterated through the whole root directory and
1784:                               * could not find enough space for the directory entry.
1785:                               */
1786:                              return 0;
1787:              
1788:                          if(offset)
1789:                          {
1790:                              /* We reached a cluster boundary and have to
1791:                               * switch to the next cluster.
1792:                               */
1793:              
1794:                              cluster_t cluster_next = fat_get_next_cluster(fs, cluster_num);
1795:                              if(!cluster_next)
1796:                              {
1797:                                  cluster_next = fat_append_clusters(fs, cluster_num, 1);
1798:                                  if(!cluster_next)
1799:                                      return 0;
1800:              
1801:                                  /* we appended a new cluster and know it is free */
1802:                                  dir_entry_offset = fs->header.cluster_zero_offset +
1803:                                                     (offset_t) (cluster_next - 2) * fs->header.cluster_size;
1804:              
1805:                                  /* clear cluster to avoid garbage directory entries */
1806:                                  fat_clear_cluster(fs, cluster_next);
1807:              
1808:                                  break;
1809:                              }
1810:                              cluster_num = cluster_next;
1811:                          }
1812:              
1813:                          offset = fat_cluster_offset(fs, cluster_num);
1814:                          offset_to = offset + fs->header.cluster_size;
1815:                          dir_entry_offset = offset;
1816:              #if FAT_LFN_SUPPORT
1817:                          free_dir_entries_found = 0;
1818:              #endif
1819:                      }
1820:                      
1821:                      /* read next lfn or 8.3 entry */
1822:                      uint8_t first_char;
1823:                      if(!fs->partition->device_read(offset, &first_char, sizeof(first_char)))
1824:                          return 0;
1825:              
1826:                      /* check if we found a free directory entry */
1827:                      if(first_char == FAT_DIRENTRY_DELETED || !first_char)
1828:                      {
1829:                          /* check if we have the needed number of available entries */
1830:              #if FAT_LFN_SUPPORT
1831:                          ++free_dir_entries_found;
1832:                          if(free_dir_entries_found >= free_dir_entries_needed)
1833:              #endif
1834:                              break;
1835:              
1836:                          offset += 32;
1837:                      }
1838:                      else
1839:                      {
1840:                          offset += 32;
1841:                          dir_entry_offset = offset;
1842:              #if FAT_LFN_SUPPORT
1843:                          free_dir_entries_found = 0;
1844:              #endif
1845:                      }
1846:                  }
1847:              
1848:                  return dir_entry_offset;
1849:              }
1850:              #endif
1851:              
1852:              #if DOXYGEN || FAT_WRITE_SUPPORT
1853:              /**
1854:               * \ingroup fat_fs
1855:               * Writes a directory entry to disk.
1856:               *
1857:               * \note The file name is not checked for invalid characters.
1858:               *
1859:               * \note The generation of the short 8.3 file name is quite
1860:               * simple. The first eight characters are used for the filename.
1861:               * The extension, if any, is made up of the first three characters
1862:               * following the last dot within the long filename. If the
1863:               * filename (without the extension) is longer than eight characters,
1864:               * the lower byte of the cluster number replaces the last two
1865:               * characters to avoid name clashes. In any other case, it is your
1866:               * responsibility to avoid name clashes.
1867:               *
1868:               * \param[in] fs The filesystem on which to operate.
1869:               * \param[in] dir_entry The directory entry to write.
1870:               * \returns 0 on failure, 1 on success.
1871:               */
1872:              uint8_t fat_write_dir_entry(const struct fat_fs_struct* fs, struct fat_dir_entry_struct* dir_entry)
1873:              {
1874:                  if(!fs || !dir_entry)
1875:                      return 0;
1876:                  
1877:              #if FAT_DATETIME_SUPPORT
1878:                  {
1879:                      uint16_t year;
1880:                      uint8_t month;
1881:                      uint8_t day;
1882:                      uint8_t hour;
1883:                      uint8_t min;
1884:                      uint8_t sec;
1885:              
1886:                      fat_get_datetime(&year, &month, &day, &hour, &min, &sec);
1887:                      fat_set_file_modification_date(dir_entry, year, month, day);
1888:                      fat_set_file_modification_time(dir_entry, hour, min, sec);
1889:                  }
1890:              #endif
1891:              
1892:                  device_write_t device_write = fs->partition->device_write;
1893:                  offset_t offset = dir_entry->entry_offset;
1894:                  const char* name = dir_entry->long_name;
1895:                  uint8_t name_len = strlen(name);
1896:              #if FAT_LFN_SUPPORT
1897:                  uint8_t lfn_entry_count = (name_len + 12) / 13;
1898:              #endif
1899:                  uint8_t buffer[32];
1900:              
1901:                  /* write 8.3 entry */
1902:              
1903:                  /* generate 8.3 file name */
1904:                  memset(&buffer[0], ' ', 11);
1905:                  char* name_ext = strrchr(name, '.');
1906:                  if(name_ext && *++name_ext)
1907:                  {
1908:                      uint8_t name_ext_len = strlen(name_ext);
1909:                      name_len -= name_ext_len + 1;
1910:              
1911:                      if(name_ext_len > 3)
1912:              #if FAT_LFN_SUPPORT
1913:                          name_ext_len = 3;
1914:              #else
1915:                          return 0;
1916:              #endif
1917:                      
1918:                      memcpy(&buffer[8], name_ext, name_ext_len);
1919:                  }
1920:                  
1921:                  if(name_len <= 8)
1922:                  {
1923:                      memcpy(buffer, name, name_len);
1924:              
1925:              #if FAT_LFN_SUPPORT
1926:                      /* For now, we create lfn entries for all files,
1927:                       * except the "." and ".." directory references.
1928:                       * This is to avoid difficulties with capitalization,
1929:                       * as 8.3 filenames allow uppercase letters only.
1930:                       *
1931:                       * Theoretically it would be possible to leave
1932:                       * the 8.3 entry alone if the basename and the
1933:                       * extension have no mixed capitalization.
1934:                       */
1935:                      if(name[0] == '.' &&
1936:                         ((name[1] == '.' && name[2] == '\0') ||
1937:                          name[1] == '\0')
1938:                        )
1939:                          lfn_entry_count = 0;
1940:              #endif
1941:                  }
1942:                  else
1943:                  {
1944:              #if FAT_LFN_SUPPORT
1945:                      memcpy(buffer, name, 8);
1946:              
1947:                      /* Minimize 8.3 name clashes by appending
1948:                       * the lower byte of the cluster number.
1949:                       */
1950:                      uint8_t num = dir_entry->cluster & 0xff;
1951:              
1952:                      buffer[6] = (num < 0xa0) ? ('0' + (num >> 4)) : ('a' + (num >> 4));
1953:                      num &= 0x0f;
1954:                      buffer[7] = (num < 0x0a) ? ('0' + num) : ('a' + num);
1955:              #else
1956:                      return 0;
1957:              #endif
1958:                  }
1959:                  if(buffer[0] == FAT_DIRENTRY_DELETED)
1960:                      buffer[0] = 0x05;
1961:              
1962:                  /* fill directory entry buffer */
1963:                  memset(&buffer[11], 0, sizeof(buffer) - 11);
1964:                  buffer[0x0b] = dir_entry->attributes;
1965:              #if FAT_DATETIME_SUPPORT
1966:                  write16(&buffer[0x16], dir_entry->modification_time);
1967:                  write16(&buffer[0x18], dir_entry->modification_date);
1968:              #endif
1969:              #if FAT_FAT32_SUPPORT
1970:                  write16(&buffer[0x14], (uint16_t) (dir_entry->cluster >> 16));
1971:              #endif
1972:                  write16(&buffer[0x1a], dir_entry->cluster);
1973:                  write32(&buffer[0x1c], dir_entry->file_size);
1974:              
1975:                  /* write to disk */
1976:              #if FAT_LFN_SUPPORT
1977:                  if(!device_write(offset + (uint16_t) lfn_entry_count * 32, buffer, sizeof(buffer)))
1978:              #else
1979:                  if(!device_write(offset, buffer, sizeof(buffer)))
1980:              #endif
1981:                      return 0;
1982:                  
1983:              #if FAT_LFN_SUPPORT
1984:                  /* calculate checksum of 8.3 name */
1985:                  uint8_t checksum = fat_calc_83_checksum(buffer);
1986:                  
1987:                  /* write lfn entries */
1988:                  for(uint8_t lfn_entry = lfn_entry_count; lfn_entry > 0; --lfn_entry)
1989:                  {
1990:                      memset(buffer, 0xff, sizeof(buffer));
1991:                      
1992:                      /* set file name */
1993:                      const char* long_name_curr = name + (lfn_entry - 1) * 13;
1994:                      uint8_t i = 1;
1995:                      while(i < 0x1f)
1996:                      {
1997:                          buffer[i++] = *long_name_curr;
1998:                          buffer[i++] = 0;
1999:              
2000:                          switch(i)
2001:                          {
2002:                              case 0x0b:
2003:                                  i = 0x0e;
2004:                                  break;
2005:                              case 0x1a:
2006:                                  i = 0x1c;
2007:                                  break;
2008:                          }
2009:              
2010:                          if(!*long_name_curr++)
2011:                              break;
2012:                      }
2013:                      
2014:                      /* set index of lfn entry */
2015:                      buffer[0x00] = lfn_entry;
2016:                      if(lfn_entry == lfn_entry_count)
2017:                          buffer[0x00] |= FAT_DIRENTRY_LFNLAST;
2018:              
2019:                      /* mark as lfn entry */
2020:                      buffer[0x0b] = 0x0f;
2021:              
2022:                      /* set 8.3 checksum */
2023:                      buffer[0x0d] = checksum;
2024:              
2025:                      /* clear reserved bytes */
2026:                      buffer[0x0c] = 0;
2027:                      buffer[0x1a] = 0;
2028:                      buffer[0x1b] = 0;
2029:              
2030:                      /* write entry */
2031:                      device_write(offset, buffer, sizeof(buffer));
2032:                  
2033:                      offset += sizeof(buffer);
2034:                  }
2035:              #endif
2036:                  
2037:                  return 1;
2038:              }
2039:              #endif
2040:              
2041:              #if DOXYGEN || FAT_WRITE_SUPPORT
2042:              /**
2043:               * \ingroup fat_file
2044:               * Creates a file.
2045:               *
2046:               * Creates a file and obtains the directory entry of the
2047:               * new file. If the file to create already exists, the
2048:               * directory entry of the existing file will be returned
2049:               * within the dir_entry parameter.
2050:               *
2051:               * \note The file name is not checked for invalid characters.
2052:               *
2053:               * \note The generation of the short 8.3 file name is quite
2054:               * simple. The first eight characters are used for the filename.
2055:               * The extension, if any, is made up of the first three characters
2056:               * following the last dot within the long filename. If the
2057:               * filename (without the extension) is longer than eight characters,
2058:               * the lower byte of the cluster number replaces the last two
2059:               * characters to avoid name clashes. In any other case, it is your
2060:               * responsibility to avoid name clashes.
2061:               *
2062:               * \param[in] parent The handle of the directory in which to create the file.
2063:               * \param[in] file The name of the file to create.
2064:               * \param[out] dir_entry The directory entry to fill for the new (or existing) file.
2065:               * \returns 0 on failure, 1 on success, 2 if the file already existed.
2066:               * \see fat_delete_file
2067:               */
2068:              uint8_t fat_create_file(struct fat_dir_struct* parent, const char* file, struct fat_dir_entry_struct* dir_entry)
2069:              {
2070:                  if(!parent || !file || !file[0] || !dir_entry)
2071:                      return 0;
2072:              
2073:                  /* check if the file already exists */
2074:                  while(1)
2075:                  {
2076:                      if(!fat_read_dir(parent, dir_entry))
2077:                          break;
2078:              
2079:                      if(strcmp(file, dir_entry->long_name) == 0)
2080:                      {
2081:                          fat_reset_dir(parent);
2082:                          return 2;
2083:                      }
2084:                  }
2085:              
2086:                  struct fat_fs_struct* fs = parent->fs;
2087:              
2088:                  /* prepare directory entry with values already known */
2089:                  memset(dir_entry, 0, sizeof(*dir_entry));
2090:                  strncpy(dir_entry->long_name, file, sizeof(dir_entry->long_name) - 1);
2091:              
2092:                  /* find place where to store directory entry */
2093:                  if(!(dir_entry->entry_offset = fat_find_offset_for_dir_entry(fs, parent, dir_entry)))
2094:                      return 0;
2095:                  
2096:                  /* write directory entry to disk */
2097:                  if(!fat_write_dir_entry(fs, dir_entry))
2098:                      return 0;
2099:                  
2100:                  return 1;
2101:              }
2102:              #endif
2103:              
2104:              #if DOXYGEN || FAT_WRITE_SUPPORT
2105:              /**
2106:               * \ingroup fat_file
2107:               * Deletes a file or directory.
2108:               *
2109:               * If a directory is deleted without first deleting its
2110:               * subdirectories and files, disk space occupied by these
2111:               * files will get wasted as there is no chance to release
2112:               * it and mark it as free.
2113:               * 
2114:               * \param[in] fs The filesystem on which to operate.
2115:               * \param[in] dir_entry The directory entry of the file to delete.
2116:               * \returns 0 on failure, 1 on success.
2117:               * \see fat_create_file
2118:               */
2119:              uint8_t fat_delete_file(struct fat_fs_struct* fs, struct fat_dir_entry_struct* dir_entry)
2120:              {
2121:                  if(!fs || !dir_entry)
2122:                      return 0;
2123:              
2124:                  /* get offset of the file's directory entry */
2125:                  offset_t dir_entry_offset = dir_entry->entry_offset;
2126:                  if(!dir_entry_offset)
2127:                      return 0;
2128:              
2129:              #if FAT_LFN_SUPPORT
2130:                  uint8_t buffer[12];
2131:                  while(1)
2132:                  {
2133:                      /* read directory entry */
2134:                      if(!fs->partition->device_read(dir_entry_offset, buffer, sizeof(buffer)))
2135:                          return 0;
2136:                      
2137:                      /* mark the directory entry as deleted */
2138:                      buffer[0] = FAT_DIRENTRY_DELETED;
2139:                      
2140:                      /* write back entry */
2141:                      if(!fs->partition->device_write(dir_entry_offset, buffer, sizeof(buffer)))
2142:                          return 0;
2143:              
2144:                      /* check if we deleted the whole entry */
2145:                      if(buffer[11] != 0x0f)
2146:                          break;
2147:              
2148:                      dir_entry_offset += 32;
2149:                  }
2150:              #else
2151:                  /* mark the directory entry as deleted */
2152:                  uint8_t first_char = FAT_DIRENTRY_DELETED;
2153:                  if(!fs->partition->device_write(dir_entry_offset, &first_char, 1))
2154:                      return 0;
2155:              #endif
2156:              
2157:                  /* We deleted the directory entry. The next thing to do is
2158:                   * marking all occupied clusters as free.
2159:                   */
2160:                  return (dir_entry->cluster == 0 || fat_free_clusters(fs, dir_entry->cluster));
2161:              }
2162:              #endif
2163:              
2164:              #if DOXYGEN || FAT_WRITE_SUPPORT
2165:              /**
2166:               * \ingroup fat_file
2167:               * Moves or renames a file.
2168:               *
2169:               * Changes a file's name, optionally moving it into another
2170:               * directory as well. Before calling this function, the
2171:               * target file name must not exist. Moving a file to a
2172:               * different filesystem (i.e. \a parent_new doesn't lie on
2173:               * \a fs) is not supported.
2174:               * 
2175:               * After successfully renaming (and moving) the file, the
2176:               * given directory entry is updated such that it points to
2177:               * the file's new location.
2178:               *
2179:               * \note The notes which apply to fat_create_file() also
2180:               * apply to this function.
2181:               *
2182:               * \param[in] fs The filesystem on which to operate.
2183:               * \param[in,out] dir_entry The directory entry of the file to move.
2184:               * \param[in] parent_new The handle of the new parent directory of the file.
2185:               * \param[in] file_new The file's new name.
2186:               * \returns 0 on failure, 1 on success.
2187:               * \see fat_create_file, fat_delete_file, fat_move_dir
2188:               */
2189:              uint8_t fat_move_file(struct fat_fs_struct* fs, struct fat_dir_entry_struct* dir_entry, struct fat_dir_struct* parent_new, const char* file_new)
2190:              {
2191:                  if(!fs || !dir_entry || !parent_new || (file_new && !file_new[0]))
2192:                      return 0;
2193:                  if(fs != parent_new->fs)
2194:                      return 0;
2195:              
2196:                  /* use existing file name if none has been specified */
2197:                  if(!file_new)
2198:                      file_new = dir_entry->long_name;
2199:              
2200:                  /* create file with new file name */
2201:                  struct fat_dir_entry_struct dir_entry_new;
2202:                  if(!fat_create_file(parent_new, file_new, &dir_entry_new))
2203:                      return 0;
2204:              
2205:                  /* copy members of directory entry which do not change with rename */
2206:                  dir_entry_new.attributes = dir_entry->attributes;
2207:              #if FAT_DATETIME_SUPPORT
2208:                  dir_entry_new.modification_time = dir_entry->modification_time;
2209:                  dir_entry_new.modification_date = dir_entry->modification_date;
2210:              #endif
2211:                  dir_entry_new.cluster = dir_entry->cluster;
2212:                  dir_entry_new.file_size = dir_entry->file_size;
2213:              
2214:                  /* make the new file name point to the old file's content */
2215:                  if(!fat_write_dir_entry(fs, &dir_entry_new))
2216:                  {
2217:                      fat_delete_file(fs, &dir_entry_new);
2218:                      return 0;
2219:                  }
2220:                  
2221:                  /* delete the old file, but not its clusters, which have already been remapped above */
2222:                  dir_entry->cluster = 0;
2223:                  if(!fat_delete_file(fs, dir_entry))
2224:                      return 0;
2225:              
2226:                  *dir_entry = dir_entry_new;
2227:                  return 1;
2228:              }
2229:              #endif
2230:              
2231:              #if DOXYGEN || FAT_WRITE_SUPPORT
2232:              /**
2233:               * \ingroup fat_dir
2234:               * Creates a directory.
2235:               *
2236:               * Creates a directory and obtains its directory entry.
2237:               * If the directory to create already exists, its
2238:               * directory entry will be returned within the dir_entry
2239:               * parameter.
2240:               *
2241:               * \note The notes which apply to fat_create_file() also
2242:               * apply to this function.
2243:               *
2244:               * \param[in] parent The handle of the parent directory of the new directory.
2245:               * \param[in] dir The name of the directory to create.
2246:               * \param[out] dir_entry The directory entry to fill for the new directory.
2247:               * \returns 0 on failure, 1 on success.
2248:               * \see fat_delete_dir
2249:               */
2250:              uint8_t fat_create_dir(struct fat_dir_struct* parent, const char* dir, struct fat_dir_entry_struct* dir_entry)
2251:              {
2252:                  if(!parent || !dir || !dir[0] || !dir_entry)
2253:                      return 0;
2254:              
2255:                  /* check if the file or directory already exists */
2256:                  while(fat_read_dir(parent, dir_entry))
2257:                  {
2258:                      if(strcmp(dir, dir_entry->long_name) == 0)
2259:                      {
2260:                          fat_reset_dir(parent);
2261:                          return 0;
2262:                      }
2263:                  }
2264:              
2265:                  struct fat_fs_struct* fs = parent->fs;
2266:              
2267:                  /* allocate cluster which will hold directory entries */
2268:                  cluster_t dir_cluster = fat_append_clusters(fs, 0, 1);
2269:                  if(!dir_cluster)
2270:                      return 0;
2271:              
2272:                  /* clear cluster to prevent bogus directory entries */
2273:                  fat_clear_cluster(fs, dir_cluster);
2274:                  
2275:                  memset(dir_entry, 0, sizeof(*dir_entry));
2276:                  dir_entry->attributes = FAT_ATTRIB_DIR;
2277:              
2278:                  /* create "." directory self reference */
2279:                  dir_entry->entry_offset = fs->header.cluster_zero_offset +
2280:                                            (offset_t) (dir_cluster - 2) * fs->header.cluster_size;
2281:                  dir_entry->long_name[0] = '.';
2282:                  dir_entry->cluster = dir_cluster;
2283:                  if(!fat_write_dir_entry(fs, dir_entry))
2284:                  {
2285:                      fat_free_clusters(fs, dir_cluster);
2286:                      return 0;
2287:                  }
2288:              
2289:                  /* create ".." parent directory reference */
2290:                  dir_entry->entry_offset += 32;
2291:                  dir_entry->long_name[1] = '.';
2292:                  dir_entry->cluster = parent->dir_entry.cluster;
2293:                  if(!fat_write_dir_entry(fs, dir_entry))
2294:                  {
2295:                      fat_free_clusters(fs, dir_cluster);
2296:                      return 0;
2297:                  }
2298:              
2299:                  /* fill directory entry */
2300:                  strncpy(dir_entry->long_name, dir, sizeof(dir_entry->long_name) - 1);
2301:                  dir_entry->cluster = dir_cluster;
2302:              
2303:                  /* find place where to store directory entry */
2304:                  if(!(dir_entry->entry_offset = fat_find_offset_for_dir_entry(fs, parent, dir_entry)))
2305:                  {
2306:                      fat_free_clusters(fs, dir_cluster);
2307:                      return 0;
2308:                  }
2309:              
2310:                  /* write directory to disk */
2311:                  if(!fat_write_dir_entry(fs, dir_entry))
2312:                  {
2313:                      fat_free_clusters(fs, dir_cluster);
2314:                      return 0;
2315:                  }
2316:              
2317:                  return 1;
2318:              }
2319:              #endif
2320:              
2321:              /**
2322:               * \ingroup fat_dir
2323:               * Deletes a directory.
2324:               *
2325:               * This is just a synonym for fat_delete_file().
2326:               * If a directory is deleted without first deleting its
2327:               * subdirectories and files, disk space occupied by these
2328:               * files will get wasted as there is no chance to release
2329:               * it and mark it as free.
2330:               * 
2331:               * \param[in] fs The filesystem on which to operate.
2332:               * \param[in] dir_entry The directory entry of the directory to delete.
2333:               * \returns 0 on failure, 1 on success.
2334:               * \see fat_create_dir
2335:               */
2336:              #ifdef DOXYGEN
2337:              uint8_t fat_delete_dir(struct fat_fs_struct* fs, struct fat_dir_entry_struct* dir_entry);
2338:              #endif
2339:              
2340:              /**
2341:               * \ingroup fat_dir
2342:               * Moves or renames a directory.
2343:               *
2344:               * This is just a synonym for fat_move_file().
2345:               * 
2346:               * \param[in] fs The filesystem on which to operate.
2347:               * \param[in,out] dir_entry The directory entry of the directory to move.
2348:               * \param[in] parent_new The handle of the new parent directory.
2349:               * \param[in] dir_new The directory's new name.
2350:               * \returns 0 on failure, 1 on success.
2351:               * \see fat_create_dir, fat_delete_dir, fat_move_file
2352:               */
2353:              #ifdef DOXYGEN
2354:              uint8_t fat_move_dir(struct fat_fs_struct* fs, struct fat_dir_entry_struct* dir_entry, struct fat_dir_struct* parent_new, const char* dir_new);
2355:              #endif
2356:              
2357:              #if DOXYGEN || FAT_DATETIME_SUPPORT
2358:              /**
2359:               * \ingroup fat_file
2360:               * Returns the modification date of a file.
2361:               *
2362:               * \param[in] dir_entry The directory entry of which to return the modification date.
2363:               * \param[out] year The year the file was last modified.
2364:               * \param[out] month The month the file was last modified.
2365:               * \param[out] day The day the file was last modified.
2366:               */
2367:              void fat_get_file_modification_date(const struct fat_dir_entry_struct* dir_entry, uint16_t* year, uint8_t* month, uint8_t* day)
2368:              {
2369:                  if(!dir_entry)
2370:                      return;
2371:              
2372:                  *year = 1980 + ((dir_entry->modification_date >> 9) & 0x7f);
2373:                  *month = (dir_entry->modification_date >> 5) & 0x0f;
2374:                  *day = (dir_entry->modification_date >> 0) & 0x1f;
2375:              }
2376:              #endif
2377:              
2378:              #if DOXYGEN || FAT_DATETIME_SUPPORT
2379:              /**
2380:               * \ingroup fat_file
2381:               * Returns the modification time of a file.
2382:               *
2383:               * \param[in] dir_entry The directory entry of which to return the modification time.
2384:               * \param[out] hour The hour the file was last modified.
2385:               * \param[out] min The min the file was last modified.
2386:               * \param[out] sec The sec the file was last modified.
2387:               */
2388:              void fat_get_file_modification_time(const struct fat_dir_entry_struct* dir_entry, uint8_t* hour, uint8_t* min, uint8_t* sec)
2389:              {
2390:                  if(!dir_entry)
2391:                      return;
2392:              
2393:                  *hour = (dir_entry->modification_time >> 11) & 0x1f;
2394:                  *min = (dir_entry->modification_time >> 5) & 0x3f;
2395:                  *sec = ((dir_entry->modification_time >> 0) & 0x1f) * 2;
2396:              }
2397:              #endif
2398:              
2399:              #if DOXYGEN || (FAT_WRITE_SUPPORT && FAT_DATETIME_SUPPORT)
2400:              /**
2401:               * \ingroup fat_file
2402:               * Sets the modification time of a date.
2403:               *
2404:               * \param[in] dir_entry The directory entry for which to set the modification date.
2405:               * \param[in] year The year the file was last modified.
2406:               * \param[in] month The month the file was last modified.
2407:               * \param[in] day The day the file was last modified.
2408:               */
2409:              void fat_set_file_modification_date(struct fat_dir_entry_struct* dir_entry, uint16_t year, uint8_t month, uint8_t day)
2410:              {
2411:                  if(!dir_entry)
2412:                      return;
2413:              
2414:                  dir_entry->modification_date =
2415:                      ((year - 1980) << 9) |
2416:                      ((uint16_t) month << 5) |
2417:                      ((uint16_t) day << 0);
2418:              }
2419:              #endif
2420:              
2421:              #if DOXYGEN || (FAT_WRITE_SUPPORT && FAT_DATETIME_SUPPORT)
2422:              /**
2423:               * \ingroup fat_file
2424:               * Sets the modification time of a file.
2425:               *
2426:               * \param[in] dir_entry The directory entry for which to set the modification time.
2427:               * \param[in] hour The year the file was last modified.
2428:               * \param[in] min The month the file was last modified.
2429:               * \param[in] sec The day the file was last modified.
2430:               */
2431:              void fat_set_file_modification_time(struct fat_dir_entry_struct* dir_entry, uint8_t hour, uint8_t min, uint8_t sec)
2432:              {
2433:                  if(!dir_entry)
2434:                      return;
2435:              
2436:                  dir_entry->modification_time =
2437:                      ((uint16_t) hour << 11) |
2438:                      ((uint16_t) min << 5) |
2439:                      ((uint16_t) sec >> 1) ;
2440:              }
2441:              #endif
2442:              
2443:              /**
2444:               * \ingroup fat_fs
2445:               * Returns the amount of total storage capacity of the filesystem in bytes.
2446:               *
2447:               * \param[in] fs The filesystem on which to operate.
2448:               * \returns 0 on failure, the filesystem size in bytes otherwise.
2449:               */
2450:              offset_t fat_get_fs_size(const struct fat_fs_struct* fs)
2451:              {
003056  780200     MOV W0, W4
2452:                  if(!fs)
00305A  520FE0     SUB W4, #0x0, [W15]
00305C  32000B     BRA Z, 0x3074
2453:                      return 0;
003058  B80060     MUL.UU W0, #0, W0
2454:              
2455:              #if FAT_FAT32_SUPPORT
2456:                  if(fs->partition->type == PARTITION_TYPE_FAT32)
2457:                      return (offset_t) (fs->header.fat_size / 4 - 2) * fs->header.cluster_size;
2458:                  else
2459:              #endif
2460:                      return (offset_t) (fs->header.fat_size / 2 - 2) * fs->header.cluster_size;
00305E  900054     MOV [W4+10], W0
003060  9000E4     MOV [W4+12], W1
003062  D10081     LSR W1, W1
003064  D38000     RRC W0, W0
003066  500362     SUB W0, #0x2, W6
003068  5883E0     SUBB W1, #0x0, W7
00306A  900804     MOV [W4+16], W0
00306C  200001     MOV #0x0, W1
00306E  B9BA00     MUL.SS W7, W0, W4
003070  B83000     MUL.UU W6, W0, W0
003072  420081     ADD W4, W1, W1
2461:              }
003074  060000     RETURN
2462:              
2463:              /**
2464:               * \ingroup fat_fs
2465:               * Returns the amount of free storage capacity on the filesystem in bytes.
2466:               *
2467:               * \note As the FAT filesystem is cluster based, this function does not
2468:               *       return continuous values but multiples of the cluster size.
2469:               *
2470:               * \param[in] fs The filesystem on which to operate.
2471:               * \returns 0 on failure, the free filesystem space in bytes otherwise.
2472:               */
2473:              offset_t fat_get_fs_free(const struct fat_fs_struct* fs)
2474:              {
003076  FA0024     LNK #0x24
003078  BE9F88     MOV.D W8, [W15++]
00307A  BE9F8A     MOV.D W10, [W15++]
00307C  BE9F8C     MOV.D W12, [W15++]
00307E  780680     MOV W0, W13
2475:                  if(!fs)
003082  568FE0     SUB W13, #0x0, [W15]
003084  32002A     BRA Z, 0x30DA
2476:                      return 0;
003080  B80060     MUL.UU W0, #0, W0
2477:              
2478:                  uint8_t fat[32];
2479:                  struct fat_usage_count_callback_arg count_arg;
2480:                  count_arg.cluster_count = 0;
003086  EB0200     CLR W4
003088  9FBF84     MOV W4, [W15-16]
2481:                  count_arg.buffer_size = sizeof(fat);
00308A  200204     MOV #0x20, W4
00308C  9FBF94     MOV W4, [W15-14]
2482:              
2483:                  offset_t fat_offset = fs->header.fat_offset;
00308E  90043D     MOV [W13+6], W8
003090  9004CD     MOV [W13+8], W9
2484:                  uint32_t fat_size = fs->header.fat_size;
003092  90055D     MOV [W13+10], W10
003094  9005ED     MOV [W13+12], W11
2485:                  while(fat_size > 0)
003096  550FE0     SUB W10, #0x0, [W15]
003098  5D8FE0     SUBB W11, #0x0, [W15]
00309A  32001A     BRA Z, 0x30D0
0030C8  320003     BRA Z, 0x30D0
2486:                  {
2487:                      uintptr_t length = UINTPTR_MAX - 1;
00309C  2FFFEC     MOV #0xFFFE, W12
2488:                      if(fat_size < length)
00309E  2FFFD4     MOV #0xFFFD, W4
0030A0  200005     MOV #0x0, W5
0030A2  550F84     SUB W10, W4, [W15]
0030A4  5D8F85     SUBB W11, W5, [W15]
0030A6  3E0001     BRA GTU, 0x30AA
2489:                          length = fat_size;
0030A8  78060A     MOV W10, W12
2490:              
2491:                      if(!fs->partition->device_read_interval(fat_offset,
0030AA  78021D     MOV [W13], W4
0030AC  900394     MOV [W4+2], W7
0030AE  578370     SUB W15, #0x10, W6
0030B0  229AA5     MOV #0x29AA, W5
0030B2  78020C     MOV W12, W4
0030B4  200203     MOV #0x20, W3
0030B6  2FFD02     MOV #0xFFD0, W2
0030B8  41010F     ADD W2, W15, W2
0030BA  BE0008     MOV.D W8, W0
0030BC  010007     CALL W7
0030BE  504FE0     SUB.B W0, #0x0, [W15]
0030C0  32000B     BRA Z, 0x30D8
2492:                                                              fat,
2493:                                                              sizeof(fat),
2494:                                                              length,
2495:              #if FAT_FAT32_SUPPORT
2496:                                                              (fs->partition->type == PARTITION_TYPE_FAT16) ?
2497:                                                                  fat_get_fs_free_16_callback :
2498:                                                                  fat_get_fs_free_32_callback,
2499:              #else
2500:                                                              fat_get_fs_free_16_callback,
2501:              #endif
2502:                                                              &count_arg
2503:                                                             )
2504:                        )
2505:                          return 0;
0030D8  B80060     MUL.UU W0, #0, W0
2506:              
2507:                      fat_offset += length;
0030C2  B86261     MUL.UU W12, #1, W4
0030CA  420408     ADD W4, W8, W8
0030CC  4A8489     ADDC W5, W9, W9
0030CE  37FFE6     BRA 0x309C
2508:                      fat_size -= length;
0030C4  550504     SUB W10, W4, W10
0030C6  5D8585     SUBB W11, W5, W11
2509:                  }
2510:              
2511:                  return (offset_t) count_arg.cluster_count * fs->header.cluster_size;
0030D0  90080D     MOV [W13+16], W0
0030D2  97BA0F     MOV [W15-16], W4
0030D4  B80004     MUL.UU W0, W4, W0
0030D6  370001     BRA 0x30DA
2512:              }
0030DA  BE064F     MOV.D [--W15], W12
0030DC  BE054F     MOV.D [--W15], W10
0030DE  BE044F     MOV.D [--W15], W8
0030E0  FA8000     ULNK
0030E2  060000     RETURN
2513:              
2514:              /**
2515:               * \ingroup fat_fs
2516:               * Callback function used for counting free clusters in a FAT.
2517:               */
2518:              uint8_t fat_get_fs_free_16_callback(uint8_t* buffer, offset_t offset, void* p)
2519:              {
0029AA  BE9F88     MOV.D W8, [W15++]
0029AC  BE9F8A     MOV.D W10, [W15++]
0029AE  780480     MOV W0, W9
0029B0  780581     MOV W1, W11
2520:                  struct fat_usage_count_callback_arg* count_arg = (struct fat_usage_count_callback_arg*) p;
2521:                  uintptr_t buffer_size = count_arg->buffer_size;
0029B2  90051B     MOV [W11+2], W10
2522:                  unsigned i;
2523:                  for(i = 0; i < buffer_size; i += 2, buffer += 2)
0029B4  550FE0     SUB W10, #0x0, [W15]
0029B6  32000B     BRA Z, 0x29CE
0029B8  EB0400     CLR W8
0029C4  E88408     INC2 W8, W8
0029C6  550F88     SUB W10, W8, [W15]
0029C8  360002     BRA LEU, 0x29CE
0029CA  E88489     INC2 W9, W9
0029CC  37FFF6     BRA 0x29BA
2524:                  {
2525:                      uint16_t cluster = read16(buffer);
0029BA  780009     MOV W9, W0
0029BC  0710D1     RCALL read16
2526:                      if(cluster == HTOL16(FAT16_CLUSTER_FREE))
0029BE  500FE0     SUB W0, #0x0, [W15]
0029C0  3A0001     BRA NZ, 0x29C4
2527:                          ++(count_arg->cluster_count);
0029C2  E80D9B     INC [W11], [W11]
2528:                  }
2529:              
2530:                  return 1;
2531:              }
0029CE  B3C010     MOV.B #0x1, W0
0029D0  BE054F     MOV.D [--W15], W10
0029D2  BE044F     MOV.D [--W15], W8
0029D4  060000     RETURN
2532:              
2533:              #if DOXYGEN || FAT_FAT32_SUPPORT
2534:              /**
2535:               * \ingroup fat_fs
2536:               * Callback function used for counting free clusters in a FAT32.
2537:               */
2538:              uint8_t fat_get_fs_free_32_callback(uint8_t* buffer, offset_t offset, void* p)
2539:              {
2540:                  struct fat_usage_count_callback_arg* count_arg = (struct fat_usage_count_callback_arg*) p;
2541:                  uintptr_t buffer_size = count_arg->buffer_size;
2542:              
2543:                  for(uintptr_t i = 0; i < buffer_size; i += 4, buffer += 4)
2544:                  {
2545:                      uint32_t cluster = read32(buffer);
2546:                      if(cluster == HTOL32(FAT32_CLUSTER_FREE))
2547:                          ++(count_arg->cluster_count);
2548:                  }
2549:              
2550:                  return 1;
2551:              }
2552:              #endif
2553:              
---  C:/Users/Jacques/Documents/GitHub/PicVisionPortable/PICVisionPortable.X/FAT/byteordering.c  --------
1:                 
2:                 /*
3:                  * Copyright (c) 2006-2012 by Roland Riegel <feedback@roland-riegel.de>
4:                  *
5:                  * This file is free software; you can redistribute it and/or modify
6:                  * it under the terms of either the GNU General Public License version 2
7:                  * or the GNU Lesser General Public License version 2.1, both as
8:                  * published by the Free Software Foundation.
9:                  */
10:                
11:                #include "byteordering.h"
12:                
13:                /**
14:                 * \addtogroup byteordering
15:                 *
16:                 * Architecture-dependent handling of byte-ordering.
17:                 *
18:                 * @{
19:                 */
20:                /**
21:                 * \file
22:                 * Byte-order handling implementation (license: GPLv2 or LGPLv2.1)
23:                 *
24:                 * \author Roland Riegel
25:                 */
26:                
27:                #if DOXYGEN || SWAP_NEEDED
28:                
29:                /**
30:                 * \internal
31:                 * Swaps the bytes of a 16-bit integer.
32:                 *
33:                 * \param[in] i A 16-bit integer which to swap.
34:                 * \returns The swapped 16-bit integer.
35:                 */
36:                uint16_t swap16(uint16_t i)
37:                {
38:                    return SWAP16(i);
39:                }
40:                
41:                /**
42:                 * \internal
43:                 * Swaps the bytes of a 32-bit integer.
44:                 *
45:                 * \param[in] i A 32-bit integer which to swap.
46:                 * \returns The swapped 32-bit integer.
47:                 */
48:                uint32_t swap32(uint32_t i)
49:                {
50:                    return SWAP32(i);
51:                }
52:                
53:                #endif
54:                
55:                /**
56:                 * Reads a 16-bit integer from memory in little-endian byte order.
57:                 *
58:                 * \param[in] p Pointer from where to read the integer.
59:                 * \returns The 16-bit integer read from memory.
60:                 */
61:                uint16_t read16(const uint8_t* p)
62:                {
63:                    return (((uint16_t) p[1]) << 8) |
004B60  904210     MOV.B [W0+1], W4
004B62  DD2248     SL W4, #8, W4
004B68  700004     IOR W0, W4, W0
64:                           (((uint16_t) p[0]) << 0);
004B64  784010     MOV.B [W0], W0
004B66  FB8000     ZE W0, W0
65:                }
004B6A  060000     RETURN
66:                
67:                /**
68:                 * Reads a 32-bit integer from memory in little-endian byte order.
69:                 *
70:                 * \param[in] p Pointer from where to read the integer.
71:                 * \returns The 32-bit integer read from memory.
72:                 */
73:                uint32_t read32(const uint8_t* p)
74:                {
75:                    return (((uint32_t) p[3]) << 24) |
004B6C  904330     MOV.B [W0+3], W6
004B6E  DD33C8     SL W6, #8, W7
004B70  200006     MOV #0x0, W6
004B78  730304     IOR W6, W4, W6
004B7A  738385     IOR W7, W5, W7
004B94  730004     IOR W6, W4, W0
004B96  738085     IOR W7, W5, W1
76:                           (((uint32_t) p[2]) << 16) |
004B72  904220     MOV.B [W0+2], W4
004B74  FB8284     ZE W4, W5
004B76  200004     MOV #0x0, W4
004B82  730304     IOR W6, W4, W6
004B84  738385     IOR W7, W5, W7
77:                           (((uint32_t) p[1]) <<  8) |
004B86  904010     MOV.B [W0+1], W0
004B88  FB8000     ZE W0, W0
004B8A  200001     MOV #0x0, W1
004B8C  DD0A48     SL W1, #8, W4
004B8E  DE02C8     LSR W0, #8, W5
004B90  720285     IOR W4, W5, W5
004B92  DD0248     SL W0, #8, W4
78:                           (((uint32_t) p[0]) <<  0);
004B7C  784210     MOV.B [W0], W4
004B7E  FB8204     ZE W4, W4
004B80  200005     MOV #0x0, W5
79:                }
004B98  060000     RETURN
80:                
81:                /**
82:                 * Writes a 16-bit integer into memory in little-endian byte order.
83:                 *
84:                 * \param[in] p Pointer where to write the integer to.
85:                 * \param[in] i The 16-bit integer to write.
86:                 */
87:                void write16(uint8_t* p, uint16_t i)
88:                {
89:                    p[1] = (uint8_t) ((i & 0xff00) >> 8);
004B9A  DE0A48     LSR W1, #8, W4
004B9C  984014     MOV.B W4, [W0+1]
90:                    p[0] = (uint8_t) ((i & 0x00ff) >> 0);
004B9E  784801     MOV.B W1, [W0]
91:                }
004BA0  060000     RETURN
92:                
93:                /**
94:                 * Writes a 32-bit integer into memory in little-endian byte order.
95:                 *
96:                 * \param[in] p Pointer where to write the integer to.
97:                 * \param[in] i The 32-bit integer to write.
98:                 */
99:                void write32(uint8_t* p, uint32_t i)
100:               {
101:                   p[3] = (uint8_t) ((i & 0xff000000) >> 24);
004BA2  DE1A48     LSR W3, #8, W4
004BA4  200005     MOV #0x0, W5
004BA6  984034     MOV.B W4, [W0+3]
102:                   p[2] = (uint8_t) ((i & 0x00ff0000) >> 16);
004BA8  984023     MOV.B W3, [W0+2]
103:                   p[1] = (uint8_t) ((i & 0x0000ff00) >>  8);
004BAA  2FF004     MOV #0xFF00, W4
004BAC  620202     AND W4, W2, W4
004BAE  200005     MOV #0x0, W5
004BB0  DD2B48     SL W5, #8, W6
004BB2  DE2248     LSR W4, #8, W4
004BB4  730204     IOR W6, W4, W4
004BB6  DE2AC8     LSR W5, #8, W5
004BB8  984014     MOV.B W4, [W0+1]
104:                   p[0] = (uint8_t) ((i & 0x000000ff) >>  0);
004BBA  784802     MOV.B W2, [W0]
105:               }
004BBC  060000     RETURN
106:               
107:               /**
108:                * @}
109:                */
110:               
